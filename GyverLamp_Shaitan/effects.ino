// ============= ЭФФЕКТЫ ===============
//Сюда планируем перенести все переменные

float speedfactor;                                 // регулятор скорости в эффектах реального времени

#define trackingOBJECT_MAX_COUNT                         (100U)  // максимальное количество отслеживаемых объектов (очень влияет на расход памяти)
float   trackingObjectPosX[trackingOBJECT_MAX_COUNT];
float   trackingObjectPosY[trackingOBJECT_MAX_COUNT];
float   trackingObjectSpeedX[trackingOBJECT_MAX_COUNT];
float   trackingObjectSpeedY[trackingOBJECT_MAX_COUNT];
float   trackingObjectShift[trackingOBJECT_MAX_COUNT];
uint8_t trackingObjectHue[trackingOBJECT_MAX_COUNT];
uint8_t trackingObjectState[trackingOBJECT_MAX_COUNT];
#define enlargedOBJECT_MAX_COUNT                     (WIDTH * 2) // максимальное количество сложных отслеживаемых объектов (меньше, чем trackingOBJECT_MAX_COUNT)
uint8_t enlargedObjectNUM;                                       // используемое в эффекте количество объектов
bool    enlargedObjectIsShift[enlargedOBJECT_MAX_COUNT];
long    enlargedObjectTime[enlargedOBJECT_MAX_COUNT];

#define NUM_LAYERS 1 

#define NUM_LAYERSMAX 2
uint32_t noise32_x[NUM_LAYERSMAX];
uint32_t noise32_y[NUM_LAYERSMAX];
uint32_t noise32_z[NUM_LAYERSMAX];
uint32_t scale32_x[NUM_LAYERSMAX];
uint32_t scale32_y[NUM_LAYERSMAX];

uint8_t shiftHue[HEIGHT];                          // свойство пикселей в размер столбца матрицы
uint8_t shiftValue[HEIGHT];                        // свойство пикселей в размер столбца матрицы ещё одно
uint16_t ff_x, ff_y, ff_z;                         // большие счётчики


// дополнительные палитры для пламени
// для записи в PROGMEM преобразовывал из 4 цветов в 16 на сайте https://colordesigner.io/gradient-generator, но не уверен, что это эквивалент CRGBPalette16()
// значения цветовых констант тут: https://github.com/FastLED/FastLED/wiki/Pixel-reference
extern const TProgmemRGBPalette16 WoodFireColors_p FL_PROGMEM = {CRGB::Black, 0x330e00, 0x661c00, 0x992900, 0xcc3700, CRGB::OrangeRed, 0xff5800, 0xff6b00, 0xff7f00, 0xff9200, CRGB::Orange, 0xffaf00, 0xffb900, 0xffc300, 0xffcd00, CRGB::Gold};             //* Orange
extern const TProgmemRGBPalette16 NormalFire_p FL_PROGMEM = {CRGB::Black, 0x330000, 0x660000, 0x990000, 0xcc0000, CRGB::Red, 0xff0c00, 0xff1800, 0xff2400, 0xff3000, 0xff3c00, 0xff4800, 0xff5400, 0xff6000, 0xff6c00, 0xff7800};                             // пытаюсь сделать что-то более приличное
extern const TProgmemRGBPalette16 NormalFire2_p FL_PROGMEM = {CRGB::Black, 0x560000, 0x6b0000, 0x820000, 0x9a0011, CRGB::FireBrick, 0xc22520, 0xd12a1c, 0xe12f17, 0xf0350f, 0xff3c00, 0xff6400, 0xff8300, 0xffa000, 0xffba00, 0xffd400};                      // пытаюсь сделать что-то более приличное
extern const TProgmemRGBPalette16 LithiumFireColors_p FL_PROGMEM = {CRGB::Black, 0x240707, 0x470e0e, 0x6b1414, 0x8e1b1b, CRGB::FireBrick, 0xc14244, 0xd16166, 0xe08187, 0xf0a0a9, CRGB::Pink, 0xff9ec0, 0xff7bb5, 0xff59a9, 0xff369e, CRGB::DeepPink};        //* Red
extern const TProgmemRGBPalette16 SodiumFireColors_p FL_PROGMEM = {CRGB::Black, 0x332100, 0x664200, 0x996300, 0xcc8400, CRGB::Orange, 0xffaf00, 0xffb900, 0xffc300, 0xffcd00, CRGB::Gold, 0xf8cd06, 0xf0c30d, 0xe9b913, 0xe1af1a, CRGB::Goldenrod};           //* Yellow
extern const TProgmemRGBPalette16 CopperFireColors_p FL_PROGMEM = {CRGB::Black, 0x001a00, 0x003300, 0x004d00, 0x006600, CRGB::Green, 0x239909, 0x45b313, 0x68cc1c, 0x8ae626, CRGB::GreenYellow, 0x94f530, 0x7ceb30, 0x63e131, 0x4bd731, CRGB::LimeGreen};     //* Green
extern const TProgmemRGBPalette16 AlcoholFireColors_p FL_PROGMEM = {CRGB::Black, 0x000033, 0x000066, 0x000099, 0x0000cc, CRGB::Blue, 0x0026ff, 0x004cff, 0x0073ff, 0x0099ff, CRGB::DeepSkyBlue, 0x1bc2fe, 0x36c5fd, 0x51c8fc, 0x6ccbfb, CRGB::LightSkyBlue};  //* Blue
extern const TProgmemRGBPalette16 RubidiumFireColors_p FL_PROGMEM = {CRGB::Black, 0x0f001a, 0x1e0034, 0x2d004e, 0x3c0068, CRGB::Indigo, CRGB::Indigo, CRGB::Indigo, CRGB::Indigo, CRGB::Indigo, CRGB::Indigo, 0x3c0084, 0x2d0086, 0x1e0087, 0x0f0089, CRGB::DarkBlue};        //* Indigo
extern const TProgmemRGBPalette16 PotassiumFireColors_p FL_PROGMEM = {CRGB::Black, 0x0f001a, 0x1e0034, 0x2d004e, 0x3c0068, CRGB::Indigo, 0x591694, 0x682da6, 0x7643b7, 0x855ac9, CRGB::MediumPurple, 0xa95ecd, 0xbe4bbe, 0xd439b0, 0xe926a1, CRGB::DeepPink}; //* Violet
const TProgmemRGBPalette16 *firePalettes[] = {
//    &HeatColors_p, // эта палитра уже есть в основном наборе. если в эффекте подключены оба набора палитр, тогда копия не нужна
    &WoodFireColors_p,
    &NormalFire_p,
    &NormalFire2_p,
    &LithiumFireColors_p,
    &SodiumFireColors_p,
    &CopperFireColors_p,
    &AlcoholFireColors_p,
    &RubidiumFireColors_p,
    &PotassiumFireColors_p};


// ------------- конфетти --------------
#define FADE_OUT_SPEED        (70U)                         // скорость затухания
void sparklesRoutine()
{
  for (uint8_t i = 0; i < modes[EFF_SPARKLES].Scale; i++)
  {
    uint8_t x = random(0U, WIDTH);
    uint8_t y = random(0U, HEIGHT);
    if (getPixColorXY(x, y) == 0U)
    {
      leds[getPixelNumber(x, y)] = CHSV(random(0U, 255U), 255U, 255U);
    }
  }
  dimAll(256U - FADE_OUT_SPEED);
//  fader(FADE_OUT_SPEED);
}

// функция плавного угасания цвета для всех пикселей
/*
void fader(uint8_t step)
{
  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    for (uint8_t j = 0U; j < HEIGHT; j++)
    {
      fadePixel(i, j, step);
    }
  }
}
*/
void fadePixel(uint8_t i, uint8_t j, uint8_t step)          // новый фейдер
{
  int32_t pixelNum = getPixelNumber(i, j);
  if (getPixColor(pixelNum) == 0U) return;

  if (leds[pixelNum].r >= 30U ||
      leds[pixelNum].g >= 30U ||
      leds[pixelNum].b >= 30U)
  {
    leds[pixelNum].fadeToBlackBy(step);
  }
  else
  {
    leds[pixelNum] = 0U;
  }
}

// ------------- огонь -----------------
#define SPARKLES              (1U)                          // вылетающие угольки вкл выкл
uint8_t pcnt = 0U;

//these values are substracetd from the generated values to give a shape to the animation
static const uint8_t valueMask[8][16] PROGMEM =
{
  {0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0   },
  {32 , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 0  , 32  },
  {64 , 32 , 0  , 0  , 32 , 0  , 0  , 0  , 0  , 0  , 0  , 32 , 0  , 0  , 32 , 64  },
  {96 , 64 , 0  , 32 , 64 , 32 , 0  , 0  , 0  , 0  , 32 , 64 , 32 , 0  , 64 , 96  },
  {128, 96 , 32 , 64 , 96 , 64 , 32 , 0  , 0  , 32 , 64 , 96 , 64 , 32 , 96 , 128 },
  {160, 128, 64 , 96 , 128, 96 , 64 , 0  , 0  , 64 , 96 , 128, 96 , 64 , 128, 160 },
  {192, 160, 96 , 128, 160, 128, 96 , 32 , 32 , 96 , 128, 160, 128, 96 , 160, 192 },
  {255, 192, 128, 160, 192, 160, 128, 64 , 64 , 128, 160, 192, 160, 128, 192, 255 }
};                     
                                    
//these are the hues for the fire,
//should be between 0 (red) to about 25 (yellow)
static const uint8_t hueMask[8][16] PROGMEM =
{
  {25, 22, 11, 1 , 1 , 11, 19, 25, 25, 22, 11, 1, 1 , 11, 19, 25 },
  {25, 19, 8 , 1 , 1 , 8 , 13, 19, 25, 19, 8 , 1, 1 , 8 , 13, 19 },
  {19, 16, 8 , 1 , 1 , 8 , 13, 16, 19, 16, 8 , 1, 1 , 8 , 13, 16 },
  {13, 13, 5 , 1 , 1 , 5 , 11, 13, 13, 13, 5 , 1, 1 , 5 , 11, 13 },
  {11, 11, 5 , 1 , 1 , 5 , 11, 11, 11, 11, 5 , 1, 1 , 5 , 11, 11 },
  {8 , 5 , 1 , 0 , 0 , 1 , 5 , 8 , 8 , 5 , 1 , 0, 0 , 1 , 5 , 8  },
  {5 , 1 , 0 , 0 , 0 , 0 , 1 , 5 , 5 , 1 , 0 , 0, 0 , 0 , 1 , 5  },
  {1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0, 0 , 0 , 0 , 1  }
};

void fireRoutine(bool isColored)                            // true - цветной огонь, false - белый
{
/*
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();
    generateLine();
    memset(matrixValue, 0, sizeof(matrixValue));
  }
*/
  if (pcnt >= 100)
  {
    shiftUp();
    generateLine();
    pcnt = 0;
  }
  drawFrame(pcnt, isColored);
  pcnt += 30;
}

// Randomly generate the next line (matrix row)
void generateLine()
{
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    line[x] = random(64, 255);
  }
}

void shiftUp()
{
  for (uint8_t y = HEIGHT - 1U; y > 0U; y--)
  {
    for (uint8_t x = 0U; x < WIDTH; x++)
    {
      uint8_t newX = x;
      if (x > 15U) newX = x % 16U;
      if (y > 7U) continue;
      matrixValue[y][newX] = matrixValue[y - 1U][newX];
    }
  }

  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    uint8_t newX = x;
    if (x > 15U) newX = x % 16U;
    matrixValue[0U][newX] = line[newX];
  }
}

// draw a frame, interpolating between 2 "key frames"
// @param pcnt percentage of interpolation

void drawFrame(uint8_t pcnt, bool isColored)
{
  int32_t nextv;

  //each row interpolates with the one before it
  for (uint8_t y = HEIGHT - 1U; y > 0U; y--)
  {
    for (uint8_t x = 0U; x < WIDTH; x++)
    {
      uint8_t newX = x;
      if (x > 15U) newX = x % 16U;
      if (y < 8U)
      {
        nextv =
          (((100.0 - pcnt) * matrixValue[y][newX]
            + pcnt * matrixValue[y - 1][newX]) / 100.0)
          - pgm_read_byte(&valueMask[y][newX]);

        CRGB color = CHSV(
          isColored ? modes[EFF_FIRE].Scale * 2.5 + pgm_read_byte(&hueMask[y][newX]) : 0U,     // H
          isColored ? 255U : 0U,                                                               // S
          (uint8_t)max(0, nextv)                                                               // V
        );

        leds[getPixelNumber(x, y)] = color;
      }
      else if (y == 8U && SPARKLES)
      {
        if (random(0, 20) == 0 && getPixColorXY(x, y - 1U) != 0U) drawPixelXY(x, y, getPixColorXY(x, y - 1U));
        else drawPixelXY(x, y, 0U);
      }
      else if (SPARKLES)
      {
        // старая версия для яркости
        if (getPixColorXY(x, y - 1U) > 0U)
          drawPixelXY(x, y, getPixColorXY(x, y - 1U));
        else drawPixelXY(x, y, 0U);
      }
    }
  }

  //first row interpolates with the "next" line
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    uint8_t newX = x;
    if (x > 15U) newX = x % 16U;
    CRGB color = CHSV(
      isColored ? modes[EFF_FIRE].Scale * 2.5 + pgm_read_byte(&(hueMask[0][newX])): 0U,        // H
      isColored ? 255U : 0U,                                                                   // S
      (uint8_t)(((100.0 - pcnt) * matrixValue[0][newX] + pcnt * line[newX]) / 100.0)           // V
    );
    //leds[getPixelNumber(newX, 0)] = color;                                         // на форуме пишут что это ошибка - вместо newX должно быть x, иначе
    leds[getPixelNumber(x, 0)] = color;                                              // на матрицах шире 16 столбцов нижний правый угол неработает
  }
}

// ------------- радуга вертикальная ----------------
// uint8_t hue; Перенесено в GyverLamp_Shaitan.ino
void rainbowVerticalRoutine()
{
  hue += 4;
  for (uint8_t j = 0; j < HEIGHT; j++)
  {
    CHSV thisColor = CHSV((uint8_t)(hue + j * modes[EFF_RAINBOW_VER].Scale/4), 255, 255);
    for (uint8_t i = 0U; i < WIDTH; i++)
    {
      drawPixelXY(i, j, thisColor);
    }
  }
}

// ------------- радуга горизонтальная ----------------
void rainbowHorizontalRoutine()
{
  hue += 4;
  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    CHSV thisColor = CHSV((uint8_t)(hue + i * modes[EFF_RAINBOW_HOR].Scale/4), 255, 255);
    for (uint8_t j = 0U; j < HEIGHT; j++)
    {
      drawPixelXY(i, j, thisColor);
    }
  }
}

// ------------- радуга диагональная -------------
void rainbowDiagonalRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();
  }

  hue += 8;
  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    for (uint8_t j = 0U; j < HEIGHT; j++)
    {
      float twirlFactor = 3.0F * (modes[EFF_RAINBOW_DIAG].Scale / 100.0F);      // на сколько оборотов будет закручена матрица, [0..3]
      CRGB thisColor = CHSV((uint8_t)(hue + (float)(WIDTH / HEIGHT * i + j * twirlFactor) * (float)(255 / maxDim)), 255, 255);
      drawPixelXY(i, j, thisColor);
    }
  }
}

// ------------- цвета -----------------
void colorsRoutine()
{
    hue++;

    for (uint16_t i = 0U; i < NUM_LEDS; i++)
    {
      leds[i] = CHSV(hue, modes[currentMode].Scale*2.55, 255U);
    }
}

// ------------- цвет ------------------
void colorRoutine()
{
//    FastLED.clear();

    for (int16_t i = 0U; i < NUM_LEDS; i++)
    {
      leds[i] = CHSV(modes[currentMode].Scale * 2.55, modes[currentMode].Speed, 255U);
    }
}

// ------------- снегопад ----------
void snowRoutine()
{
  // сдвигаем всё вниз
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    for (uint8_t y = 0U; y < HEIGHT - 1; y++)
    {
      drawPixelXY(x, y, getPixColorXY(x, y + 1U));
    }
  }

  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    // заполняем случайно верхнюю строку
    // а также не даём двум блокам по вертикали вместе быть
    if (getPixColorXY(x, HEIGHT - 2U) == 0U && (random(0, 101 - modes[EFF_SNOW].Scale) == 0U))
      drawPixelXY(x, HEIGHT - 1U, 0xE0FFFF - 0x101010 * random(0, 4));
    else
      drawPixelXY(x, HEIGHT - 1U, 0x000000);
  }
//  delay (map(modes[currentMode].Speed,1,255,50,20));
}

// ------------- метель -------------
#define SNOW_DENSE            (60U)                         // плотность снега
#define SNOW_TAIL_STEP        (100U)                        // длина хвоста
#define SNOW_SATURATION       (0U)                          // насыщенность (от 0 до 255)
void snowStormRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();
  }

  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    if (getPixColorXY(i, HEIGHT - 1U) == 0U &&
       (random(0, 101-modes[currentMode].Scale) == 0U) &&
        getPixColorXY(i + 1U, HEIGHT - 1U) == 0U &&
        getPixColorXY(i - 1U, HEIGHT - 1U) == 0U)
    {
      leds[getPixelNumber(i, HEIGHT - 1U)] = CHSV(random(0, 200), SNOW_SATURATION, 255U);
    }
  }

  // сдвигаем по диагонали
  for (uint8_t y = 0U; y < HEIGHT - 1U; y++)
  {
    for (uint8_t x = WIDTH - 1U; x > 0U; x--)
    {
      drawPixelXY(x, y, getPixColorXY(x - 1U, y + 1U));
    }
    drawPixelXY(0, y, getPixColorXY(WIDTH - 1U, y + 1U));
  }

  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    fadePixel(i, HEIGHT - 1U, SNOW_TAIL_STEP);
  }
//  delay (map(modes[currentMode].Speed,1,255,50,20));
}

// ------------- звездопад -------------
#define STAR_DENSE            (60U)                         // плотность комет
#define STAR_TAIL_STEP        (100U)                        // длина хвоста кометы
#define STAR_SATURATION       (150U)                        // насыщенность кометы (от 0 до 255)
void starfallRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();
  }
 
  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    if (getPixColorXY(i, HEIGHT - 1U) == 0U &&
       (random(0, 101-modes[currentMode].Scale) == 0U) &&
        getPixColorXY(i + 1U, HEIGHT - 1U) == 0U &&
        getPixColorXY(i - 1U, HEIGHT - 1U) == 0U)
    {
      leds[getPixelNumber(i, HEIGHT - 1U)] = CHSV(random(0, 200), STAR_SATURATION, 255U);
    }
  }

  // сдвигаем по диагонали
  for (uint8_t y = 0U; y < HEIGHT - 1U; y++)
  {
    for (uint8_t x = WIDTH - 1U; x > 0U; x--)
    {
      drawPixelXY(x, y, getPixColorXY(x - 1U, y + 1U));
    }
    drawPixelXY(0U, y, getPixColorXY(WIDTH - 1U, y + 1U));
  }

  for (uint8_t i = 0U; i < WIDTH; i++)
  {
    fadePixel(i, HEIGHT - 1U, STAR_TAIL_STEP);
  }
}

// ------------- матрица ---------------
void matrixRoutine()
{
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    // заполняем случайно верхнюю строку
    CRGB thisColor = getPixColorXY(x, HEIGHT - 1U);
    if ((uint32_t)thisColor == 0U)
    {
     if (random(0, 100-modes[currentMode].Scale) == 0U)
      drawPixelXY(x, HEIGHT - 1U, CHSV(random(0, 9) * 28, 255U, 255U));
    }
    else
       leds[getPixelNumber(x,HEIGHT - 1U)]-=CHSV(0,0,random(96, 128));
//       leds[getPixelNumber(x,HEIGHT - 1U)]-=CHSV(0,0,128);
  }
  // сдвигаем всё вниз
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    for (uint8_t y = 0U; y < HEIGHT - 1U; y++)
    {
      drawPixelXY(x, y, getPixColorXY(x, y + 1U));
    }
  }

/*  
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    // заполняем случайно верхнюю строку
    uint32_t thisColor = getPixColorXY(x, HEIGHT - 1U);
    if (thisColor == 0U)
      drawPixelXY(x, HEIGHT - 1U, 0x00FF00 * (random(0, 100 - modes[EFF_MATRIX].Scale) == 0U));
    else if (thisColor < 0x002000)
      drawPixelXY(x, HEIGHT - 1U, 0U);
    else
      drawPixelXY(x, HEIGHT - 1U, thisColor - 0x002000);
  }

  // сдвигаем всё вниз
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    for (uint8_t y = 0U; y < HEIGHT - 1U; y++)
    {
      drawPixelXY(x, y, getPixColorXY(x, y + 1U));
    }
  }
 */ 
}

// ------------- светлячки --------------
#define LIGHTERS_AM           (100U)
int32_t lightersPos[2U][LIGHTERS_AM];
int8_t lightersSpeed[2U][LIGHTERS_AM];
CHSV lightersColor[LIGHTERS_AM];
uint8_t loopCounter;
int32_t angle[LIGHTERS_AM];
int32_t speedV[LIGHTERS_AM];
int8_t angleSpeed[LIGHTERS_AM];
void lightersRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    randomSeed(millis());
    for (uint8_t i = 0U; i < LIGHTERS_AM; i++)
    {
      lightersPos[0U][i] = random(0, WIDTH * 10);
      lightersPos[1U][i] = random(0, HEIGHT * 10);
      lightersSpeed[0U][i] = random(-10, 10);
      lightersSpeed[1U][i] = random(-10, 10);
      lightersColor[i] = CHSV(random(0U, 255U), 255U, 255U);
    }
  }
  FastLED.clear();
  if (++loopCounter > 20U) loopCounter = 0U;
  for (uint8_t i = 0U; i < modes[EFF_LIGHTERS].Scale; i++)
  {
    if (loopCounter == 0U)                                  // меняем скорость каждые 255 отрисовок
    {
      lightersSpeed[0U][i] += random(-3, 4);
      lightersSpeed[1U][i] += random(-3, 4);
      lightersSpeed[0U][i] = constrain(lightersSpeed[0U][i], -20, 20);
      lightersSpeed[1U][i] = constrain(lightersSpeed[1U][i], -20, 20);
    }

    lightersPos[0U][i] += lightersSpeed[0U][i];
    lightersPos[1U][i] += lightersSpeed[1U][i];

    if (lightersPos[0U][i] < 0) lightersPos[0U][i] = (WIDTH - 1) * 10;
    if (lightersPos[0U][i] >= (int32_t)(WIDTH * 10)) lightersPos[0U][i] = 0;

    if (lightersPos[1U][i] < 0)
    {
      lightersPos[1U][i] = 0;
      lightersSpeed[1U][i] = -lightersSpeed[1U][i];
    }
    if (lightersPos[1U][i] >= (int32_t)(HEIGHT - 1) * 10)
    {
      lightersPos[1U][i] = (HEIGHT - 1U) * 10;
      lightersSpeed[1U][i] = -lightersSpeed[1U][i];
    }
    drawPixelXY(lightersPos[0U][i] / 10, lightersPos[1U][i] / 10, lightersColor[i]);
  }
}

// ------------- светлячки со шлейфом -------------
#define BALLS_AMOUNT          (10U)                          // количество "шариков"
#define CLEAR_PATH            (1U)                          // очищать путь
#define BALL_TRACK            (1U)                          // (0 / 1) - вкл/выкл следы шариков
#define TRACK_STEP            (70U)                         // длина хвоста шарика (чем больше цифра, тем хвост короче)
int16_t coord[BALLS_AMOUNT][2U];
int8_t vector[BALLS_AMOUNT][2U];
CRGB ballColors[BALLS_AMOUNT];
void ballsRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;

    for (uint8_t j = 0U; j < map(modes[currentMode].Scale,0,100,1,10); j++)
    {
      int8_t sign;
      // забиваем случайными данными
      coord[j][0U] = WIDTH / 2 * 10;
      random(0, 2) ? sign = 1 : sign = -1;
      vector[j][0U] = random(4, 15) * sign;
      coord[j][1U] = HEIGHT / 2 * 10;
      random(0, 2) ? sign = 1 : sign = -1;
      vector[j][1U] = random(4, 15) * sign;
      ballColors[j] = CHSV(random(0, 9) * 28, 255U, 255U);
    }
  }

  if (!BALL_TRACK)                                          // режим без следов шариков
  {
    FastLED.clear();
  }
  else                                                      // режим со следами
  {
    dimAll(256U - TRACK_STEP);
    // fader(TRACK_STEP);
  }

  // движение шариков
  for (uint8_t j = 0U; j < BALLS_AMOUNT; j++)
  {
    // движение шариков
    for (uint8_t i = 0U; i < 2U; i++)
    {
      coord[j][i] += vector[j][i];
      if (coord[j][i] < 0)
      {
        coord[j][i] = 0;
        vector[j][i] = -vector[j][i];
      }
    }

    if (coord[j][0U] > (int16_t)((WIDTH - 1) * 10))
    {
      coord[j][0U] = (WIDTH - 1) * 10;
      vector[j][0U] = -vector[j][0U];
    }
    if (coord[j][1U] > (int16_t)((HEIGHT - 1) * 10))
    {
      coord[j][1U] = (HEIGHT - 1) * 10;
      vector[j][1U] = -vector[j][1U];
    }
    leds[getPixelNumber(coord[j][0U] / 10, coord[j][1U] / 10)] =  ballColors[j];
  }
}

// ------------- пейнтбол -------------
const uint8_t BorderWidth = 2U;
void lightBallsRoutine()
{
  // Apply some blurring to whatever's already on the matrix
  // Note that we never actually clear the matrix, we just constantly
  // blur it repeatedly.  Since the blurring is 'lossy', there's
  // an automatic trend toward black -- by design.
  uint8_t blurAmount = dim8_raw(beatsin8(3,64,100));
  blur2d(leds, WIDTH, HEIGHT, blurAmount);

  // Use two out-of-sync sine waves
  uint8_t  i = beatsin8(  91, BorderWidth, WIDTH-BorderWidth);
  uint8_t  j = beatsin8( 109, BorderWidth, WIDTH-BorderWidth);
  uint8_t  k = beatsin8(  73, BorderWidth, WIDTH-BorderWidth);
  uint8_t  m = beatsin8( 123, BorderWidth, WIDTH-BorderWidth);

  // The color of each point shifts over time, each at a different speed.
  uint16_t ms = millis();
  leds[getPixelNumber( i, j)] += CHSV( ms / 29, 200U, 255U);
  leds[getPixelNumber( j, k)] += CHSV( ms / 41, 200U, 255U);
  leds[getPixelNumber( k, m)] += CHSV( ms / 73, 200U, 255U);
  leds[getPixelNumber( m, i)] += CHSV( ms / 97, 200U, 255U);

}
// Trivial XY function for the SmartMatrix; use a different XY
// function for different matrix grids. See XYMatrix example for code.
uint16_t XY(uint8_t x, uint8_t y)
{
  uint16_t i;
  if (y & 0x01)
  {
    // Odd rows run backwards
    uint8_t reverseX = (WIDTH - 1) - x;
    i = (y * WIDTH) + reverseX;
  }
  else
  {
    // Even rows run forwards
    i = (y * WIDTH) + x;
  }
  return i;
}

// ------------- блуждающий кубик -------------
//      
#define RANDOM_COLOR          (1U)                          // случайный цвет при отскоке
int16_t coordB[2U];
int16_t coordBold[2U];
int8_t vectorB[2U];
CRGB ballColor;
int8_t ballSize;
bool boom;
void ballRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    //FastLED.clear();

    for (uint8_t i = 0U; i < 2U; i++)
    {
      coordB[i] = WIDTH / 2 * 10;
      vectorB[i] = random(8, 20);
      boom=false;
    }
  }
  uint8_t x;
  uint8_t y;
  boom=true;
  for (x =0; x<WIDTH; x++)
    for (y =0; y<HEIGHT; y++)
      if (paint[x][y].r+paint[x][y].g+paint[x][y].b>0)  boom=false;  

  if (boom)
   {
    #ifdef GENERAL_DEBUG
    LOG.println(F("Picure_all CRGB(0,0,0) "));
    #endif
    
    loadingFlag=true;
    PaintRoutine(true);
    boom=true; // проверяем, если рисунка нет, то создаем
    for (x =0; x<WIDTH; x++)
      for (y =0; y<HEIGHT; y++)
        if (paint[x][y].r+paint[x][y].g+paint[x][y].b>0)  boom=false;  
     if (boom) {
      #ifdef GENERAL_DEBUG
        LOG.println(F("Picure from EEPROM all CRGB(0,0,0) "));
      #endif
      for (y =0; y<HEIGHT/2; y++)
       {
        paint[0][y]        =CHSV(map(y,0,HEIGHT,0,255) , 255, 255 );
        paint[WIDTH-1][y]  =CHSV(map(y,0,HEIGHT,0,255) , 255, 255 );
       } 
      for (y = HEIGHT/2; y<HEIGHT; y++)
       {
        paint[WIDTH/2][y]  =CHSV(map(y,0,HEIGHT,0,255) , 255, 255 );
        paint[WIDTH/2+1][y]=CHSV(map(y,0,HEIGHT,0,255) , 255, 255 );
       } 
      
     }

    boom=false;       
   }
  ballColor = CHSV(modes[currentMode].Scale * 2.55, 255U, 255U); //CHSV(random(0, 9) * 28, 255U, 255U);
  ballSize = map(modes[EFF_CUBE].Scale, 0U, 255U, 2U, max((uint8_t)min(WIDTH,HEIGHT) / 3, 2));
  for (uint8_t i = 0U; i < 2U; i++)  coordB[i] += vectorB[i];
    if (coordB[1] < 0)
    {
      coordB[1] = 0;
      vectorB[1] = -vectorB[1];
      if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
    }
  //Движение шарика по цилиндру
  if (coordB[0] < 0) coordB[0]+=WIDTH*10;
  if (coordB[0] >WIDTH*10) coordB[0]-=WIDTH*10;

  if (coordB[1U] > (int16_t)((HEIGHT - ballSize) * 10))
  {
    coordB[1U] = (HEIGHT - ballSize) * 10;
    vectorB[1U] = -vectorB[1U];
    if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
    // vectorB[1] += random(0, 6) - 3;
  }
//Проверить отскоки
  x=coordB[0U]/10;
  y=coordB[1U]/10;
  if (vectorB[0U]>0)
   {
     if ((getPixColorXYCylinder(x+2,y)>0) || (getPixColorXYCylinder(x+2,y+1)>0))
     {
       vectorB[0U] = Change_Vector(vectorB[0U],x+2,y,0);
       if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
     }
   } else
   {
     if ((getPixColorXYCylinder(x-1,y)>0) || (getPixColorXYCylinder(x-1,y+1)>0))
     {
       vectorB[0U] = Change_Vector(vectorB[0U],x-1,y,0);
      if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
     }
   }   
  if (vectorB[1U]>0)
   {
     if (y<HEIGHT-ballSize && getPixColorXYCylinder(x,y+2)>0)
     {
       vectorB[1U] = Change_Vector(vectorB[0U],x,y+2,1);
       if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
     }
   } else
   {
     if (y>1 && getPixColorXYCylinder(x,y-1)>0) 
     {
       vectorB[1U] = Change_Vector(vectorB[0U],x,y-1,1);
       if (RANDOM_COLOR) ballColor = CHSV(random(0, 9) * 28, 255U, 255U);
     }
   }   


//  FastLED.clear();
//  SaluteFadeAll(64);
//  Кубик на рисованном поле
  loadingFlag=true;
  PaintRoutine(false);
//
  for (uint8_t i = 0U; i < ballSize; i++)
  {
    for (uint8_t j = 0U; j < ballSize; j++)
    {
      drawPixelXYCylinder(coordB[0U] / 10 + i, coordB[1U] / 10 + j,ballColor);
    }
  }
}

int16_t Change_Vector(int8_t vector, int8_t x, int8_t y, uint8_t dxy)
{
  int8_t new_vector=vector;
  uint8_t dx=(dxy==0)?1:0;
  uint8_t dy=(dxy==0)?0:1;
  if (random(0, 9) ==0) paint[x][y]=CRGB(0,0,0);
  if (random(0, 9) ==0) paint[x+dx][y+dy]=CRGB(0,0,0);
  if (vector<0) if (random(0, 9) ==0) paint[x-dx][y-dy]=CRGB(0,0,0);
  if (vector>0) if (random(0, 9) ==0) paint[x+2*dx][y+2*dy]=CRGB(0,0,0);
  new_vector += random(0, 7) - 3;
  if (new_vector==0) new_vector=vector;
  if (abs(new_vector)>25) new_vector=vector;
  
  return -vector;
}
// ------------- белый свет -------------
void whiteColorRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();

    for (uint16_t i = 0U; i < NUM_LEDS; i++)
    {
      leds[i] = CHSV(0U, 0U, 255U);
    }
  }
}

// ------------- белый свет (светится горизонтальная полоса по центру лампы; масштаб - высота центральной горизонтальной полосы; скорость - регулировка от холодного к тёплому; яркость - общая яркость) -------------
/*void whiteColorStripeRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();
    delay(1);

    uint8_t centerY = max((uint8_t)round(HEIGHT / 2.0F) - 1, 0);
    uint8_t bottomOffset = (uint8_t)(!(HEIGHT & 1) && (HEIGHT > 1));                      // если высота матрицы чётная, линий с максимальной яркостью две, а линии с минимальной яркостью снизу будут смещены на один ряд
    for (int16_t y = centerY; y >= 0; y--)
    {
      CRGB color = CHSV(
        45U,                                                                              // определяем тон
        map(modes[EFF_WHITE_COLOR].Speed, 0U, 255U, 0U, 170U),                            // определяем насыщенность
        y == centerY                                                                                                    // определяем яркость
          ? 255U                                                                                                        // для центральной горизонтальной полосы (или двух) яркость всегда равна 255
          : (modes[EFF_WHITE_COLOR].Scale / 100.0F) > ((centerY + 1.0F) - (y + 1.0F)) / (centerY + 1.0F) ? 255U : 0U);  // для остальных горизонтальных полос яркость равна либо 255, либо 0 в зависимости от масштаба

      for (uint8_t x = 0U; x < WIDTH; x++)
      {
        drawPixelXY(x, y, color);                                                         // при чётной высоте матрицы максимально яркими отрисуются 2 центральных горизонтальных полосы
        drawPixelXY(x, max((uint8_t)(HEIGHT - 1U) - (y + 1U) + bottomOffset, 0U), color); // при нечётной - одна, но дважды
      }
    }
  }
}
*/
// ------------- ещё более белый свет (с вертикальным вариантом) -------------
// (c) SottNick
#define BORDERLAND   2 // две дополнительные единицы бегунка Масштаб на границе вертикального и горизонтального варианта эффекта (с каждой стороны границы) будут для света всеми светодиодами в полную силу
void whiteColorStripeRoutine()
{
  if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();

    uint8_t thisSize = HEIGHT;
    uint8_t halfScale = modes[currentMode].Scale;
    if (halfScale > 50U)
    {
      thisSize = WIDTH;
      halfScale = 101U - halfScale;
    }
    halfScale = constrain(halfScale, 0U, 50U - BORDERLAND);

    uint8_t center =  (uint8_t)round(thisSize / 2.0F) - 1U;
    uint8_t offset = (uint8_t)(!(thisSize & 0x01));
   
    uint8_t fullFill =  center / (50.0 - BORDERLAND) * halfScale;
    uint8_t iPol = (center / (50.0 - BORDERLAND) * halfScale - fullFill) * 255;
   
    for (int16_t i = center; i >= 0; i--)
    {
      CRGB color = CHSV(
                     45U,                                                                              // определяем тон
                     map(modes[currentMode].Speed, 0U, 255U, 0U, 170U),                                // определяем насыщенность
                     i > (center - fullFill - 1)                                                       // определяем яркость
                     ? 255U                                                                            // для центральных горизонтальных полос
                     : iPol * (i > center - fullFill - 2));  // для остальных горизонтальных полос яркость равна либо 255, либо 0 в зависимости от масштаба

      if (modes[currentMode].Scale <= 50U)
        for (uint8_t x = 0U; x < WIDTH; x++)
        {
          drawPixelXY(x, i, color);                         // при чётной высоте матрицы максимально яркими отрисуются 2 центральных горизонтальных полосы
          drawPixelXY(x, HEIGHT + offset - i - 2U, color);  // при нечётной - одна, но дважды
        }
      else
        for (uint8_t y = 0U; y < HEIGHT; y++)
        {
          // со смещением вертикальной полосы
//          drawPixelXY((i + modes[currentMode].Speed - 1U) % WIDTH, y, color);                    // при чётной высоте матрицы максимально яркими отрисуются 2 центральных вертикальных полосы
//          drawPixelXY((WIDTH + offset - i + modes[currentMode].Speed - 3U) % WIDTH, y, color);   // при нечётной - одна, но дважды
          // вертикальная полоса по центру
          drawPixelXY(i, y, color);                    // при чётной высоте матрицы максимально яркими отрисуются 2 центральных вертикальных полосы
          drawPixelXY(WIDTH + offset - i - 2U, y, color);   // при нечётной - одна, но дважды
        }
    }
  }
}
// ------------- мигающий цвет (не эффект! используется для отображения краткосрочного предупреждения; блокирующий код!) -------------
#define WARNING_BRIGHTNESS    (10U)                         // яркость вспышки
void showWarning(
  CRGB color,                                               /* цвет вспышки                                                 */
  uint32_t duration,                                        /* продолжительность отображения предупреждения (общее время)   */
  uint16_t blinkHalfPeriod)                                 /* продолжительность одной вспышки в миллисекундах (полупериод) */
{
  uint32_t blinkTimer = millis();
  enum BlinkState { OFF = 0, ON = 1 } blinkState = BlinkState::OFF;
  FastLED.setBrightness(WARNING_BRIGHTNESS);                // установка яркости для предупреждения
  FastLED.clear();
  delay(2);
  FastLED.show();

  for (uint16_t i = 0U; i < NUM_LEDS; i++)                  // установка цвета всех диодов в WARNING_COLOR
  {
    leds[i] = color;
  }

  uint32_t startTime = millis();
  while (millis() - startTime <= (duration + 5))            // блокировка дальнейшего выполнения циклом на время отображения предупреждения
  {
    if (millis() - blinkTimer >= blinkHalfPeriod)           // переключение вспышка/темнота
    {
      blinkTimer = millis();
      blinkState = (BlinkState)!blinkState;
      FastLED.setBrightness(blinkState == BlinkState::OFF ? 0 : WARNING_BRIGHTNESS);
      delay(1);
      FastLED.show();
    }
    delay(50);
  }

  FastLED.clear();
  FastLED.setBrightness(ONflag ? modes[currentMode].Brightness : 0);  // установка яркости, которая была выставлена до вызова предупреждения
  delay(1);
  FastLED.show();
  loadingFlag = true;                                       // принудительное отображение текущего эффекта (того, что был активен перед предупреждением)
}


// =============- ЭКС-новый огонь / водопад -===============
// COOLING: How much does the air cool as it rises?
// Less cooling = taller flames.  More cooling = shorter flames.
// Default 55, suggested range 20-100
#define COOLINGNEW 32
// 8  практически сплошной поток красивой подсвеченной воды ровным потоком сверху донизу. будто бы на столе стоит маленький "родничок"
// 20 ровный водопад с верщиной на свету, где потоки летящей воды наверху разбиваются ветром в белую пену
// 32 уже не ровный водопад, у которого струи воды долетают до земли неравномерно
// чем больше параметр, тем больше тени снизу
// 55 такое, как на первом видео

// SPARKING: What chance (out of 255) is there that a new spark will be lit?
// Higher chance = more roaring fire.  Lower chance = more flickery fire.
// Default 120, suggested range 50-200.
#define SPARKINGNEW 80 // 30 // 120 // 90 // 60
// 80 почти все белые струи сверху будут долетать до низа - хорошо при выбранном ползунке Масштаб = 100 (белая вода без подкрашивания)
// 50 чуть больше половины будет долетать. для цветных вариантов жидкости так более эффектно

// палитра для типа реалистичного водопада (если ползунок Масштаб выставить на 100)
extern const TProgmemRGBPalette16 WaterfallColors_p FL_PROGMEM = {
  0x000000, 0x060707, 0x101110, 0x151717,
  0x1C1D22, 0x242A28, 0x363B3A, 0x313634,
  0x505552, 0x6B6C70, 0x98A4A1, 0xC1C2C1,
  0xCACECF, 0xCDDEDD, 0xDEDFE0, 0xB2BAB9
};

void fire2012WithPalette(){
//    bool fire_water = modes[currentMode].Scale <= 50;
//    uint8_t COOLINGNEW = fire_water ? modes[currentMode].Scale * 2  + 20 : (100 - modes[currentMode].Scale ) *  2 + 20 ;
//    uint8_t COOLINGNEW = modes[currentMode].Scale * 2  + 20 ;
    // Array of temperature readings at each simulation cell
    static byte heat[WIDTH][HEIGHT];

    for(uint8_t x = 0; x < WIDTH; x++) {
      // Step 1.  Cool down every cell a little
      for (int i = 0; i < HEIGHT; i++) {
          heat[x][i] = qsub8(heat[x][i], random8(0, ((COOLINGNEW * 10) / HEIGHT) + 2));
      }

      // Step 2.  Heat from each cell drifts 'up' and diffuses a little
      for (int k = HEIGHT - 1; k >= 2; k--) {
          heat[x][k] = (heat[x][k - 1] + heat[x][k - 2] + heat[x][k - 2]) / 3;
      }

      // Step 3.  Randomly ignite new 'sparks' of heat near the bottom
      if (random8() < SPARKINGNEW) {
          int y = random8(2);
          heat[x][y] = qadd8(heat[x][y], random8(160, 255));
      }

      // Step 4.  Map from heat cells to LED colors
      for (int j = 0; j < HEIGHT; j++) {
          // Scale the heat value from 0-255 down to 0-240
          // for best results with color palettes.
          byte colorindex = scale8(heat[x][j], 240);
          if (modes[currentMode].Scale == 100)
            leds[getPixelNumber(x, (HEIGHT - 1) - j)] = ColorFromPalette(WaterfallColors_p, colorindex);
          else
            leds[getPixelNumber(x, (HEIGHT - 1) - j)] = ColorFromPalette(CRGBPalette16( CRGB::Black, CHSV(modes[currentMode].Scale * 2.57, 255U, 255U) , CHSV(modes[currentMode].Scale* 2.5, 128U, 255U) , CRGB::White), colorindex);
      }
    }
}

// --------------------------- эффект кометы ----------------------

// далее идут общие процедуры для эффектов от Stefan Petrick, а непосредственно Комета - в самом низу
CRGB ledsbuff[NUM_LEDS];
const uint8_t e_centerX =  (WIDTH / 2) - 1;
const uint8_t e_centerY = (HEIGHT / 2) - 1;
int8_t zD;
int8_t zF;
// The coordinates for 3 16-bit noise spaces.
#define NUM_LAYERS 1

uint32_t e_x[NUM_LAYERS];
uint32_t e_y[NUM_LAYERS];
uint32_t e_z[NUM_LAYERS];
uint32_t e_scaleX[NUM_LAYERS];
uint32_t e_scaleY[NUM_LAYERS];

uint8_t noise3d[NUM_LAYERS][WIDTH][HEIGHT];

uint8_t eNs_noisesmooth;
bool eNs_isSetupped;

void eNs_setup() {
  eNs_noisesmooth = 200;
  for (int i = 0; i < NUM_LAYERS; i++) {
    e_x[i] = random16();
    e_y[i] = random16();
    e_z[i] = random16();
    e_scaleX[i] = 6000;
    e_scaleY[i] = 6000;
  }
  eNs_isSetupped = true;
}

void FillNoise(int8_t layer) {
  for (int8_t i = 0; i < WIDTH; i++) {
    int32_t ioffset = e_scaleX[layer] * (i - e_centerX);
    for (int8_t j = 0; j < HEIGHT; j++) {
      int32_t joffset = e_scaleY[layer] * (j - e_centerY);
      int8_t data = inoise16(e_x[layer] + ioffset, e_y[layer] + joffset, e_z[layer]) >> 8;
      int8_t olddata = noise3d[layer][i][j];
      int8_t newdata = scale8( olddata, eNs_noisesmooth ) + scale8( data, 255 - eNs_noisesmooth );
      data = newdata;
      noise3d[layer][i][j] = data;
    }
  }
}

void MoveX(int8_t delta) {
  //CLS2();
  for (int8_t y = 0; y < HEIGHT; y++) {
    for (int8_t x = 0; x < WIDTH - delta; x++) {
      ledsbuff[XY(x, y)] = leds[getPixelNumber(x + delta, y)];
    }
    for (int8_t x = WIDTH - delta; x < WIDTH; x++) {
      ledsbuff[XY(x, y)] = leds[getPixelNumber(x + delta - WIDTH, y)];
    }
  }
  //CLS();
  // write back to leds
  for (uint8_t y = 0; y < HEIGHT; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      leds[getPixelNumber(x, y)] = ledsbuff[XY(x, y)];
    }
  }
}

void MoveY(int8_t delta) {
  //CLS2();
  for (int8_t x = 0; x < WIDTH; x++) {
    for (int8_t y = 0; y < HEIGHT - delta; y++) {
      ledsbuff[XY(x, y)] = leds[getPixelNumber(x, y + delta)];
    }
    for (int8_t y = HEIGHT - delta; y < HEIGHT; y++) {
      ledsbuff[XY(x, y)] = leds[getPixelNumber(x, y + delta - HEIGHT)];
    }
  }
  //CLS();
  // write back to leds
  for (uint8_t y = 0; y < HEIGHT; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      leds[getPixelNumber(x, y)] = ledsbuff[XY(x, y)];
    }
  }
}

void MoveFractionalNoiseX(int8_t amplitude = 1, float shift = 0) {
  for (int8_t y = 0; y < HEIGHT; y++) {
    int16_t amount = ((int16_t)noise3d[0][0][y] - 128) * 2 * amplitude + shift * 256  ;
    int8_t delta = abs(amount) >> 8 ;
    int8_t fraction = abs(amount) & 255;
    for (int8_t x = 0 ; x < WIDTH; x++) {
      if (amount < 0) {
        zD = x - delta; zF = zD - 1;
      } else {
        zD = x + delta; zF = zD + 1;
      }
      CRGB PixelA = CRGB::Black  ;
      if ((zD >= 0) && (zD < WIDTH)) PixelA = leds[getPixelNumber(zD, y)];
      CRGB PixelB = CRGB::Black ;
      if ((zF >= 0) && (zF < WIDTH)) PixelB = leds[getPixelNumber(zF, y)];
      ledsbuff[XY(x, y)] = (PixelA.nscale8(ease8InOutApprox(255 - fraction))) + (PixelB.nscale8(ease8InOutApprox(fraction)));   // lerp8by8(PixelA, PixelB, fraction );
    }
  }
  memcpy(leds, ledsbuff, sizeof(CRGB)* NUM_LEDS);
}

void MoveFractionalNoiseY(int8_t amplitude = 1, float shift = 0) {
  for (int8_t x = 0; x < WIDTH; x++) {
    int16_t amount = ((int16_t)noise3d[0][x][0] - 128) * 2 * amplitude + shift * 256 ;
    int8_t delta = abs(amount) >> 8 ;
    int8_t fraction = abs(amount) & 255;
    for (int8_t y = 0 ; y < WIDTH; y++) {
      if (amount < 0) {
        zD = y - delta; zF = zD - 1;
      } else {
        zD = y + delta; zF = zD + 1;
      }
      CRGB PixelA = CRGB::Black ;
      if ((zD >= 0) && (zD < WIDTH)) PixelA = leds[getPixelNumber(x, zD)];
      CRGB PixelB = CRGB::Black ;
      if ((zF >= 0) && (zF < WIDTH)) PixelB = leds[getPixelNumber(x, zF)];
      ledsbuff[XY(x, y)] = (PixelA.nscale8(ease8InOutApprox(255 - fraction))) + (PixelB.nscale8(ease8InOutApprox(fraction)));
    }
  }
  memcpy(leds, ledsbuff, sizeof(CRGB)* NUM_LEDS);
}
// NoiseSmearing(by StefanPetrick) Effect mod for GyverLamp by PalPalych 
void MultipleStream() { // 2 comets
  dimAll(192); // < -- затухание эффекта для последующего кадрв

  // gelb im Kreis
  byte xx = 2 + sin8( millis() / 10) / 22;
  byte yy = 2 + cos8( millis() / 10) / 22;
  leds[getPixelNumber( xx, yy)] = 0xFFFF00;

  // rot in einer Acht
  xx = 4 + sin8( millis() / 46) / 32;
  yy = 4 + cos8( millis() / 15) / 32;
  leds[getPixelNumber( xx, yy)] = 0xFF0000;

  // Noise
  e_x[0] += 3000;
  e_y[0] += 3000;
  e_z[0] += 3000;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  MoveFractionalNoiseX(3, 0.33);
  MoveFractionalNoiseY(3);
}

void MultipleStream2() { // 3 comets
  dimAll(192); // < -- затухание эффекта для последующего кадра. В мини кометах можно установить регулятор затухания побольше, например от 192 до 252 - хвосты будут подлиннее
  byte xx = 2 + sin8( millis() / 10) / 22;
  byte yy = 2 + cos8( millis() / 9) / 22;
  leds[getPixelNumber( xx, yy)] += 0x0000FF;

  xx = 4 + sin8( millis() / 10) / 32;
  yy = 4 + cos8( millis() / 7) / 32;
  leds[getPixelNumber( xx, yy)] += 0xFF0000;
  leds[getPixelNumber( e_centerX, e_centerY)] += 0xFFFF00;

  e_x[0] += 3000;
  e_y[0] += 3000;
  e_z[0] += 3000;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  MoveFractionalNoiseX(2);
  MoveFractionalNoiseY(2, 0.33);
}

void MultipleStream3() { // Fireline
  dimAll(160); // < -- затухание эффекта для последующего кадрв
  for (uint8_t i = 1; i < WIDTH; i += 3) {
    leds[getPixelNumber( i, e_centerY)] += CHSV(i * 2 , 255, 255);
  }
  // Noise
  e_x[0] += 3000;
  e_y[0] += 3000;
  e_z[0] += 3000;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  MoveFractionalNoiseY(3);
  MoveFractionalNoiseX(3);
}

void MultipleStream4() { // Comet
  dimAll(184); // < -- затухание эффекта для последующего кадрв
  CRGB _eNs_color = CHSV(millis(), 255, 255);
  leds[getPixelNumber( e_centerX, e_centerY)] += _eNs_color;
  // Noise
  e_x[0] += 2000;
  e_y[0] += 2000;
  e_z[0] += 2000;
  e_scaleX[0] = 4000;
  e_scaleY[0] = 4000;
  FillNoise(0);
  MoveFractionalNoiseX(6);
  MoveFractionalNoiseY(5, -0.5);
}

void MultipleStream5() { // Fractorial Fire
  dimAll(140); // < -- затухание эффекта для последующего кадрв
  for (uint8_t i = 1; i < WIDTH; i += 2) {
    leds[getPixelNumber( i, HEIGHT - 1)] += CHSV(i * 2, 255, 255);
  }
  // Noise
  e_x[0] += 3000;
  e_y[0] += 3000;
  e_z[0] += 3000;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  //MoveX(1);
  //MoveY(1);
  MoveFractionalNoiseY(3, 1);
  MoveFractionalNoiseX(2);
}

void MultipleStream8() { // Windows ))
  dimAll(96); // < -- затухание эффекта для последующего кадрв на 96/255*100=37%
  for (uint8_t y = 2; y < HEIGHT; y += 5) {
    for (uint8_t x = 2; x < WIDTH; x += 5) {
      leds[getPixelNumber(x, y)]  += CHSV(x * y , 255, 255);
      leds[getPixelNumber(x + 1, y)] += CHSV((x + 4) * y, 255, 255);
      leds[getPixelNumber(x, y + 1)] += CHSV(x * (y + 4), 255, 255);
      leds[getPixelNumber(x + 1, y + 1)] += CHSV((x + 4) * (y + 4), 255, 255);
    }
  }
  // Noise
  e_x[0] += 3000;
  e_y[0] += 3000;
  e_z[0] += 3000;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  MoveFractionalNoiseX(3);
  MoveFractionalNoiseY(3);
}

void NoiseStreaming(uint8_t scale = 0) {
  if (!eNs_isSetupped)eNs_setup;
  uint8_t _selector = constrain(scale / 16, 0, 5);
  uint8_t _scale = constrain((uint8_t)scale % 17, 0, 15);

  if (_selector == 0) MultipleStream();
  if (_selector == 1) MultipleStream2();
  if (_selector == 2) MultipleStream3();
  if (_selector == 3) MultipleStream4(); // Rainbow comet
  if (_selector == 4) MultipleStream5();
  if (_selector == 5) MultipleStream8();
}

// прописывается, если ранее нигде не была объявленв
void dimAll(uint8_t value) {
  for (uint16_t i = 0; i < NUM_LEDS; i++) {
    leds[i].nscale8(value); //fadeToBlackBy
  }
}

//  Follow the Rainbow Comet by Palpalych (Effect for GyverLamp 02/03/2020) //
void RainbowComet(uint8_t scale = 4) { // Rainbow Comet by PalPalych
  dimAll(254U); // < -- затухание эффекта для последующего кадра
  CRGB _eNs_color = CRGB::White;
  if (scale < 50) {
    _eNs_color = CHSV(millis() / scale * 4, 255, 255);
  } else if (scale < 100) {
    _eNs_color = CHSV((scale - 50) * 5, 255, 255);
  }
  leds[getPixelNumber(e_centerX, e_centerY)] += _eNs_color;
  leds[getPixelNumber(e_centerX + 1, e_centerY)] += _eNs_color;
  leds[getPixelNumber(e_centerX, e_centerY + 1)] += _eNs_color;
  leds[getPixelNumber(e_centerX + 1, e_centerY + 1)] += _eNs_color;

  // Noise
  e_x[0] += 1500;
  e_y[0] += 1500;
  e_z[0] += 1500;
  e_scaleX[0] = 8000;
  e_scaleY[0] = 8000;
  FillNoise(0);
  MoveFractionalNoiseX(WIDTH / 2U - 1U);
  MoveFractionalNoiseY(HEIGHT / 2U - 1U);
}

void RainbowCometRoutine() {      // <- ******* для оригинальной прошивки Gunner47 ******* (раскомментить/закоментить)
  RainbowComet(modes[currentMode].Scale);    // <--- вызов эффекта с параметрами Rainbow Comet by PalPalych
}

void NoiseStreamingRoutine() {      // <- ******* для оригинальной прошивки Gunner47 ******* (раскомментить/закоментить)
  NoiseStreaming(modes[currentMode].Scale);  // <--- вызов эффекта с параметрами Noise Smearing by StefanPetrick
}



// --------------------------- эффект пульс ----------------------
// Stefan Petrick's PULSE Effect mod by PalPalych for GyverLamp
// Подключен вместо эффекты кубики

void dimAll2(uint8_t value) { // это копия процедуры dimAll на случай, если эффект будет устанавливаться отдельно от остальных
  for (uint16_t i = 0; i < NUM_LEDS; i++) {
    leds[i].nscale8(value); //fadeToBlackBy
  }
}
void drawCircle(int16_t x0, int16_t y0, uint16_t radius, const CRGB & color){
  int a = radius, b = 0;
  int radiusError = 1 - a;

  if (radius == 0) {
    drawPixelXY(x0, y0, color);
    return;
  }

  while (a >= b)  {
    drawPixelXY(a + x0, b + y0, color);
    drawPixelXY(b + x0, a + y0, color);
    drawPixelXY(-a + x0, b + y0, color);
    drawPixelXY(-b + x0, a + y0, color);
    drawPixelXY(-a + x0, -b + y0, color);
    drawPixelXY(-b + x0, -a + y0, color);
    drawPixelXY(a + x0, -b + y0, color);
    drawPixelXY(b + x0, -a + y0, color);
    b++;
    if (radiusError < 0)
      radiusError += 2 * b + 1;
    else
    {
      a--;
      radiusError += 2 * (b - a + 1);
    }
  }
}

CRGBPalette16 palette;
CRGB _pulse_color;
uint8_t step;
uint8_t currentRadius = 4;
uint8_t centerX = random8(WIDTH - 5U) + 3U;
uint8_t centerY = random8(HEIGHT - 5U) + 3U;
uint16_t _rc;
uint8_t _pulse_hue;
uint8_t _pulse_hueall;
uint8_t _pulse_delta;
uint8_t pulse_hue;
void pulse() {
  palette = RainbowColors_p;
  uint8_t _scale = modes[currentMode].Scale;
  const uint8_t limitSteps = 6U;
  static const float fadeRate = 0.8;

  dimAll2(248U); // если эффект устанавливается с другими эффектами от Stefan Petrick, тогда  процедура должна называться dimAll (без двоечки)
  if (step <= currentRadius) {
    for (uint8_t i = 0; i < step; i++ ) {
      uint8_t _dark = qmul8( 2U, cos8 (128U / (step + 1U) * (i + 1U))) ;
      if (_scale == 1) {            // 1 - случайные диски
        _pulse_hue = pulse_hue;
        _pulse_color = CHSV(_pulse_hue, 255U, _dark);
      
      } else if (_scale <= 17) {    // 2...17 - перелив цвета дисков 
        _pulse_delta = (17U - _scale) ;
        _pulse_color = CHSV(_pulse_hueall, 255U, _dark);
     
      } else if (_scale <= 33) {    // 18...33 - выбор цвета дисков 
        _pulse_hue = (_scale - 18U) * 16U ;
        _pulse_color = CHSV(_pulse_hue, 255U, _dark);
      
      } else if (_scale <= 50) {    // 34...50 - дискоцветы
        _pulse_hue += (_scale - 33U) * 5U ;
        _pulse_color = CHSV(_pulse_hue, 255U, _dark);
      
      } else if (_scale <= 67) {    // 51...67 - пузыри цветы
        uint8_t _sat =  qsub8( 255U, cos8 (128U / (step + 1U) * (i + 1U))) ;
         _pulse_hue += (68U - _scale) * 7U ;
        _pulse_color = CHSV(_pulse_hue, _sat, _dark);
      
      } else if (_scale < 83) {     // 68...83 - выбор цвета пузырей
        uint8_t _sat =  qsub8( 255U, cos8 (128U / (step + 1U) * (i + 1U))) ;
        _pulse_hue = (_scale - 68U) * 16U ;
        _pulse_color = CHSV(_pulse_hue, _sat, _dark);
      
      } else if (_scale < 100) {    // 84...99 - перелив цвета пузырей
        uint8_t _sat =  qsub8( 255U, cos8 (128U / (step + 1U) * (i + 1U))) ;
        _pulse_delta = (_scale - 85U)  ;
        _pulse_color = CHSV(_pulse_hueall, _sat, _dark);
      
      } else { // 100 - случайные пузыри
        uint8_t _sat =  qsub8( 255U, cos8 (128U / (step + 1U) * (i + 1U))) ;
        _pulse_hue = pulse_hue;
        _pulse_color = CHSV(_pulse_hue, _sat, _dark);
      }
      drawCircle(centerX, centerY, i, _pulse_color  );
    }
  } else {
    centerX = random8(WIDTH - 5U) + 3U;
    centerY = random8(HEIGHT - 5U) + 3U;
    _pulse_hueall += _pulse_delta;
    pulse_hue = random8(0U, 255U);
    currentRadius = random8(3U, 9U);
    step = 0;
  }
  step++;
}

// ------------- матрица 2 ---------------
void matrix2Routine()
{
  for (uint8_t x = 0U; x < WIDTH; x++)
  {
    // обрабатываем нашу матрицу снизу вверх до второй сверху строчки
    for (uint8_t y = 0U; y < HEIGHT - 1U; y++)
    {
      uint32_t thisColor = getPixColorXY(x, y);                                              // берём цвет нашего пикселя
      uint32_t upperColor = getPixColorXY(x, y + 1U);                                        // берём цвет пикселя над нашим
      if (upperColor >= 0x900000 && random(7 * HEIGHT) != 0U)                  // если выше нас максимальная яркость, игнорим этот факт с некой вероятностью или опускаем цепочку ниже
        drawPixelXY(x, y, upperColor);
      else if (thisColor == 0U && random((100 - modes[currentMode].Scale) * HEIGHT) == 0U)  // если наш пиксель ещё не горит, иногда зажигаем новые цепочки
      //else if (thisColor == 0U && random((100 - modes[currentMode].Scale) * HEIGHT*3) == 0U)  // для длинных хвостов
        drawPixelXY(x, y, 0x9bf800);
      else if (thisColor <= 0x050800)                                                        // если наш пиксель почти погас, стараемся сделать затухание медленней
      {
        if (thisColor >= 0x030000)
          drawPixelXY(x, y, 0x020300);
        else if (thisColor != 0U)
          drawPixelXY(x, y, 0U);
      }
      else if (thisColor >= 0x900000)                                                        // если наш пиксель максимальной яркости, резко снижаем яркость
        drawPixelXY(x, y, 0x558800);
      else 
        drawPixelXY(x, y, thisColor - 0x0a1000);                                             // в остальных случаях снижаем яркость на 1 уровень
        //drawPixelXY(x, y, thisColor - 0x050800);                                             // для длинных хвостов
    }
    // аналогично обрабатываем верхний ряд пикселей матрицы
    uint32_t thisColor = getPixColorXY(x, HEIGHT - 1U);
    if (thisColor == 0U)                                                                     // если наш верхний пиксель не горит, заполняем его с вероятностью .Scale
    {
      if (random(100 - modes[currentMode].Scale) == 0U)
        drawPixelXY(x, HEIGHT - 1U, 0x9bf800);
    }  
    else if (thisColor <= 0x050800)                                                          // если наш верхний пиксель почти погас, стараемся сделать затухание медленней
    {
      if (thisColor >= 0x030000)
        drawPixelXY(x, HEIGHT - 1U, 0x020300);
      else
        drawPixelXY(x, HEIGHT - 1U, 0U);
    }
    else if (thisColor >= 0x900000)                                                          // если наш верхний пиксель максимальной яркости, резко снижаем яркость
      drawPixelXY(x, HEIGHT - 1U, 0x558800);
    else 
      drawPixelXY(x, HEIGHT - 1U, thisColor - 0x0a1000);                                     // в остальных случаях снижаем яркость на 1 уровень
      //drawPixelXY(x, HEIGHT - 1U, thisColor - 0x050800);                                     // для длинных хвостов
  }
}



/*
  Metaballs proof of concept by Stefan Petrick (mod by Palpalych for GyverLamp 27/02/2020)
  ...very rough 8bit math here...
  read more about the concept of isosurfaces and metaballs:
  https://www.gamedev.net/articles/programming/graphics/exploring-metaballs-and-isosurfaces-in-2d-r2556
*/

// ***** METABALLS / МЕТАШАРИКИ *****
// v1.7.0 - Updating for GuverLamp v1.7 by PalPalych 12.03.2020
bool metaBallsRoutine() {
  float speed = 1;

  // get some 2 random moving points
  uint8_t x2 = inoise8(millis() * speed, 25355, 685 ) / WIDTH;
  uint8_t y2 = inoise8(millis() * speed, 355, 11685 ) / HEIGHT;

  uint8_t x3 = inoise8(millis() * speed, 55355, 6685 ) / WIDTH;
  uint8_t y3 = inoise8(millis() * speed, 25355, 22685 ) / HEIGHT;

  // and one Lissajou function
  uint8_t x1 = beatsin8(23 * speed, 0, 15);
  uint8_t y1 = beatsin8(28 * speed, 0, 15);

  for (uint8_t y = 0; y < HEIGHT; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {

      // calculate distances of the 3 points from actual pixel
      // and add them together with weightening
      uint8_t  dx =  abs(x - x1);
      uint8_t  dy =  abs(y - y1);
      uint8_t dist = 2 * sqrt((dx * dx) + (dy * dy));

      dx =  abs(x - x2);
      dy =  abs(y - y2);
      dist += sqrt((dx * dx) + (dy * dy));

      dx =  abs(x - x3);
      dy =  abs(y - y3);
      dist += sqrt((dx * dx) + (dy * dy));

      // inverse result
      byte color = 1000 / dist;

      // map color between thresholds
      if (color > 0 and color < 60) {
        drawPixelXY(x, y, CHSV(color * 9, 255, 255));
      } else {
        drawPixelXY(x, y, CHSV(0, 255, 255));
      }
      // show the 3 points, too
      drawPixelXY(x1, y1, CRGB(255, 255, 255));
      drawPixelXY(x2, y2, CRGB(255, 255, 255));
      drawPixelXY(x3, y3, CRGB(255, 255, 255));
    }
  }
  return true;
}

// ***** SINUSOID3 / СИНУСОИД3 *****
// v1.7.0 - Updating for GuverLamp v1.7 by PalPalych 12.03.2020
/*
  Sinusoid3 by Stefan Petrick (mod by Palpalych for GyverLamp 27/02/2020)
  read more about the concept: https://www.youtube.com/watch?v=mubH-w_gwdA
*/
void Sinusoid3Routine ()
{
  const uint8_t semiHeightMajor =  HEIGHT / 2 + (HEIGHT % 2);
  const uint8_t semiWidthMajor =  WIDTH / 2  + (WIDTH % 2) ;
//  float e_s3_speed = 0.004 * modes[currentMode].Speed + 0.015; // speed of the movement along the Lissajous curves
  float e_s3_speed=0.1;
  float e_s3_size = 3 * (float)modes[currentMode].Scale/255.0 + 2;    // amplitude of the curves

//  float time_shift = float(millis()%(uint32_t)(30000*(1.0/((float)modes[currentMode].Speed/255))));
  float time_shift = float(millis()%(uint32_t)(30000*(1.0/((float)5/255))));
  for (uint8_t y = 0; y < HEIGHT; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      CRGB color;

      float cx = y + float(e_s3_size * (sinf (float(e_s3_speed * 0.003 * time_shift)))) - semiHeightMajor;  // the 8 centers the middle on a 16x16
      float cy = x + float(e_s3_size * (cosf (float(e_s3_speed * 0.0022 * time_shift)))) - semiWidthMajor;
      float v = 127 * (1 + sinf ( sqrtf ( ((cx * cx) + (cy * cy)) ) ));
      color.r = v;

      cx = x + float(e_s3_size * (sinf (e_s3_speed * float(0.0021 * time_shift)))) - semiWidthMajor;
      cy = y + float(e_s3_size * (cosf (e_s3_speed * float(0.002 * time_shift)))) - semiHeightMajor;
      v = 127 * (1 + sinf ( sqrtf ( ((cx * cx) + (cy * cy)) ) ));
      color.b = v;

      cx = x + float(e_s3_size * (sinf (e_s3_speed * float(0.0041 * time_shift)))) - semiWidthMajor;
      cy = y + float(e_s3_size * (cosf (e_s3_speed * float(0.0052 * time_shift)))) - semiHeightMajor;
      v = 127 * (1 + sinf ( sqrtf ( ((cx * cx) + (cy * cy)) ) ));
      color.g = v;
      drawPixelXY(x, y, color);
    }
  }
}

// --------------------------- эффект спирали ----------------------
/*
 * Aurora: https://github.com/pixelmatix/aurora
 * https://github.com/pixelmatix/aurora/blob/sm3.0-64x64/PatternSpiro.h
 * Copyright (c) 2014 Jason Coon
 * Неполная адаптация SottNick
 */
    byte spirotheta1 = 0;
    byte spirotheta2 = 0;
    byte spirohueoffset = 0;

    const uint8_t spiroradiusx = WIDTH / 4;
    const uint8_t spiroradiusy = HEIGHT / 4;
    
    const uint8_t spirocenterX = WIDTH / 2;
    const uint8_t spirocenterY = HEIGHT / 2;
    
    const uint8_t spirominx = spirocenterX - spiroradiusx;
    const uint8_t spiromaxx = spirocenterX + spiroradiusx + 1;
    const uint8_t spirominy = spirocenterY - spiroradiusy;
    const uint8_t spiromaxy = spirocenterY + spiroradiusy + 1;

    uint8_t spirocount = 1;
    uint8_t spirooffset = 256 / spirocount;
    boolean spiroincrement = false;

    boolean spirohandledChange = false;

uint8_t mapsin8(uint8_t theta, uint8_t lowest = 0, uint8_t highest = 255) {
  uint8_t beatsin = sin8(theta);
  uint8_t rangewidth = highest - lowest;
  uint8_t scaledbeat = scale8(beatsin, rangewidth);
  uint8_t result = lowest + scaledbeat;
  return result;
}

uint8_t mapcos8(uint8_t theta, uint8_t lowest = 0, uint8_t highest = 255) {
  uint8_t beatcos = cos8(theta);
  uint8_t rangewidth = highest - lowest;
  uint8_t scaledbeat = scale8(beatcos, rangewidth);
  uint8_t result = lowest + scaledbeat;
  return result;
}
  
void spiroRoutine() {
      dimAll(250);

      boolean change = false;
      
      for (int i = 0; i < spirocount; i++) {
        uint8_t x = mapsin8(spirotheta1 + i * spirooffset, spirominx, spiromaxx);
        uint8_t y = mapcos8(spirotheta1 + i * spirooffset, spirominy, spiromaxy);

        uint8_t x2 = mapsin8(spirotheta2 + i * spirooffset, x - spiroradiusx, x + spiroradiusx);
        uint8_t y2 = mapcos8(spirotheta2 + i * spirooffset, y - spiroradiusy, y + spiroradiusy);

        CRGB color = ColorFromPalette( PartyColors_p, (spirohueoffset + i * spirooffset)     , 128U); // вообще-то палитра должна постоянно меняться, но до адаптации этого руки уже не дошли

if (x2<WIDTH && y2<HEIGHT) // добавил проверки. не знаю, почему эффект подвисает без них
        leds[getPixelNumber(x2, y2)] += color;
        
        if((x2 == spirocenterX && y2 == spirocenterY) ||
           (x2 == spirocenterX && y2 == spirocenterY)) change = true;
      }

      spirotheta2 += 2;

      EVERY_N_MILLIS(12) {
        spirotheta1 += 1;
      }

      EVERY_N_MILLIS(75) {
        if (change && !spirohandledChange) {
          spirohandledChange = true;
          
          if (spirocount >= WIDTH || spirocount == 1) spiroincrement = !spiroincrement;

          if (spiroincrement) {
            if(spirocount >= 4)
              spirocount *= 2;
            else
              spirocount += 1;
          }
          else {
            if(spirocount > 4)
              spirocount /= 2;
            else
              spirocount -= 1;
          }

          spirooffset = 256 / spirocount;
        }
        
        if(!change) spirohandledChange = false;
      }

      EVERY_N_MILLIS(33) {
        spirohueoffset += 1;
      }
}

// --------------------------- эффект мячики ----------------------
//  BouncingBalls2014 is a program that lets you animate an LED strip
//  to look like a group of bouncing balls
//  Daniel Wilson, 2014
//  https://github.com/githubcdr/Arduino/blob/master/bouncingballs/bouncingballs.ino
//  With BIG thanks to the FastLED community!
//  адаптация от SottNick
#define bballsGRAVITY           (-9.81)              // Downward (negative) acceleration of gravity in m/s^2
#define bballsH0                (1)                  // Starting height, in meters, of the ball (strip length)
//#define enlargedOBJECT_MAX_COUNT            (WIDTH * 2)          // максимальное количество мячиков прикручено при адаптации для бегунка Масштаб
//uint8_t enlargedObjectNUM;                                   // Number of bouncing balls you want (recommend < 7, but 20 is fun in its own way) ... количество мячиков теперь задаётся бегунком, а не константой
//uint8_t bballsCOLOR[enlargedOBJECT_MAX_COUNT] ;                   // прикручено при адаптации для разноцветных мячиков
//будем использовать uint8_t trackingObjectHue[trackingOBJECT_MAX_COUNT];
//uint8_t bballsX[enlargedOBJECT_MAX_COUNT] ;                       // прикручено при адаптации для распределения мячиков по радиусу лампы
//будем использовать uint8_t trackingObjectState[trackingOBJECT_MAX_COUNT];
//bool enlargedObjectIsShift[enlargedOBJECT_MAX_COUNT] ;                      // прикручено при адаптации для того, чтобы мячики не стояли на месте
float bballsVImpact0 = sqrt3( -2 * bballsGRAVITY * bballsH0 );  // Impact velocity of the ball when it hits the ground if "dropped" from the top of the strip
//float bballsVImpact[enlargedOBJECT_MAX_COUNT] ;                   // As time goes on the impact velocity will change, so make an array to store those values
//будем использовать float trackingObjectSpeedY[trackingOBJECT_MAX_COUNT];
//uint16_t   bballsPos[enlargedOBJECT_MAX_COUNT] ;                       // The integer position of the dot on the strip (LED index)
//будем использовать float trackingObjectPosY[trackingOBJECT_MAX_COUNT];
//long  enlargedObjectTime[enlargedOBJECT_MAX_COUNT] ;                     // The clock time of the last ground strike
//float bballsCOR[enlargedOBJECT_MAX_COUNT] ;                       // Coefficient of Restitution (bounce damping)
//будем использовать float trackingObjectShift[trackingOBJECT_MAX_COUNT];

void BBallsRoutine() {
  if (loadingFlag)
  {
    loadingFlag = false;
    //FastLED.clear();
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) / 99.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
    for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) {             // Initialize variables
      trackingObjectHue[i] = random8();
      trackingObjectState[i] = random8(0U, WIDTH);
      enlargedObjectTime[i] = millis();
      trackingObjectPosY[i] = 0U;                                // Balls start on the ground
      trackingObjectSpeedY[i] = bballsVImpact0;                // And "pop" up at vImpact0
      trackingObjectShift[i] = 0.90 - float(i) / pow(enlargedObjectNUM, 2); // это, видимо, прыгучесть. для каждого мячика уникальная изначально
      enlargedObjectIsShift[i] = false;
      hue2 = (modes[currentMode].Speed > 127U) ? 255U : 0U;                                           // цветные или белые мячики
//      hue = (modes[currentMode].Speed == 128U) ? 255U : 254U - modes[currentMode].Speed % 128U * 2U;  // скорость угасания хвостов 0 = моментально
      hue = (currentMode == EFF_BBALS) ? 0 : map(modes[currentMode].Speed % 128U,1,127,32,255);  // скорость угасания хвостов 0 = моментально
    }
  }
  
  float bballsHi;
  float bballsTCycle;
  deltaHue++; // постепенное изменение оттенка мячиков (закомментировать строчку, если не нужно)
  dimAll(hue);
  for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) {
    //leds[XY(trackingObjectState[i], trackingObjectPosY[i])] = CRGB::Black; // off for the next loop around  // теперь пиксели гасятся в dimAll()

    bballsTCycle =  millis() - enlargedObjectTime[i] ; // Calculate the time since the last time the ball was on the ground

    // A little kinematics equation calculates positon as a function of time, acceleration (gravity) and intial velocity
    bballsHi = 0.5 * bballsGRAVITY * pow( bballsTCycle / 1000.0 , 2.0 ) + trackingObjectSpeedY[i] * bballsTCycle / 1000.0;

    if ( bballsHi < 0 ) {
      enlargedObjectTime[i] = millis();
      bballsHi = 0; // If the ball crossed the threshold of the "ground," put it back on the ground
      trackingObjectSpeedY[i] = trackingObjectShift[i] * trackingObjectSpeedY[i] ; // and recalculate its new upward velocity as it's old velocity * COR

      if ( trackingObjectSpeedY[i] < 0.01 ) // If the ball is barely moving, "pop" it back up at vImpact0
      {
        trackingObjectShift[i] = 0.90 - float(random(0U, 9U)) / pow(random(4U, 9U), 2); // сделал, чтобы мячики меняли свою прыгучесть каждый цикл
        enlargedObjectIsShift[i] = trackingObjectShift[i] >= 0.89;                             // если мячик максимальной прыгучести, то разрешаем ему сдвинуться
        trackingObjectSpeedY[i] = bballsVImpact0;
      }
    }
    trackingObjectPosY[i] = round( bballsHi * (HEIGHT - 1) / bballsH0);             // Map "h" to a "pos" integer index position on the LED strip
    if (enlargedObjectIsShift[i] && (trackingObjectPosY[i] == HEIGHT - 1)) {                  // если мячик получил право, то пускай сдвинется на максимальной высоте 1 раз
      enlargedObjectIsShift[i] = false;
      if (trackingObjectHue[i] % 2 == 0) {                                       // чётные налево, нечётные направо
        if (trackingObjectState[i] == 0U) trackingObjectState[i] = WIDTH - 1U;
        else --trackingObjectState[i];
      } else {
        if (trackingObjectState[i] == WIDTH - 1U) trackingObjectState[i] = 0U;
        else ++trackingObjectState[i];
      }
    }
    leds[getPixelNumber(trackingObjectState[i], trackingObjectPosY[i])] = CHSV(trackingObjectHue[i] + deltaHue, hue2, 255U);
  }
}


// стандартные функции библиотеки LEDraw от @Palpalych (для адаптаций его эффектов)
void blurScreen(fract8 blur_amount, CRGB *LEDarray = leds)
{
  blur2d(LEDarray, WIDTH, HEIGHT, blur_amount);
}

// добавлено изменение текущей палитры (используется во многих эффектах ниже для бегунка Масштаб)
const TProgmemRGBPalette16 *palette_arr[] = {&PartyColors_p, &OceanColors_p, &LavaColors_p, &HeatColors_p, &WaterfallColors_p, &CloudColors_p, &ForestColors_p, &RainbowColors_p, &RainbowStripeColors_p};
const TProgmemRGBPalette16 *curPalette = palette_arr[0];

// ============= ЭФФЕКТ СТАЯ ===============
// https://github.com/pixelmatix/aurora/blob/master/PatternFlock.h
// Адаптация от (c) SottNick и @kDn

template <class T>
class Vector2 {
public:
    T x, y;

    Vector2() :x(0), y(0) {}
    Vector2(T x, T y) : x(x), y(y) {}
    Vector2(const Vector2& v) : x(v.x), y(v.y) {}

    Vector2& operator=(const Vector2& v) {
        x = v.x;
        y = v.y;
        return *this;
    }
    
    bool isEmpty() {
        return x == 0 && y == 0;
    }

    bool operator==(Vector2& v) {
        return x == v.x && y == v.y;
    }

    bool operator!=(Vector2& v) {
        return !(x == y);
    }

    Vector2 operator+(Vector2& v) {
        return Vector2(x + v.x, y + v.y);
    }
    Vector2 operator-(Vector2& v) {
        return Vector2(x - v.x, y - v.y);
    }

    Vector2& operator+=(Vector2& v) {
        x += v.x;
        y += v.y;
        return *this;
    }
    Vector2& operator-=(Vector2& v) {
        x -= v.x;
        y -= v.y;
        return *this;
    }

    Vector2 operator+(double s) {
        return Vector2(x + s, y + s);
    }
    Vector2 operator-(double s) {
        return Vector2(x - s, y - s);
    }
    Vector2 operator*(double s) {
        return Vector2(x * s, y * s);
    }
    Vector2 operator/(double s) {
        return Vector2(x / s, y / s);
    }
    
    Vector2& operator+=(double s) {
        x += s;
        y += s;
        return *this;
    }
    Vector2& operator-=(double s) {
        x -= s;
        y -= s;
        return *this;
    }
    Vector2& operator*=(double s) {
        x *= s;
        y *= s;
        return *this;
    }
    Vector2& operator/=(double s) {
        x /= s;
        y /= s;
        return *this;
    }

    void set(T x, T y) {
        this->x = x;
        this->y = y;
    }

    void rotate(double deg) {
        double theta = deg / 180.0 * M_PI;
        double c = cos(theta);
        double s = sin(theta);
        double tx = x * c - y * s;
        double ty = x * s + y * c;
        x = tx;
        y = ty;
    }

    Vector2& normalize() {
        if (length() == 0) return *this;
        *this *= (1.0 / length());
        return *this;
    }

    float dist(Vector2 v) const {
        Vector2 d(v.x - x, v.y - y);
        return d.length();
    }
    float length() const {
        return sqrt(x * x + y * y);
    }

    float mag() const {
        return length();
    }

    float magSq() {
        return (x * x + y * y);
    }

    void truncate(double length) {
        double angle = atan2f(y, x);
        x = length * cos(angle);
        y = length * sin(angle);
    }

    Vector2 ortho() const {
        return Vector2(y, -x);
    }

    static float dot(Vector2 v1, Vector2 v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }
    static float cross(Vector2 v1, Vector2 v2) {
        return (v1.x * v2.y) - (v1.y * v2.x);
    }

    void limit(float max) {
        if (magSq() > max*max) {
            normalize();
            *this *= max;
        }
    }
};

typedef Vector2<float> PVector;

// Flocking
// Daniel Shiffman <http://www.shiffman.net>
// The Nature of Code, Spring 2009

// Boid class
// Methods for Separation, Cohesion, Alignment added

class Boid {
  public:

    PVector location;
    PVector velocity;
    PVector acceleration;
    float maxforce;    // Maximum steering force
    float maxspeed;    // Maximum speed

    float desiredseparation = 4;
    float neighbordist = 8;
    byte colorIndex = 0;
    float mass;

    boolean enabled = true;

    Boid() {}

    Boid(float x, float y) {
      acceleration = PVector(0, 0);
      velocity = PVector(randomf(), randomf());
      location = PVector(x, y);
      maxspeed = 1.5;
      maxforce = 0.05;
    }

    static float randomf() {
      return mapfloat(random(0, 255), 0, 255, -.5, .5);
    }

    static float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) {
      return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    void run(Boid boids [], uint8_t boidCount) {
      flock(boids, boidCount);
      update();
      // wrapAroundBorders();
      // render();
    }

    // Method to update location
    void update() {
      // Update velocity
      velocity += acceleration;
      // Limit speed
      velocity.limit(maxspeed);
      location += velocity;
      // Reset acceleration to 0 each cycle
      acceleration *= 0;
    }

    void applyForce(PVector force) {
      // We could add mass here if we want A = F / M
      acceleration += force;
    }

    void repelForce(PVector obstacle, float radius) {
      //Force that drives boid away from obstacle.

      PVector futPos = location + velocity; //Calculate future position for more effective behavior.
      PVector dist = obstacle - futPos;
      float d = dist.mag();

      if (d <= radius) {
        PVector repelVec = location - obstacle;
        repelVec.normalize();
        if (d != 0) { //Don't divide by zero.
          // float scale = 1.0 / d; //The closer to the obstacle, the stronger the force.
          repelVec.normalize();
          repelVec *= (maxforce * 7);
          if (repelVec.mag() < 0) { //Don't let the boids turn around to avoid the obstacle.
            repelVec.y = 0;
          }
        }
        applyForce(repelVec);
      }
    }

    // We accumulate a new acceleration each time based on three rules
    void flock(Boid boids [], uint8_t boidCount) {
      PVector sep = separate(boids, boidCount);   // Separation
      PVector ali = align(boids, boidCount);      // Alignment
      PVector coh = cohesion(boids, boidCount);   // Cohesion
      // Arbitrarily weight these forces
      sep *= 1.5;
      ali *= 1.0;
      coh *= 1.0;
      // Add the force vectors to acceleration
      applyForce(sep);
      applyForce(ali);
      applyForce(coh);
    }

    // Separation
    // Method checks for nearby boids and steers away
    PVector separate(Boid boids [], uint8_t boidCount) {
      PVector steer = PVector(0, 0);
      int count = 0;
      // For every boid in the system, check if it's too close
      for (int i = 0; i < boidCount; i++) {
        Boid other = boids[i];
        if (!other.enabled)
          continue;
        float d = location.dist(other.location);
        // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)
        if ((d > 0) && (d < desiredseparation)) {
          // Calculate vector pointing away from neighbor
          PVector diff = location - other.location;
          diff.normalize();
          diff /= d;        // Weight by distance
          steer += diff;
          count++;            // Keep track of how many
        }
      }
      // Average -- divide by how many
      if (count > 0) {
        steer /= (float) count;
      }

      // As long as the vector is greater than 0
      if (steer.mag() > 0) {
        // Implement Reynolds: Steering = Desired - Velocity
        steer.normalize();
        steer *= maxspeed;
        steer -= velocity;
        steer.limit(maxforce);
      }
      return steer;
    }

    // Alignment
    // For every nearby boid in the system, calculate the average velocity
    PVector align(Boid boids [], uint8_t boidCount) {
      PVector sum = PVector(0, 0);
      int count = 0;
      for (int i = 0; i < boidCount; i++) {
        Boid other = boids[i];
        if (!other.enabled)
          continue;
        float d = location.dist(other.location);
        if ((d > 0) && (d < neighbordist)) {
          sum += other.velocity;
          count++;
        }
      }
      if (count > 0) {
        sum /= (float) count;
        sum.normalize();
        sum *= maxspeed;
        PVector steer = sum - velocity;
        steer.limit(maxforce);
        return steer;
      }
      else {
        return PVector(0, 0);
      }
    }

    // Cohesion
    // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location
    PVector cohesion(Boid boids [], uint8_t boidCount) {
      PVector sum = PVector(0, 0);   // Start with empty vector to accumulate all locations
      int count = 0;
      for (int i = 0; i < boidCount; i++) {
        Boid other = boids[i];
        if (!other.enabled)
          continue;
        float d = location.dist(other.location);
        if ((d > 0) && (d < neighbordist)) {
          sum += other.location; // Add location
          count++;
        }
      }
      if (count > 0) {
        sum /= count;
        return seek(sum);  // Steer towards the location
      }
      else {
        return PVector(0, 0);
      }
    }

    // A method that calculates and applies a steering force towards a target
    // STEER = DESIRED MINUS VELOCITY
    PVector seek(PVector target) {
      PVector desired = target - location;  // A vector pointing from the location to the target
      // Normalize desired and scale to maximum speed
      desired.normalize();
      desired *= maxspeed;
      // Steering = Desired minus Velocity
      PVector steer = desired - velocity;
      steer.limit(maxforce);  // Limit to maximum steering force
      return steer;
    }

    // A method that calculates a steering force towards a target
    // STEER = DESIRED MINUS VELOCITY
    void arrive(PVector target) {
      PVector desired = target - location;  // A vector pointing from the location to the target
      float d = desired.mag();
      // Normalize desired and scale with arbitrary damping within 100 pixels
      desired.normalize();
      if (d < 4) {
        float m = map(d, 0, 100, 0, maxspeed);
        desired *= m;
      }
      else {
        desired *= maxspeed;
      }

      // Steering = Desired minus Velocity
      PVector steer = desired - velocity;
      steer.limit(maxforce);  // Limit to maximum steering force
      applyForce(steer);
      //Serial.println(d);
    }

    void wrapAroundBorders() {
      if (location.x < 0) location.x = WIDTH - 1;
      if (location.y < 0) location.y = HEIGHT - 1;
      if (location.x >= WIDTH) location.x = 0;
      if (location.y >= HEIGHT) location.y = 0;
    }

    void avoidBorders() {
      PVector desired = velocity;

      if (location.x < 8) desired = PVector(maxspeed, velocity.y);
      if (location.x >= WIDTH - 8) desired = PVector(-maxspeed, velocity.y);
      if (location.y < 8) desired = PVector(velocity.x, maxspeed);
      if (location.y >= HEIGHT - 8) desired = PVector(velocity.x, -maxspeed);

      if (desired != velocity) {
        PVector steer = desired - velocity;
        steer.limit(maxforce);
        applyForce(steer);
      }

      if (location.x < 0) location.x = 0;
      if (location.y < 0) location.y = 0;
      if (location.x >= WIDTH) location.x = WIDTH - 1;
      if (location.y >= HEIGHT) location.y = HEIGHT - 1;
    }

    bool bounceOffBorders(float bounce) {
      bool bounced = false;

      if (location.x >= WIDTH) {
        location.x = WIDTH - 1;
        velocity.x *= -bounce;
        bounced = true;
      }
      else if (location.x < 0) {
        location.x = 0;
        velocity.x *= -bounce;
        bounced = true;
      }

      if (location.y >= HEIGHT) {
        location.y = HEIGHT - 1;
        velocity.y *= -bounce;
        bounced = true;
      }
      else if (location.y < 0) {
        location.y = 0;
        velocity.y *= -bounce;
        bounced = true;
      }

      return bounced;
    }

    void render() {
      // // Draw a triangle rotated in the direction of velocity
      // float theta = velocity.heading2D() + radians(90);
      // fill(175);
      // stroke(0);
      // pushMatrix();
      // translate(location.x,location.y);
      // rotate(theta);
      // beginShape(TRIANGLES);
      // vertex(0, -r*2);
      // vertex(-r, r*2);
      // vertex(r, r*2);
      // endShape();
      // popMatrix();
      // backgroundLayer.drawPixel(location.x, location.y, CRGB::Blue);
    }
};

static const uint8_t AVAILABLE_BOID_COUNT = 20;
Boid boids[AVAILABLE_BOID_COUNT]; 

    static const int boidCount = 10;
    Boid predator;

    PVector wind;
//    byte hue = 0; будем использовать сдвиг от эффектов Радуга
    bool predatorPresent = true;

void flockRoutine(bool predatorIs) {
    if (loadingFlag)
    {
      loadingFlag = false;
//      Serial.println("Запуск стаи"); 
      if (modes[currentMode].Scale > 100) modes[currentMode].Scale = 100; // чтобы не было проблем при прошивке без очистки памяти
      curPalette = palette_arr[(int)((float)modes[currentMode].Scale/100 * ((sizeof(palette_arr)/sizeof(TProgmemRGBPalette16 *))-1U))];

      for (int i = 0; i < boidCount; i++) {
        boids[i] = Boid(15, 15);
//        boids[i].maxspeed = 0.380 * modes[currentMode].Speed /127.0+0.380/2;
        boids[i].maxspeed = 0.5;    
        boids[i].maxforce = 0.015 * modes[currentMode].Speed /127.0+0.015/2;
      }
      predatorPresent = predatorIs && random(0, 2) >= 1;
      if (predatorPresent) {
        predator = Boid(31, 31);
        predator.maxspeed = 0.385 * modes[currentMode].Speed /127.0+0.385/2;
        predator.maxforce = 0.020 * modes[currentMode].Speed /127.0+0.020/2;
        predator.neighbordist = 8.0; // было 16.0 и хищник гонял по одной линии всегда
        predator.desiredseparation = 0.0;
      }
    }
    
      blurScreen(15); // @Palpalych советует делать размытие
      //myLamp.dimAll(254U - (31-(myLamp.effects.getScale()%32))*8);
      dimAll(255U - (modes[currentMode].Scale % 11U) * 3);

      bool applyWind = random(0, 255) > 240;
      if (applyWind) {
        wind.x = Boid::randomf() * .015 * modes[currentMode].Speed /127.0 + .015/2;
        wind.y = Boid::randomf() * .015 * modes[currentMode].Speed /127.0 + .015/2;
      }

      if ((modes[currentMode].Scale>1) && (modes[currentMode].Scale<100)) hue=modes[currentMode].Scale*2.55;
      CRGB color = ColorFromPalette(*curPalette, hue);
      

      for (int i = 0; i < boidCount; i++) {
        Boid * boid = &boids[i];

        if (predatorPresent) {
          // flee from predator
          boid->repelForce(predator.location, 10);
        }

        boid->run(boids, boidCount);
        boid->wrapAroundBorders();
        PVector location = boid->location;
        // PVector velocity = boid->velocity;
        // backgroundLayer.drawLine(location.x, location.y, location.x - velocity.x, location.y - velocity.y, color);
        // effects.leds[getPixelNumber(location.x, location.y)] += color;
        drawPixelXY(location.x, location.y, color);

        if (applyWind) {
          boid->applyForce(wind);
          applyWind = false;
        }
      }

      if (predatorPresent) {
        predator.run(boids, boidCount);
        predator.wrapAroundBorders();
        color = ColorFromPalette(*curPalette, hue + 128);
        PVector location = predator.location;
        // PVector velocity = predator.velocity;
        // backgroundLayer.drawLine(location.x, location.y, location.x - velocity.x, location.y - velocity.y, color);
        // effects.leds[getPixelNumber(location.x, location.y)] += color;        
        drawPixelXY(location.x, location.y, color);
      }

      EVERY_N_MILLIS(333) {
        if (modes[currentMode].Scale==1 || modes[currentMode].Scale==100) hue++;
      }
      
      EVERY_N_SECONDS(30) {
        predatorPresent = predatorIs && !predatorPresent;
      }
}

// ============= ЭФФЕКТ ОГОНЬ 2018 ===============
// https://gist.github.com/StefanPetrick/819e873492f344ebebac5bcd2fdd8aa8
// https://gist.github.com/StefanPetrick/1ba4584e534ba99ca259c1103754e4c5
// Адаптация от (c) SottNick

// parameters and buffer for the noise array
// (вместо закомментированных ситрок используются массивы и переменные от эффекта Кометы для экономии памяти)
//define NUM_LAYERS 2 // менять бесполезно, так как в коде чётко использовано 2 слоя
//uint32_t e_x[NUM_LAYERSMAX];
//uint32_t e_y[NUM_LAYERSMAX];
//uint32_t e_z[NUM_LAYERSMAX];
//uint32_t e_scaleX[NUM_LAYERSMAX];
//uint32_t e_scaleY[NUM_LAYERSMAX];
//uint8_t noise3d[NUM_LAYERSMAX][WIDTH][HEIGHT];

uint8_t fire18heat[NUM_LEDS];
// this finds the right index within a serpentine matrix

void Fire2018_2() {
  const uint8_t CentreY =  HEIGHT / 2 + (HEIGHT % 2);
  const uint8_t CentreX =  WIDTH / 2  + (WIDTH % 2) ;

  // some changing values
  uint16_t ctrl1 = inoise16(11 * millis(), 0, 0);
  uint16_t ctrl2 = inoise16(13 * millis(), 100000, 100000);
  uint16_t  ctrl = ((ctrl1 + ctrl2) / 2);

  // parameters for the heatmap
  uint16_t speed = 25;
  e_x[0] = 3 * ctrl * speed;
  e_y[0] = 20 * millis() * speed;
  e_z[0] = 5 * millis() * speed ;
  e_scaleX[0] = ctrl1 / 2;
  e_scaleY[0] = ctrl2 / 2;

  //calculate the noise data
  uint8_t layer = 0;

  for (uint8_t i = 0; i < WIDTH; i++) {
    uint32_t ioffset = e_scaleX[layer] * (i - CentreX);
    for (uint8_t j = 0; j < HEIGHT; j++) {
      uint32_t joffset = e_scaleY[layer] * (j - CentreY);
      uint16_t data = ((inoise16(e_x[layer] + ioffset, e_y[layer] + joffset, e_z[layer])) + 1);
//      noise3d[layer][i][j] = data >> 8;
      noise3d[layer][i][j] = (data >> 8)+modes[currentMode].Scale*2.55;
    }
  }

  // parameters for te brightness mask
  speed = 20;
  e_x[1] = 3 * ctrl * speed;
  e_y[1] = 20 * millis() * speed;
  e_z[1] = 5 * millis() * speed ;
  e_scaleX[1] = ctrl1 / 2;
  e_scaleY[1] = ctrl2 / 2;

  //calculate the noise data
  layer = 1;
  for (uint8_t i = 0; i < WIDTH; i++) {
    uint32_t ioffset = e_scaleX[layer] * (i - CentreX);
    for (uint8_t j = 0; j < HEIGHT; j++) {
      uint32_t joffset = e_scaleY[layer] * (j - CentreY);
      uint16_t data = ((inoise16(e_x[layer] + ioffset, e_y[layer] + joffset, e_z[layer])) + 1);
//      noise3d[layer][i][j] = data >> 8;
      noise3d[layer][i][j] = (data >> 8)+modes[currentMode].Scale*2.55;
    }
  }

  // draw lowest line - seed the fire
  for (uint8_t x = 0; x < WIDTH; x++) {
//    fire18heat[XY(x, HEIGHT - 1)] =  noise3d[0][WIDTH - 1 - x][CentreY - 1]; // хз, почему взято с середины. вожможно, нужно просто с 7 строки вне зависимости от высоты матрицы
   fire18heat[XY(x, HEIGHT - 1)] =  noise3d[0][WIDTH - 1 - x][CentreY - 1]; // хз, почему взято с середины. вожможно, нужно просто с 7 строки вне зависимости от высоты матрицы
  }


  //copy everything one line up
  for (uint8_t y = 0; y < HEIGHT - 1; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      fire18heat[XY(x, y)] = fire18heat[XY(x, y + 1)];
    }
  }

  //dim
  for (uint8_t y = 0; y < HEIGHT - 1; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      uint8_t dim = noise3d[0][x][y];
      // high value = high flames
      dim = dim / 1.7;
      dim = 255 - dim;
      fire18heat[XY(x, y)] = scale8(fire18heat[XY(x, y)] , dim);
    }
  }

  for (uint8_t y = 0; y < HEIGHT; y++) {
    for (uint8_t x = 0; x < WIDTH; x++) {
      // map the colors based on heatmap
      //leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)], 1 , 0);
      //leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)], fire18heat[XY(x, y)] * 0.153, 0);// * 0.153 - лучший оттенок
      leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)]*2.55, (float)fire18heat[XY(x, y)] * modes[currentMode].Scale * 0.01, 0);
//      leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)], (float)fire18heat[XY(x, y)] * modes[currentMode].Scale * 2.55, 0);
      

      //пытался понять, как регулировать оттенок пламени...
      //  if (modes[currentMode].Scale > 50)
      //    leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)], fire18heat[XY(x, y)] * (modes[currentMode].Scale % 50)  * 0.051, 0);
      //  else
      //    leds[getPixelNumber(x, HEIGHT - 1 - y)] = CRGB( fire18heat[XY(x, y)], 1 , fire18heat[XY(x, y)] * modes[currentMode].Scale * 0.051);
      //примерно понял
   
      // dim the result based on 2nd noise layer
      leds[getPixelNumber(x, HEIGHT - 1 - y)].nscale8(noise3d[1][x][y]);
    }
  }

}

/*
// ============= ЭФФЕКТ ПРИЗМАТА ===============
// Prismata Loading Animation
void prismataRoutine(CRGB *leds, const char *param)
{
  const TProgmemRGBPalette16 *palette_arr[] = {&PartyColors_p, &OceanColors_p, &LavaColors_p, &HeatColors_p, &WaterfallColors_p, &CloudColors_p, &ForestColors_p, &RainbowColors_p, &RainbowStripeColors_p};
  const TProgmemRGBPalette16 *curPalette = palette_arr[(int)((float)myLamp.effects.getScale()/255*((sizeof(palette_arr)/sizeof(TProgmemRGBPalette16 *))-1))];

  EVERY_N_MILLIS(333) {
    GSHMEM.spirohueoffset += 1;
  }

  dimAll(250U - modes[EFF_PRISMATA].Scale;%32*7.5);
  for (uint8_t x = 0; x < WIDTH; x++) {
      uint8_t y = beatsin8(x + 1 * myLamp.effects.getSpeed()/5, 0, HEIGHT);
      drawPixelXY(x, y, ColorFromPalette(*curPalette, (x+GSHMEM.spirohueoffset) * 7));
    }
}
*/
/*
static byte spirotheta1 = 0;
static byte spirotheta2 = 0;
static byte spirohueoffset = 0;

// ============= PRISMATA /  ПРИЗМАТА ===============
// Prismata Loading Animation
// v1.0 - Updating for GuverLamp v1.7 by SottNick 07.04.2020
// v1.1 - +Smoothing, +Pallete Selector 09.04.2020
*/
void PrismataRoutine() {
  if (loadingFlag)
  {
    loadingFlag = false;
    setCurrentPalette();

  } 
  
//  EVERY_N_MILLIS(33) { маловата задержочка
    hue++; // используем переменную сдвига оттенка из функций радуги, чтобы не занимать память
//  }
  blurScreen(20); // @Palpalych посоветовал делать размытие
  dimAll(255U - (modes[currentMode].Scale - 1U) % 11U * 3U);

  for (uint8_t x = 0; x < WIDTH; x++)
  {
    //uint8_t y = beatsin8(x + 1, 0, HEIGHT-1); // это я попытался распотрошить данную функцию до исходного кода и вставить в неё регулятор скорости
    // вместо 28 в оригинале было 280, умножения на .Speed не было, а вместо >>17 было (<<8)>>24. короче, оригинальная скорость достигается при бегунке .Speed=20
    uint8_t beat = (GET_MILLIS() * (accum88(x + 1)) * 28 * modes[currentMode].Speed) >> 17;
    uint8_t y = scale8(sin8(beat), HEIGHT-1);
    //и получилось!!!
    
    drawPixelXY(x, y, ColorFromPalette(*curPalette, x * 7 + hue));
  }
}

// ============= ЭФФЕКТЫ ОСАДКИ / ТУЧКА В БАНКЕ / ГРОЗА В БАНКЕ ===============
// https://github.com/marcmerlin/FastLED_NeoMatrix_SmartMatrix_LEDMatrix_GFX_Demos/blob/master/FastLED/Sublime_Demos/Sublime_Demos.ino
// там по ссылке ещё остались эффекты с 3 по 9 (в SimplePatternList перечислены)

//прикольная процедура добавляет блеск почти к любому эффекту после его отрисовки https://www.youtube.com/watch?v=aobtR1gIyIo
//void addGlitter( uint8_t chanceOfGlitter){
//  if ( random8() < chanceOfGlitter) leds[ random16(NUM_LEDS) ] += CRGB::White;
//}

//static uint8_t intensity = 42;  // будет бегунок масштаба

// Array of temp cells (used by fire, theMatrix, coloredRain, stormyRain)
// uint8_t **tempMatrix; = noise3d[0][WIDTH][HEIGHT]
// uint8_t *splashArray; = line[WIDTH] из эффекта Огонь

CRGB solidRainColor = CRGB(60,80,90);

uint8_t wrapX(int8_t x){
  return (x + WIDTH)%WIDTH;
}
uint8_t wrapY(int8_t y){
  return (y + HEIGHT)%HEIGHT;
}

void rain(byte backgroundDepth, byte maxBrightness, byte spawnFreq, byte tailLength, CRGB rainColor, bool splashes, bool clouds, bool storm)
{
  static uint16_t noiseX = random16();
  static uint16_t noiseY = random16();
  static uint16_t noiseZ = random16();

  CRGB lightningColor = CRGB(72,72,80);
  CRGBPalette16 rain_p( CRGB::Black, rainColor );
#ifdef SMARTMATRIX
  CRGBPalette16 rainClouds_p( CRGB::Black, CRGB(75,84,84), CRGB(49,75,75), CRGB::Black );
#else
  CRGBPalette16 rainClouds_p( CRGB::Black, CRGB(15,24,24), CRGB(9,15,15), CRGB::Black );
#endif

  fadeToBlackBy( leds, NUM_LEDS, 255-tailLength);

  // Loop for each column individually
  for (int x = 0; x < WIDTH; x++) {
    // Step 1.  Move each dot down one cell
    for (int i = 0; i < HEIGHT; i++) {
      if (noise3d[0][x][i] >= backgroundDepth) {  // Don't move empty cells
        if (i > 0) noise3d[0][x][wrapY(i-1)] = noise3d[0][x][i];
        noise3d[0][x][i] = 0;
      }
    }

    // Step 2.  Randomly spawn new dots at top
    if (random(255) < spawnFreq) {
      noise3d[0][x][HEIGHT-1] = random(backgroundDepth, maxBrightness);
    }

    // Step 3. Map from tempMatrix cells to LED colors
    for (int y = 0; y < HEIGHT; y++) {
      if (noise3d[0][x][y] >= backgroundDepth) {  // Don't write out empty cells
        leds[getPixelNumber(x,y)] = ColorFromPalette(rain_p, noise3d[0][x][y]);
      }
    }

    // Step 4. Add splash if called for
    if (splashes) {
      // FIXME, this is broken
      byte j = line[x];
      byte v = noise3d[0][x][0];

      if (j >= backgroundDepth) {
        leds[getPixelNumber(wrapX(x-2),0)] = ColorFromPalette(rain_p, j/3);
        leds[getPixelNumber(wrapX(x+2),0)] = ColorFromPalette(rain_p, j/3);
        line[x] = 0;   // Reset splash
      }

      if (v >= backgroundDepth) {
        leds[getPixelNumber(wrapX(x-1),1)] = ColorFromPalette(rain_p, v/2);
        leds[getPixelNumber(wrapX(x+1),1)] = ColorFromPalette(rain_p, v/2);
        line[x] = v; // Prep splash for next frame
      }
    }

    // Step 5. Add lightning if called for
    if (storm) {
      //uint8_t lightning[WIDTH][HEIGHT];
      // ESP32 does not like static arrays  https://github.com/espressif/arduino-esp32/issues/2567
      uint8_t *lightning = (uint8_t *) malloc(WIDTH * HEIGHT);
//      while (lightning == NULL) { Serial.println("lightning malloc failed"); }

//     read_microphone();

      if ((random16() < 72) /* || storm_light */) {    // Odds of a lightning bolt
/*
    #ifdef GENERAL_DEBUG
    LOG.print(F("Microphone A0 min/max "));
    LOG.print(storm_min);
    LOG.print(F(" / "));
    LOG.println(storm_max);
    #endif
*/        
        lightning[scale8(random8(), WIDTH-1) + (HEIGHT-1) * WIDTH] = 255;  // Random starting location
        for(int ly = HEIGHT-1; ly > 1; ly--) {
          for (int lx = 1; lx < WIDTH-1; lx++) {
            if (lightning[lx + ly * WIDTH] == 255) {
              lightning[lx + ly * WIDTH] = 0;
              uint8_t dir = random8(4);
              switch (dir) {
                case 0:
                  leds[getPixelNumber(lx+1,ly-1)] = lightningColor;
                  lightning[(lx+1) + (ly-1) * WIDTH] = 255; // move down and right
                break;
                case 1:
                  leds[getPixelNumber(lx,ly-1)] = CRGB(128,128,128); // я без понятия, почему у верхней молнии один оттенок, а у остальных - другой
                  lightning[lx + (ly-1) * WIDTH] = 255;    // move down
                break;
                case 2:
                  leds[getPixelNumber(lx-1,ly-1)] = CRGB(128,128,128);
                  lightning[(lx-1) + (ly-1) * WIDTH] = 255; // move down and left
                break;
                case 3:
                  leds[getPixelNumber(lx-1,ly-1)] = CRGB(128,128,128);
                  lightning[(lx-1) + (ly-1) * WIDTH] = 255; // fork down and left
                  leds[getPixelNumber(lx-1,ly-1)] = CRGB(128,128,128);
                  lightning[(lx+1) + (ly-1) * WIDTH] = 255; // fork down and right
                break;
              }
            }
          }
        }
      }
      free(lightning);
    }

    // Step 6. Add clouds if called for
    if (clouds) {
      uint16_t noiseScale = 250;  // A value of 1 will be so zoomed in, you'll mostly see solid colors. A value of 4011 will be very zoomed out and shimmery
      const uint16_t cloudHeight = (HEIGHT*0.2)+1;

      // This is the array that we keep our computed noise values in
      //static uint8_t noise[WIDTH][cloudHeight];
      static uint8_t *noise = (uint8_t *) malloc(WIDTH * cloudHeight);
//      while (noise == NULL) { Serial.println("noise malloc failed"); }
      int xoffset = noiseScale * x + hue;

      for(int z = 0; z < cloudHeight; z++) {
        int yoffset = noiseScale * z - hue;
        uint8_t dataSmoothing = 192;
        uint8_t noiseData = qsub8(inoise8(noiseX + xoffset,noiseY + yoffset,noiseZ),16);
        noiseData = qadd8(noiseData,scale8(noiseData,39));
        noise[x * cloudHeight + z] = scale8( noise[x * cloudHeight + z], dataSmoothing) + scale8( noiseData, 256 - dataSmoothing);
        nblend(leds[getPixelNumber(x,HEIGHT-z-1)], ColorFromPalette(rainClouds_p, noise[x * cloudHeight + z]), (cloudHeight-z)*(250/cloudHeight));
      }
      noiseZ ++;
    }
  }
}

uint8_t myScale8(uint8_t x) { // даёт масштабировать каждые 8 градаций (от 0 до 7) бегунка Масштаб в значения от 0 до 255 по типа синусоиде
  uint8_t x8 = x % 8U;
  uint8_t x4 = x8 % 4U;
  if (x4 == 0U)
    if (x8 == 0U)       return 0U;
    else                return 255U;
  else if (x8 < 4U)     return (1U   + x4 * 72U); // всего 7шт по 36U + 3U лишних = 255U (чтобы восхождение по синусоиде не было зеркально спуску)
//else
                        return (253U - x4 * 72U); // 253U = 255U - 2U
}

void coloredRain() // внимание! этот эффект заточен на работу бегунка Масштаб в диапазоне от 0 до 100. пока что единственный.
{
  // я хз, как прикрутить а 1 регулятор и длину хвостов и цвет капель
  // ( Depth of dots, maximum brightness, frequency of new dots, length of tails, color, splashes, clouds, ligthening )
  //rain(60, 200+, map8(intensity,5,100), 195, CRGB::Green, false, false, false); // было CRGB::Green
  if (modes[currentMode].Scale > 247U)
    rain(60, 200, map8(42,5,100), myScale8(modes[currentMode].Scale*2.55), solidRainColor, false, false, false);
  else
    rain(60, 200, map8(42,5,100), myScale8(modes[currentMode].Scale*2.55), CHSV(modes[currentMode].Scale*2.55, 255U, 255U), false, false, false);
}

void simpleRain()
{
  // ( Depth of dots, maximum brightness, frequency of new dots, length of tails, color, splashes, clouds, ligthening )
  //rain(60, 200, map8(intensity,2,60), 10, solidRainColor, true, true, false);
  rain(60, 180,(modes[currentMode].Scale*2.55-1), 30, solidRainColor, true, true, false);
}

void stormyRain()
{
  // ( Depth of dots, maximum brightness, frequency of new dots, length of tails, color, splashes, clouds, ligthening )
  //rain(0, 90, map8(intensity,0,150)+60, 10, solidRainColor, true, true, true);
  rain(60, 160, (modes[currentMode].Scale*2.55-1), 30, solidRainColor, true, true, true);
}

// ------------- цвет + вода в бассейне ------------------
// (с) Сотнег. 03.2020
// эффект иммеет шов на стыке краёв матрицы (сзади лампы, как и у других эффектов), зато адаптирован для нестандартных размеров матриц.
// можно было бы сделать абсолютно бесшовный вариант для конкретной матрицы (16х16), но уже была бы заметна зацикленность анимации.

// далее идёт массив из 25 кадров анимации с маской бликов на воде (размер картинки больше размера матрицы, чтобы повторяемость картинки была незаметной)
// бесшовную анимированную текстуру бликов делал в программе Substance Designer (30 дней бесплатно работает) при помощи плагина Bruno Caustics Generator
// но сразу под такой мелкий размер текстура выходит нечёткой, поэтому пришлось делать крупную и потом в фотошопе доводить её до ума
// конвертировал в массив через сервис https://littlevgl.com/image-to-c-array, 
// чтобы из ч/б картинки получить массив для коррекции параметра насыщенности цвета, использовал настройки True color -> C array
// последовательность замен полученных блоков массива в ворде: "^p  0x"->"^p  {0x"  ...  ", ^p"->"},^p" ... "},^p#endif"->"}^p },^p {"
static const uint8_t aquariumGIF[25][32][32] PROGMEM =
{
 {
  {0x2b, 0x00, 0x00, 0x00, 0x00, 0x07, 0x17, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xa0, 0xe4, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x36, 0x00, 0x00, 0x2e, 0x48, 0x00, 0x00, 0x00, 0x09, 0x77},
  {0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x3d, 0x3c, 0x2e, 0x33, 0x42, 0x8b, 0xe7, 0x8d, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x02, 0x00, 0x00, 0x0a, 0x90, 0x53, 0x26, 0x2f, 0x82, 0xab},
  {0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3a, 0x39, 0x21, 0x14, 0x00, 0x3f, 0x72, 0x4f, 0x67, 0x5d, 0x3c, 0x20, 0x12, 0x42, 0x60, 0x00, 0x00, 0x00, 0x1c, 0xb3, 0x6a, 0x2d, 0x27, 0x3a, 0x71},
  {0x44, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x47, 0x00, 0x0e, 0x44, 0x60, 0x62, 0x5d, 0x92, 0xb5, 0x3d, 0x02, 0x13, 0x7c, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x35},
  {0x4f, 0x11, 0x0e, 0x26, 0x35, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06, 0x6e, 0x27, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x11, 0x47, 0x95, 0x7e, 0x82, 0x6d, 0x13, 0x00, 0x00, 0x00, 0x00, 0x32},
  {0x04, 0x05, 0x0b, 0x30, 0x6f, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x8c, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x42, 0x3f, 0x37, 0x1a, 0x00, 0x00, 0x00, 0x06, 0x24},
  {0x00, 0x00, 0x00, 0x00, 0x29, 0x25, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7b, 0x65, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x15, 0x00, 0x00, 0x19, 0x3a, 0x05, 0x00, 0x00, 0x1c, 0x0c},
  {0x00, 0x00, 0x00, 0x00, 0x02, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x52, 0x00, 0x0a, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x07, 0x00, 0x00, 0x00, 0x36, 0x29, 0x00, 0x13, 0x1e, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x2f, 0x04, 0x13, 0x60, 0x68, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x23, 0x3b, 0x36, 0x3a, 0x05, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0xa8, 0x62, 0x7c, 0xac, 0x22, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x1b, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x3a, 0x5f, 0x30, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x32, 0x86, 0x59, 0x24, 0x23, 0x5b, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x00, 0x06, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0xad, 0x47, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x48, 0x79, 0x26, 0x00, 0x00, 0x00, 0x09, 0x4b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0e, 0x22, 0x11, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x45, 0x63, 0x9f, 0xa8, 0x30, 0x00},
  {0x2a, 0x44, 0x76, 0x6e, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x64, 0x04, 0x00, 0x00, 0x1e, 0x4b, 0x53, 0x34, 0x09, 0x05, 0x5f, 0xa8, 0x5f},
  {0xae, 0x87, 0x84, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x4c, 0x13, 0x00, 0x00, 0x00, 0x00, 0x04, 0x7d, 0xa7, 0x5a, 0x41, 0x51, 0x55, 0x35, 0x07, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xca},
  {0x64, 0x05, 0x09, 0x22, 0x1e, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x7e, 0x38, 0x19, 0x0e, 0x2e, 0x71, 0x5f, 0x2e, 0x3c, 0x8d, 0x65, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c},
  {0x2e, 0x00, 0x00, 0x00, 0x16, 0x20, 0x13, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x85, 0x58, 0x47, 0x7b, 0xa6, 0x42, 0x00, 0x00, 0x00, 0x31, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x63},
  {0x31, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1d, 0x1f, 0x0d, 0x00, 0x20, 0x49, 0x0a, 0x00, 0x00, 0x3f, 0x63, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x72},
  {0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x21, 0x4c, 0x5d, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x33, 0x03, 0x00, 0x00, 0x00, 0x20, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x79},
  {0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x0a, 0x00, 0x00, 0x00, 0x20, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x7a},
  {0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x1f, 0x00, 0x00, 0x00, 0x21, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x78},
  {0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x2f, 0x00, 0x00, 0x01, 0x14, 0x2e, 0x85, 0x79, 0x11, 0x00, 0x00, 0x23, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x75},
  {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x64, 0x20, 0x26, 0x32, 0x2e, 0x27, 0x20, 0x4a, 0x63, 0x38, 0x07, 0x31, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x6f},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x93, 0x30, 0x1e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x18, 0x4d, 0x77, 0x96, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x62},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x90, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x8b, 0xee, 0xaf, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x51},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x94, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x47, 0x39, 0x39, 0x87, 0xb6, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x7d, 0x57},
  {0x22, 0x00, 0x00, 0x00, 0x03, 0x2d, 0x65, 0x71, 0x38, 0x20, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x51, 0x22, 0x00, 0x00, 0x00, 0x44, 0xac, 0x7e, 0x38, 0x39, 0x47, 0x53, 0x6f, 0x6d},
  {0x78, 0x72, 0x68, 0x7e, 0x9b, 0xb1, 0xa8, 0x4b, 0x00, 0x00, 0x15, 0x13, 0x00, 0x00, 0x00, 0x00, 0x08, 0x4d, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0xaf, 0x91, 0x5f, 0x57, 0x3f, 0x2f, 0x51},
  {0xa0, 0x9e, 0x69, 0x90, 0x93, 0x37, 0x1d, 0x33, 0x33, 0x09, 0x00, 0x19, 0x0d, 0x00, 0x00, 0x00, 0x36, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x8b, 0x24, 0x15, 0x10, 0x16, 0x43},
  {0x85, 0x2a, 0x00, 0x0e, 0x1f, 0x00, 0x00, 0x00, 0x1e, 0x37, 0x11, 0x00, 0x20, 0x02, 0x00, 0x0b, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xae, 0x55, 0x00, 0x00, 0x00, 0x00, 0x20},
  {0x5f, 0x07, 0x00, 0x00, 0x17, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x3c, 0x0f, 0x0d, 0x1c, 0x04, 0x78, 0x86, 0x0d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0xc8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x12},
  {0x61, 0x00, 0x00, 0x00, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x11, 0x38, 0x05, 0x36, 0x84, 0x80, 0x42, 0x1e, 0x15, 0x15, 0x13, 0x01, 0x1e, 0x4e, 0x90, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x28},
  {0x53, 0x00, 0x00, 0x00, 0x02, 0x16, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x37, 0x6c, 0x8c, 0x01, 0x00, 0x00, 0x04, 0x0e, 0x1c, 0x6c, 0x83, 0x2a, 0x00, 0x53, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x43}
 },
 {
  {0x8d, 0x0b, 0x00, 0x00, 0x00, 0x05, 0x23, 0x1d, 0x0f, 0x15, 0x49, 0x85, 0x63, 0xb9, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x17, 0x07, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67},
  {0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x42, 0x26, 0x27, 0x29, 0x30, 0x80, 0xf1, 0x9a, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x70, 0x71, 0x26, 0x2d, 0x33, 0x61, 0xb6},
  {0x14, 0x00, 0x00, 0x00, 0x04, 0x1c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x7f, 0x5d, 0x69, 0x58, 0x35, 0x19, 0x0d, 0x10, 0x55, 0x58, 0x00, 0x08, 0x93, 0x89, 0x39, 0x38, 0x2e, 0x30, 0x59},
  {0x31, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x4c, 0x00, 0x14, 0x4c, 0x64, 0x66, 0x62, 0x62, 0x94, 0xa7, 0x5b, 0x82, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d},
  {0x63, 0x15, 0x06, 0x06, 0x1b, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6c, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x16, 0x14, 0x1b, 0x6e, 0x5b, 0x44, 0x64, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1d},
  {0x2d, 0x0e, 0x08, 0x22, 0x56, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x70, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x36, 0x00, 0x00, 0x3d, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x25},
  {0x00, 0x00, 0x00, 0x03, 0x39, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x31, 0x00, 0x00, 0x09, 0x56, 0x0d, 0x00, 0x00, 0x0b, 0x1f},
  {0x00, 0x00, 0x00, 0x00, 0x07, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x17, 0x88, 0x4d, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x2b, 0x00, 0x00, 0x00, 0x38, 0x44, 0x00, 0x00, 0x25, 0x08},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x10, 0x00, 0x00, 0x0b, 0x6b, 0x3a, 0x04, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x24, 0x00, 0x00, 0x00, 0x03, 0x54, 0x23, 0x1f, 0x18, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x6c, 0x39, 0x44, 0x8a, 0x55, 0x00, 0x00, 0x02, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x27, 0x00, 0x00, 0x00, 0x00, 0x27, 0x8c, 0x3c, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x97, 0x58, 0x55, 0x89, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x35, 0x32, 0x00, 0x00, 0x00, 0x07, 0x51, 0xd8, 0x57, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x0b, 0x5c, 0x65, 0x13, 0x00, 0x00, 0x16, 0x41, 0x02, 0x00, 0x00, 0x00, 0x02, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x25, 0x38, 0x49, 0x54, 0x5b, 0x69, 0x9b, 0xa6, 0x31, 0x00},
  {0x2b, 0x38, 0x61, 0x95, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x26, 0x37, 0x73, 0x71, 0x55, 0x66, 0x58, 0x3d, 0x20, 0x02, 0x01, 0x59, 0xa5, 0x61},
  {0xaf, 0x76, 0x74, 0x65, 0x30, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43, 0x07, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x95, 0x6d, 0x76, 0x9b, 0x5b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xc6},
  {0x66, 0x05, 0x00, 0x00, 0x0d, 0x1e, 0x14, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x5b, 0x1d, 0x07, 0x1e, 0x69, 0x65, 0x26, 0x00, 0x00, 0x3d, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78},
  {0x31, 0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0x1c, 0x0d, 0x00, 0x00, 0x2e, 0x7d, 0x4e, 0x5c, 0x93, 0x55, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60},
  {0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1a, 0x1e, 0x2f, 0x4a, 0x16, 0x02, 0x2b, 0x68, 0x08, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x6f},
  {0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x6f, 0x28, 0x00, 0x00, 0x00, 0x33, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x76},
  {0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x11, 0x00, 0x00, 0x00, 0x2f, 0x16, 0x00, 0x00, 0x00, 0x00, 0x18, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x79},
  {0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3a, 0x0f, 0x00, 0x00, 0x00, 0x38, 0x27, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x77},
  {0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41, 0x15, 0x00, 0x06, 0x1a, 0x6f, 0x79, 0x0a, 0x00, 0x00, 0x00, 0x1e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x74},
  {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x5c, 0x22, 0x26, 0x26, 0x29, 0x52, 0x62, 0x2f, 0x00, 0x00, 0x21, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6f},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x92, 0x53, 0x12, 0x04, 0x00, 0x00, 0x00, 0x22, 0x5a, 0x50, 0x42, 0x6b, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x64},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x93, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0xc3, 0xdf, 0x9a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x52},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x5f, 0x71, 0x3d, 0x27, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x47, 0x2e, 0x3f, 0x8f, 0xad, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x41},
  {0x02, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x70, 0x56, 0x09, 0x00, 0x00, 0x18, 0x16, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x52, 0xa8, 0x62, 0x19, 0x31, 0x53, 0x75, 0xb5, 0x76},
  {0x88, 0x4b, 0x44, 0x54, 0x81, 0x93, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x0f, 0x00, 0x00, 0x2a, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0xb7, 0xcc, 0x95, 0x7b, 0x68, 0x79, 0xa7},
  {0xb9, 0xb6, 0x72, 0x91, 0xaa, 0x64, 0x29, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x03, 0x20, 0x00, 0x01, 0x46, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xb3, 0x1f, 0x00, 0x00, 0x00, 0x27},
  {0x59, 0x69, 0x05, 0x15, 0x30, 0x04, 0x13, 0x28, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x23, 0x55, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0xa9, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x4a, 0x40, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x1d, 0x22, 0x00, 0x00, 0x00, 0x00, 0x64, 0xcb, 0x5e, 0x14, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x59, 0x37, 0x00, 0x00, 0x0d, 0x10, 0x00, 0x00, 0x00, 0x1b, 0x20, 0x00, 0x00, 0x00, 0x91, 0x75, 0x16, 0x14, 0x15, 0x19, 0x18, 0x11, 0x00, 0x29, 0xd8, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x82, 0x25, 0x00, 0x00, 0x01, 0x13, 0x01, 0x00, 0x00, 0x00, 0x28, 0x2a, 0x00, 0x35, 0x79, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12, 0x27, 0x65, 0x70, 0x90, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04}
 },
 {
  {0x84, 0x00, 0x00, 0x00, 0x07, 0x45, 0x4b, 0x1c, 0x24, 0x60, 0x82, 0x5e, 0x3f, 0x9a, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x89, 0x9c, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53},
  {0x42, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x1a, 0x06, 0x07, 0x02, 0x14, 0x3e, 0x86, 0xf7, 0xa5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x7d, 0x86, 0x2f, 0x28, 0x30, 0x36, 0x58, 0xbe},
  {0x26, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x91, 0x6b, 0x6a, 0x52, 0x2e, 0x13, 0x07, 0x0a, 0x1c, 0x71, 0x9a, 0xa8, 0x9e, 0x4b, 0x3e, 0x3f, 0x33, 0x2d, 0x5a},
  {0x2d, 0x00, 0x00, 0x00, 0x02, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4e, 0x00, 0x1b, 0x53, 0x67, 0x66, 0x62, 0x62, 0x80, 0xb3, 0x6f, 0x6b, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
  {0x5b, 0x22, 0x02, 0x00, 0x0e, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x69, 0x32, 0x00, 0x00, 0x00, 0x00, 0x11, 0x1d, 0x1c, 0x42, 0x4f, 0x00, 0x00, 0x53, 0x13, 0x00, 0x00, 0x00, 0x00, 0x05},
  {0x4f, 0x22, 0x09, 0x1f, 0x4f, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x71, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x28, 0x00, 0x00, 0x35, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x12},
  {0x09, 0x00, 0x00, 0x0e, 0x47, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x1d, 0x00, 0x00, 0x03, 0x5a, 0x1a, 0x00, 0x00, 0x00, 0x24},
  {0x00, 0x00, 0x00, 0x00, 0x0d, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3d, 0x0f, 0x00, 0x00, 0x00, 0x2e, 0x52, 0x00, 0x00, 0x17, 0x1b},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x0a, 0x00, 0x00, 0x00, 0x31, 0x8b, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x3c, 0x09, 0x00, 0x00, 0x00, 0x00, 0x55, 0x28, 0x08, 0x2b, 0x03},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x32, 0x01, 0x04, 0x30, 0x6f, 0x2a, 0x09, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x3b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x18, 0x76, 0x4f, 0x0b, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x8f, 0x5d, 0x53, 0x95, 0x4d, 0x00, 0x00, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc3, 0x83, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x2a, 0x72, 0x60, 0x2b, 0x1e, 0x3e, 0x3a, 0x00, 0x00, 0x00, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x34, 0x0f, 0x23, 0x3d, 0x52, 0x6c, 0xac, 0xb4, 0x36, 0x00},
  {0x2b, 0x38, 0x56, 0x7a, 0xa0, 0x64, 0x00, 0x00, 0x00, 0x00, 0x32, 0x1c, 0x00, 0x00, 0x00, 0x0d, 0x26, 0x19, 0x26, 0x3e, 0x6d, 0xcc, 0xa7, 0x5e, 0x62, 0x5e, 0x45, 0x21, 0x0d, 0x56, 0xa2, 0x62},
  {0xae, 0x75, 0x6a, 0x51, 0x32, 0x23, 0x15, 0x03, 0x00, 0x00, 0x0d, 0x3a, 0x00, 0x00, 0x0c, 0x32, 0x68, 0x88, 0x84, 0x61, 0x5e, 0x97, 0x66, 0x16, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xc0},
  {0x66, 0x05, 0x00, 0x00, 0x00, 0x00, 0x12, 0x1a, 0x10, 0x00, 0x00, 0x2f, 0x4e, 0x2e, 0x23, 0x1c, 0x1f, 0x3f, 0x1a, 0x00, 0x00, 0x24, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73},
  {0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x16, 0x17, 0x0e, 0x38, 0x8f, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d},
  {0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x2f, 0x63, 0x4f, 0x14, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x13, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6c},
  {0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x4a, 0x01, 0x0b, 0x15, 0x0f, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x73},
  {0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x32, 0x00, 0x00, 0x3c, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x36, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x76},
  {0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x32, 0x00, 0x00, 0x2f, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x75},
  {0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x40, 0x0a, 0x0a, 0x53, 0x75, 0x09, 0x00, 0x00, 0x00, 0x00, 0x17, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x73},
  {0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7d, 0x44, 0x1a, 0x29, 0x53, 0x60, 0x25, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x6e},
  {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x89, 0x95, 0x20, 0x00, 0x00, 0x00, 0x28, 0x5d, 0x4a, 0x1d, 0x15, 0x51, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x64},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x5e, 0x74, 0x51, 0x39, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x74, 0xad, 0xa2, 0xd0, 0x90, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x51},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x7a, 0x5c, 0x11, 0x00, 0x00, 0x20, 0x15, 0x00, 0x00, 0x00, 0x16, 0x56, 0x48, 0x35, 0x50, 0x97, 0x9f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x01, 0x57, 0x44},
  {0x0b, 0x00, 0x00, 0x00, 0x09, 0x54, 0x74, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x0c, 0x00, 0x15, 0x4f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x5f, 0xa2, 0x54, 0x1f, 0x43, 0x66, 0x80, 0xbc, 0x87},
  {0x93, 0x3e, 0x25, 0x3b, 0x67, 0x5a, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x23, 0x1a, 0x4b, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0xc5, 0xce, 0x93, 0x76, 0x5d, 0x6a, 0xa1},
  {0x9c, 0xc4, 0x81, 0x9a, 0x8f, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x78, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xc2, 0x94, 0x0f, 0x00, 0x00, 0x00, 0x13},
  {0x2a, 0x90, 0x34, 0x2b, 0x60, 0x40, 0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xa7, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1b, 0x62, 0x00, 0x00, 0x1e, 0x1b, 0x17, 0x1b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xc4, 0x66, 0x15, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x90, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3a, 0x8a, 0x0c, 0x00, 0x0a, 0x0a, 0x00, 0x06, 0x1b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x73, 0x72, 0x07, 0x0b, 0x12, 0x18, 0x1c, 0x18, 0x07, 0x22, 0xb7, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x74, 0x5e, 0x06, 0x00, 0x09, 0x28, 0x15, 0x00, 0x0d, 0x53, 0x30, 0x00, 0x00, 0x19, 0x82, 0x09, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x18, 0x2a, 0xab, 0xc4, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x7b, 0x07, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x13, 0x40, 0x61, 0x61, 0x43, 0x1e, 0x61, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d},
  {0x4f, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0x00, 0x00, 0x00, 0x27, 0x49, 0x73, 0xcf, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0xe3, 0x4e, 0x23, 0x24, 0x2a, 0x30, 0x45, 0xa6},
  {0x2d, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x8d, 0x68, 0x5a, 0x40, 0x20, 0x0a, 0x01, 0x04, 0x17, 0x57, 0xa2, 0xbf, 0x7c, 0x3e, 0x3a, 0x39, 0x2f, 0x25, 0x49},
  {0x26, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x44, 0x00, 0x1d, 0x4b, 0x59, 0x56, 0x50, 0x57, 0x88, 0x94, 0x28, 0x32, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
  {0x3d, 0x22, 0x00, 0x00, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x2e, 0x00, 0x00, 0x00, 0x02, 0x14, 0x1d, 0x25, 0x5d, 0x2f, 0x00, 0x00, 0x48, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x49, 0x37, 0x08, 0x15, 0x38, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x5f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x08, 0x00, 0x00, 0x25, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1f, 0x00, 0x03, 0x13, 0x46, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x37, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x23, 0x00, 0x00, 0x00, 0x14},
  {0x01, 0x00, 0x00, 0x00, 0x12, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x32, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x4f, 0x00, 0x00, 0x04, 0x21},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x06, 0x00, 0x00, 0x00, 0x10, 0x63, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2f, 0x00, 0x22, 0x12},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x19, 0x00, 0x00, 0x00, 0x35, 0x60, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x5a, 0x41, 0x1e, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x46, 0x24, 0x24, 0x3e, 0x4a, 0x29, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x8b, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x14, 0x56, 0x82, 0x52, 0x3d, 0x5a, 0x44, 0x00, 0x00, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x45, 0x00, 0x00, 0x05, 0x19, 0x31, 0x52, 0x8e, 0xa0, 0x38, 0x00},
  {0x24, 0x2e, 0x48, 0x61, 0x6d, 0x74, 0x54, 0x1d, 0x00, 0x05, 0x2d, 0x0b, 0x00, 0x20, 0x4b, 0x40, 0x38, 0x38, 0x3a, 0x44, 0x79, 0xb1, 0x70, 0x4d, 0x58, 0x5d, 0x53, 0x3b, 0x21, 0x4b, 0x88, 0x53},
  {0x92, 0x62, 0x58, 0x42, 0x1f, 0x03, 0x05, 0x11, 0x0d, 0x00, 0x15, 0x3f, 0x30, 0x2c, 0x2f, 0x2a, 0x29, 0x3b, 0x6b, 0x5f, 0x44, 0x83, 0x7b, 0x33, 0x21, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x33, 0x9e},
  {0x57, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x10, 0x2a, 0x6c, 0x42, 0x01, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x17, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d},
  {0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x75, 0x19, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c},
  {0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x65, 0x27, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x09, 0x2c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x58},
  {0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x42, 0x00, 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x00, 0x06, 0x2e, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x5f},
  {0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x5f, 0x00, 0x00, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x05, 0x2e, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x62},
  {0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x5b, 0x1a, 0x03, 0x0c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07, 0x2f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x61},
  {0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x50, 0x51, 0x5f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x2e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x60},
  {0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x63, 0x77, 0x3b, 0x4e, 0x54, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x5c},
  {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x44, 0x62, 0x57, 0x47, 0x1d, 0x00, 0x24, 0x4e, 0x35, 0x0a, 0x00, 0x01, 0x32, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x54},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x68, 0x57, 0x1f, 0x00, 0x00, 0x21, 0x0c, 0x00, 0x07, 0x57, 0x87, 0x73, 0x73, 0xa7, 0x71, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x44},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x4f, 0x69, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x04, 0x23, 0x04, 0x00, 0x46, 0x5c, 0x40, 0x3a, 0x55, 0x85, 0x7a, 0x21, 0x00, 0x00, 0x00, 0x00, 0x07, 0x4f, 0x3d},
  {0x14, 0x00, 0x00, 0x00, 0x20, 0x5f, 0x51, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x34, 0x4d, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x05, 0x59, 0x82, 0x3d, 0x23, 0x49, 0x64, 0x75, 0xa4, 0x80},
  {0x88, 0x34, 0x0d, 0x30, 0x5b, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xb2, 0xae, 0x7a, 0x5e, 0x44, 0x4c, 0x82},
  {0x6b, 0xa4, 0x80, 0x77, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0xb1, 0x60, 0x03, 0x00, 0x00, 0x00, 0x05},
  {0x00, 0x7e, 0x78, 0x52, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x70, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x60, 0x4d, 0x1b, 0x5f, 0x43, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x94, 0x70, 0x16, 0x11, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x8c, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1a, 0x70, 0x1d, 0x04, 0x39, 0x6c, 0x45, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x6d, 0x00, 0x02, 0x0a, 0x12, 0x18, 0x18, 0x10, 0x44, 0x96, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x58, 0x4a, 0x00, 0x00, 0x00, 0x46, 0x59, 0x5e, 0x5c, 0x30, 0x06, 0x00, 0x00, 0x04, 0x71, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1b, 0xa3, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x87, 0x12, 0x00, 0x00, 0x00, 0x11, 0x24, 0x28, 0x56, 0x6a, 0x59, 0x31, 0x0a, 0x3e, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34},
  {0x67, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x09, 0x00, 0x00, 0x14, 0x40, 0x5a, 0x6d, 0xc5, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0xeb, 0x4d, 0x24, 0x24, 0x2b, 0x33, 0x42, 0xa7},
  {0x37, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x9f, 0x77, 0x5a, 0x3a, 0x1a, 0x05, 0x00, 0x00, 0x1d, 0x6c, 0x9d, 0xbd, 0x8c, 0x45, 0x3e, 0x3d, 0x34, 0x25, 0x43},
  {0x28, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x48, 0x00, 0x24, 0x4f, 0x5a, 0x54, 0x4e, 0x61, 0xa2, 0x83, 0x11, 0x27, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x2f, 0x20, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x32, 0x00, 0x00, 0x00, 0x07, 0x1a, 0x23, 0x4a, 0x6e, 0x0b, 0x00, 0x00, 0x48, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3e, 0x52, 0x09, 0x0e, 0x2a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x69, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x32, 0x00, 0x00, 0x00, 0x1b, 0x55, 0x01, 0x00, 0x00, 0x00, 0x00},
  {0x2e, 0x18, 0x06, 0x17, 0x4b, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x52, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x29, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x31, 0x00, 0x00, 0x00, 0x04},
  {0x11, 0x00, 0x00, 0x00, 0x1c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x3d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x15, 0x57, 0x04, 0x00, 0x00, 0x1c},
  {0x00, 0x00, 0x00, 0x00, 0x01, 0x24, 0x02, 0x00, 0x00, 0x00, 0x00, 0x14, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x40, 0x00, 0x0f, 0x24},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x79, 0x5d, 0x3c, 0x09},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x43, 0x07, 0x00, 0x00, 0x02, 0x37, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x4f, 0x6f, 0x4d, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x12, 0x52, 0x9b, 0x5e, 0x18, 0x10, 0x16, 0x03, 0x1b, 0x2f, 0x19, 0x17, 0x15, 0x0e, 0x04, 0x00, 0x4b, 0x29, 0x00, 0x00, 0x00, 0x00, 0x23, 0x54, 0x03, 0x00, 0x3f, 0x10},
  {0x27, 0x2c, 0x46, 0x5f, 0x69, 0x68, 0x63, 0x65, 0x6e, 0x74, 0x23, 0x00, 0x45, 0x65, 0x48, 0x45, 0x48, 0x47, 0x4a, 0x60, 0xa3, 0x9f, 0x4b, 0x3f, 0x4e, 0x5b, 0x6f, 0x68, 0x26, 0x13, 0x60, 0x71},
  {0x92, 0x5f, 0x56, 0x41, 0x1f, 0x01, 0x00, 0x00, 0x1c, 0x50, 0x6d, 0x5d, 0x37, 0x0f, 0x04, 0x04, 0x06, 0x0b, 0x20, 0x56, 0x54, 0x88, 0x97, 0x55, 0x40, 0x2d, 0x12, 0x07, 0x16, 0x1d, 0x49, 0xa2},
  {0x58, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x12, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c},
  {0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x02, 0x27, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48},
  {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x63, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x02, 0x2d, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55},
  {0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x6a, 0x1b, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x5c},
  {0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x3a, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x5f},
  {0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x55, 0x00, 0x00, 0x03, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x5f},
  {0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x96, 0x3a, 0x00, 0x0d, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x2f, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x5e},
  {0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x64, 0x94, 0x9b, 0x7f, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x2c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x5b},
  {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x61, 0x61, 0x33, 0x0d, 0x32, 0x87, 0x80, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x21, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x54},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x52, 0x6d, 0x3e, 0x05, 0x00, 0x00, 0x00, 0x0d, 0x5c, 0x6e, 0x6c, 0x62, 0x5c, 0x64, 0x98, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x44},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x68, 0x58, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x76, 0x86, 0x57, 0x48, 0x4b, 0x65, 0x8a, 0x6b, 0x15, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x56, 0x42},
  {0x21, 0x00, 0x00, 0x01, 0x3c, 0x67, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x75, 0x26, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x78, 0x35, 0x2e, 0x59, 0x72, 0x7c, 0xa6, 0x8d},
  {0x93, 0x3e, 0x0d, 0x3e, 0x55, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x59, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0xbc, 0xab, 0x77, 0x55, 0x39, 0x3e, 0x79},
  {0x56, 0xa6, 0x96, 0x59, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0xb6, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x74, 0xcf, 0x79, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x97, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x51, 0x67, 0x50, 0x7a, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x7e, 0x21, 0x11, 0x14, 0x0f, 0x04, 0x00, 0x10, 0x96, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x0e, 0x6b, 0x13, 0x00, 0x44, 0x92, 0x4f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x79, 0x00, 0x00, 0x03, 0x0d, 0x16, 0x18, 0x1a, 0x74, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x50, 0x59, 0x00, 0x00, 0x00, 0x51, 0x88, 0x65, 0x46, 0x18, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x18, 0xb4, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x8e, 0x1f, 0x00, 0x00, 0x00, 0x10, 0x3f, 0x45, 0x64, 0x66, 0x47, 0x1b, 0x00, 0x1e, 0x73, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a},
  {0x7c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x02, 0x2e, 0x56, 0x62, 0x5d, 0xad, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0xee, 0x4e, 0x24, 0x24, 0x2b, 0x34, 0x3f, 0xa1},
  {0x3f, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x62, 0xb0, 0x87, 0x58, 0x32, 0x13, 0x00, 0x00, 0x00, 0x2a, 0x7f, 0x90, 0xb5, 0x9a, 0x4c, 0x40, 0x3f, 0x38, 0x27, 0x38},
  {0x28, 0x0b, 0x00, 0x00, 0x00, 0x0e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x56, 0x0a, 0x29, 0x51, 0x59, 0x50, 0x4d, 0x74, 0xad, 0x61, 0x01, 0x1d, 0x60, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x25, 0x1e, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x03, 0x04, 0x3c, 0x45, 0x00, 0x00, 0x00, 0x0d, 0x1f, 0x2d, 0x76, 0x60, 0x00, 0x00, 0x00, 0x44, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x26, 0x59, 0x0c, 0x06, 0x1a, 0x12, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00, 0x21, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x1b, 0x00, 0x00, 0x00, 0x12, 0x5b, 0x08, 0x00, 0x00, 0x00, 0x00},
  {0x2a, 0x3d, 0x0d, 0x17, 0x4a, 0x0f, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x20, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x40, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x45, 0x3e, 0x00, 0x00, 0x00, 0x00},
  {0x27, 0x00, 0x00, 0x00, 0x29, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x28, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x5c, 0x0b, 0x00, 0x00, 0x0d},
  {0x12, 0x00, 0x00, 0x00, 0x03, 0x3f, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x70, 0x04, 0x00, 0x22},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x24, 0x00, 0x00, 0x00, 0x00, 0x12, 0x2f, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x8f, 0x41, 0x3b, 0x2f},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x1d, 0x00, 0x00, 0x00, 0x13, 0x12, 0x00, 0x0a, 0x19, 0x00, 0x00, 0x00, 0x00, 0x11, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x14, 0x65, 0x4f},
  {0x06, 0x00, 0x00, 0x00, 0x17, 0x7a, 0x66, 0x09, 0x00, 0x17, 0x11, 0x00, 0x00, 0x03, 0x65, 0x54, 0x3a, 0x37, 0x2b, 0x4a, 0x69, 0x02, 0x00, 0x00, 0x00, 0x00, 0x25, 0x14, 0x00, 0x00, 0x07, 0x47},
  {0x5e, 0x2c, 0x41, 0x59, 0x69, 0x7c, 0x7f, 0x71, 0x74, 0x30, 0x00, 0x00, 0x0a, 0x46, 0x5a, 0x3d, 0x34, 0x3a, 0x3d, 0x69, 0xbe, 0x86, 0x29, 0x25, 0x35, 0x5e, 0x88, 0x21, 0x00, 0x00, 0x00, 0x40},
  {0xac, 0x60, 0x50, 0x3e, 0x1d, 0x03, 0x09, 0x32, 0x6f, 0x64, 0x16, 0x22, 0x47, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x62, 0xa0, 0xa1, 0x6e, 0x58, 0x55, 0x51, 0x41, 0x2c, 0x21, 0x25, 0x86},
  {0x61, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x8f, 0x67, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x13, 0x59, 0x1d, 0x00, 0x00, 0x00, 0x05, 0x1c, 0x24, 0x35, 0x82},
  {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x28, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49},
  {0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x2c, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d},
  {0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x31, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x57},
  {0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x6d, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x2d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5b},
  {0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x33, 0x00, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x5c},
  {0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x9b, 0x1a, 0x00, 0x00, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x5b},
  {0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x4f, 0x7a, 0x9d, 0x91, 0x64, 0x3b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2d, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x58},
  {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x4b, 0x6d, 0x4e, 0x18, 0x07, 0x3b, 0x8e, 0xaa, 0x33, 0x00, 0x00, 0x00, 0x00, 0x12, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x50},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6c, 0x5e, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x02, 0x66, 0xa3, 0x65, 0x45, 0x48, 0x4e, 0x80, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x56},
  {0x18, 0x00, 0x00, 0x00, 0x05, 0x47, 0x6e, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0xb4, 0x5b, 0x52, 0x56, 0x71, 0x8b, 0x5a, 0x0a, 0x00, 0x00, 0x00, 0x1a, 0x30, 0x58, 0x5f},
  {0x47, 0x11, 0x00, 0x12, 0x55, 0x5a, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x47, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x66, 0x6a, 0x31, 0x3e, 0x66, 0x6c, 0x4d, 0x27, 0x34},
  {0x5f, 0x52, 0x2f, 0x4e, 0x3f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xc1, 0x9e, 0x67, 0x42, 0x2f, 0x31, 0x3f},
  {0x47, 0x8f, 0xa5, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5f, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xb0, 0x2b, 0x00, 0x00, 0x00, 0x05, 0x1d},
  {0x00, 0x73, 0xd3, 0x73, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x9e, 0x4b, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x86, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x4c, 0x7a, 0x60, 0x76, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x82, 0x24, 0x10, 0x15, 0x15, 0x0d, 0x00, 0x32, 0x93, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x06, 0x6a, 0x1f, 0x00, 0x54, 0x8f, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x7e, 0x0c, 0x00, 0x00, 0x04, 0x0f, 0x15, 0x24, 0x9d, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x44, 0x65, 0x00, 0x00, 0x00, 0x60, 0x98, 0x5d, 0x2e, 0x03, 0x00, 0x00, 0x00, 0x00, 0x61, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xb5, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x9e, 0x34, 0x00, 0x00, 0x00, 0x12, 0x67, 0x6b, 0x72, 0x5f, 0x2f, 0x04, 0x00, 0x05, 0x79, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1a, 0x64, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24},
  {0x9d, 0x00, 0x00, 0x00, 0x00, 0x09, 0x13, 0x00, 0x1a, 0x51, 0x75, 0x7a, 0x6a, 0xa8, 0xb8, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x4d, 0xba, 0x95, 0x29, 0x26, 0x2f, 0x3a, 0x45, 0xa4},
  {0x4a, 0x04, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x26, 0x5b, 0x85, 0xd2, 0xba, 0x5f, 0x2d, 0x0d, 0x00, 0x00, 0x00, 0x53, 0xab, 0x83, 0xcb, 0xce, 0x5e, 0x48, 0x48, 0x41, 0x2c, 0x31},
  {0x28, 0x19, 0x00, 0x00, 0x00, 0x0f, 0x0b, 0x00, 0x04, 0x08, 0x06, 0x00, 0x00, 0x55, 0x4a, 0x36, 0x57, 0x5d, 0x51, 0x55, 0x95, 0xbb, 0x54, 0x10, 0x29, 0x75, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x20, 0x23, 0x00, 0x00, 0x00, 0x13, 0x03, 0x03, 0x06, 0x02, 0x00, 0x00, 0x00, 0x3f, 0x2d, 0x00, 0x00, 0x15, 0x27, 0x4f, 0xa0, 0x3d, 0x00, 0x00, 0x00, 0x41, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1e, 0x5f, 0x11, 0x00, 0x0d, 0x27, 0x0a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x32, 0x00, 0x00, 0x00, 0x00, 0x10, 0x48, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6a, 0x13, 0x00, 0x00, 0x00, 0x00},
  {0x25, 0x77, 0x22, 0x14, 0x56, 0x43, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x36, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x65, 0x00, 0x00, 0x00, 0x00},
  {0x19, 0x26, 0x00, 0x08, 0x5e, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x72, 0x44, 0x00, 0x00, 0x00, 0x00, 0x39, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7c, 0x16, 0x00, 0x00, 0x00},
  {0x15, 0x0d, 0x00, 0x00, 0x35, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x22, 0x33, 0x3a, 0x07, 0x00, 0x00, 0x00, 0x3c, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x79, 0x01, 0x00, 0x00},
  {0x34, 0x04, 0x00, 0x00, 0x2f, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 0x0a, 0x00, 0x15, 0x1c, 0x00, 0x00, 0x00, 0x38, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6e, 0x77, 0x34, 0x2b, 0x29},
  {0x59, 0x00, 0x00, 0x00, 0x24, 0x39, 0x00, 0x00, 0x00, 0x0a, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x3b, 0x2d, 0x08, 0x03, 0x4c, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x25, 0x00, 0x0d, 0x2f, 0x92},
  {0x62, 0x00, 0x00, 0x00, 0x4f, 0x77, 0x08, 0x00, 0x0c, 0x24, 0x07, 0x00, 0x00, 0x00, 0x0c, 0x85, 0x84, 0x50, 0x55, 0xaf, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x07, 0x31, 0x00, 0x00, 0x00, 0x00, 0x38},
  {0x6e, 0x63, 0x3e, 0x5a, 0x89, 0xa1, 0x7d, 0x6b, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x22, 0x5e, 0x43, 0x15, 0x14, 0x20, 0x5f, 0xd1, 0x91, 0x44, 0x40, 0x58, 0xac, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0xaf, 0x9d, 0x4f, 0x3e, 0x20, 0x1c, 0x47, 0x94, 0x89, 0x09, 0x00, 0x00, 0x3e, 0x56, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x9d, 0x67, 0x83, 0x85, 0xa7, 0x9a, 0x35, 0x00, 0x00, 0x00, 0x14},
  {0x99, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x77, 0x44, 0x57, 0x48, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x47, 0x10, 0x09, 0x00, 0x00, 0x36, 0x83, 0x5e, 0x3b, 0x3e, 0x97},
  {0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0xbc, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x1c, 0x39, 0x19, 0x00, 0x00, 0x00, 0x00, 0x15, 0x33, 0x27, 0x36, 0x84},
  {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x87, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x2a, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f},
  {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x1f, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56},
  {0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x0d, 0x40, 0x06, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x5d},
  {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x79, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x00, 0x01, 0x35, 0x29, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x5f},
  {0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xb7, 0x90, 0x0a, 0x00, 0x00, 0x03, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x24, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x5d},
  {0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3d, 0x71, 0x90, 0xb0, 0x9e, 0x5c, 0x1e, 0x16, 0x00, 0x00, 0x00, 0x00, 0x02, 0x25, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x5a},
  {0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x71, 0x6e, 0x34, 0x01, 0x0b, 0x56, 0x9d, 0xbd, 0x62, 0x00, 0x00, 0x00, 0x00, 0x07, 0x28, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x5c, 0x7e},
  {0x48, 0x00, 0x00, 0x00, 0x00, 0x07, 0x54, 0x7c, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x6e, 0xb6, 0x6b, 0x35, 0x34, 0x3d, 0x67, 0x52, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x3f, 0x4a, 0x5d, 0x7a},
  {0x57, 0x42, 0x00, 0x00, 0x20, 0x6b, 0x66, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0xcf, 0x7e, 0x5e, 0x65, 0x82, 0x92, 0x51, 0x0b, 0x1a, 0x44, 0x50, 0x39, 0x15, 0x00, 0x0f},
  {0x08, 0x55, 0x42, 0x38, 0x6a, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x71, 0x0e, 0x00, 0x00, 0x00, 0x2c, 0x7b, 0x85, 0x58, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x08, 0x7a, 0x83, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x92, 0x4b, 0x05, 0x13, 0x1a, 0x15, 0x0b, 0x00},
  {0x23, 0x00, 0x6e, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x8b, 0x38, 0x2f, 0x2c, 0x2c, 0x32, 0x36},
  {0x39, 0x62, 0xb7, 0x99, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0x85, 0x12, 0x0b, 0x01, 0x00, 0x00, 0x2a, 0xa5, 0x68, 0x04, 0x00, 0x00, 0x00, 0x04, 0x1a},
  {0x00, 0x7c, 0xb5, 0x88, 0x79, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x8c, 0x24, 0x0f, 0x14, 0x19, 0x26, 0x25, 0x3e, 0x75, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x72, 0x36, 0x06, 0x6e, 0x92, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x87, 0x23, 0x00, 0x00, 0x00, 0x04, 0x2d, 0x3a, 0x26, 0x61, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3a, 0x78, 0x00, 0x00, 0x00, 0x7a, 0xa9, 0x52, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x23, 0x5e, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x9b, 0x46, 0x00, 0x00, 0x00, 0x15, 0x86, 0x83, 0x67, 0x44, 0x1e, 0x07, 0x00, 0x14, 0x89, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x33, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a},
  {0xad, 0x06, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x12, 0x52, 0x9f, 0xac, 0x9f, 0x96, 0xae, 0xe5, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0xb6, 0x53, 0x23, 0x2d, 0x3a, 0x44, 0x91},
  {0x49, 0x0f, 0x00, 0x00, 0x00, 0x06, 0x19, 0x05, 0x12, 0x27, 0x38, 0x5a, 0x86, 0x53, 0x6c, 0x9c, 0x39, 0x05, 0x00, 0x00, 0x24, 0x32, 0x2b, 0x44, 0xa7, 0xf9, 0x8c, 0x46, 0x48, 0x43, 0x2e, 0x25},
  {0x24, 0x22, 0x00, 0x00, 0x00, 0x18, 0x49, 0x16, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x67, 0x92, 0x51, 0x47, 0x6b, 0xbb, 0x99, 0x6b, 0x5a, 0x6e, 0x9f, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x34, 0x4e, 0x00, 0x00, 0x00, 0x52, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x17, 0x2a, 0x18, 0x2d, 0x85, 0xa6, 0x30, 0x03, 0x00, 0x00, 0x38, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x13, 0x71, 0x21, 0x00, 0x29, 0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1d, 0x01, 0x00, 0x00, 0x3d, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0x45, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x42, 0x73, 0x34, 0x7a, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x60, 0x41, 0x00, 0x00, 0x00, 0x48, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x6a, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x21, 0x43, 0x4b, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x40, 0x52, 0x50, 0x04, 0x00, 0x05, 0x4e, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x68, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x26, 0x08, 0x10, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x23, 0x00, 0x00, 0x28, 0x24, 0x00, 0x08, 0x4a, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0xc1, 0x61, 0x0a, 0x00, 0x00},
  {0x14, 0x3d, 0x00, 0x12, 0x4c, 0x05, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x1c, 0x00, 0x00, 0x00, 0x02, 0x31, 0x00, 0x00, 0x48, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x78, 0x4f, 0x3d, 0x3d, 0x1c},
  {0xa0, 0x4b, 0x00, 0x0b, 0x48, 0x06, 0x00, 0x00, 0x00, 0x1e, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x73, 0x5a, 0x8d, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x46, 0x00, 0x00, 0x06, 0x2c, 0x51},
  {0x7c, 0x59, 0x00, 0x13, 0x6b, 0x1a, 0x00, 0x00, 0x24, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x82, 0x6d, 0x67, 0xd4, 0xa2, 0x2a, 0x0e, 0x00, 0x07, 0x4e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x29, 0x9b, 0x4e, 0x64, 0xa6, 0x83, 0x49, 0x46, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x67, 0x22, 0x00, 0x00, 0x53, 0xce, 0x86, 0x62, 0x64, 0x9e, 0xcd, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x5a, 0xca, 0x60, 0x36, 0x33, 0x54, 0x97, 0xad, 0x1e, 0x00, 0x00, 0x00, 0x14, 0x5a, 0x54, 0x08, 0x00, 0x00, 0x00, 0x09, 0x5c, 0x21, 0x17, 0x31, 0x61, 0xaa, 0x92, 0x1e, 0x00, 0x00, 0x00, 0x00},
  {0xb1, 0x55, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x6a, 0x81, 0x18, 0x00, 0x35, 0x66, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0x62, 0x1a, 0x07, 0x3b},
  {0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x94, 0x7f, 0x64, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x4b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x8b, 0x83, 0x64, 0xb0},
  {0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xaf, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x2c, 0x2e, 0x6e},
  {0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x78, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x4d},
  {0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x73, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x25, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x00, 0x04, 0x56},
  {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x05, 0x0a, 0x03, 0x00, 0x00, 0x00, 0x02, 0x09, 0x07, 0x01, 0x00, 0x08, 0x55},
  {0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xd5, 0x61, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0d, 0x00, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x02, 0x06, 0x00, 0x00, 0x00, 0x0a, 0x55},
  {0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x62, 0x79, 0x90, 0xb2, 0x9d, 0x51, 0x04, 0x00, 0x14, 0x02, 0x00, 0x0d, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x58, 0x91},
  {0x6b, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x09, 0x56, 0x7a, 0x4e, 0x0f, 0x00, 0x17, 0x6c, 0xac, 0xa2, 0x6f, 0x14, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x4e, 0x5d, 0x5a, 0x5f, 0x7f},
  {0x4f, 0x69, 0x12, 0x00, 0x00, 0x29, 0x73, 0x66, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x72, 0xc2, 0x73, 0x1c, 0x32, 0x38, 0x00, 0x00, 0x00, 0x00, 0x32, 0x7f, 0x6e, 0x3a, 0x13, 0x00, 0x02},
  {0x00, 0x48, 0x64, 0x1f, 0x42, 0x71, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xc0, 0x93, 0x71, 0x81, 0x67, 0x3b, 0x25, 0x55, 0x7e, 0x42, 0x01, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x5f, 0x9e, 0x6b, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x77, 0x49, 0x0d, 0x1e, 0x4b, 0x88, 0xb9, 0x94, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x30, 0xa6, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x29, 0x73, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x23, 0x82, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x78, 0x11, 0x00, 0x01, 0x08, 0x00, 0x00, 0x60, 0x43, 0x11, 0x15, 0x17, 0x12, 0x08, 0x00},
  {0x20, 0x00, 0x4a, 0xb3, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x99, 0x2f, 0x25, 0x16, 0x02, 0x00, 0x00, 0x47, 0xab, 0x46, 0x22, 0x22, 0x24, 0x29, 0x2c},
  {0x37, 0x6b, 0xa8, 0xc4, 0x7a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x88, 0x20, 0x05, 0x26, 0x17, 0x00, 0x00, 0x00, 0x3b, 0x83, 0x08, 0x00, 0x00, 0x00, 0x02, 0x15},
  {0x00, 0x9f, 0x77, 0x24, 0x7f, 0x7e, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x40, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x41, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x28, 0x7d, 0x02, 0x00, 0x07, 0x88, 0x9c, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x74, 0x00, 0x00, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x42, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x8d, 0x56, 0x00, 0x00, 0x00, 0x1e, 0xa2, 0x9a, 0x74, 0x57, 0x3e, 0x2f, 0x3a, 0x55, 0xc0, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x39, 0x00, 0x00, 0x00, 0x00, 0x10},
  {0xac, 0x17, 0x00, 0x00, 0x00, 0x00, 0x44, 0x82, 0x9e, 0x9b, 0xaf, 0xd1, 0xae, 0x83, 0xbf, 0xae, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0xa1, 0x2b, 0x25, 0x36, 0x43, 0x78},
  {0x4f, 0x1c, 0x00, 0x00, 0x00, 0x13, 0x39, 0x18, 0x00, 0x00, 0x1f, 0x63, 0x2c, 0x00, 0x00, 0x62, 0x8d, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xb6, 0xd6, 0x5c, 0x47, 0x4c, 0x36, 0x22},
  {0x4c, 0x55, 0x00, 0x00, 0x00, 0x3e, 0x29, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xc4, 0x72, 0x16, 0x19, 0x44, 0x68, 0x76, 0x8e, 0xe2, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x17, 0x74, 0x1b, 0x00, 0x27, 0x56, 0x02, 0x00, 0x00, 0x00, 0x00, 0x09, 0x07, 0x00, 0x00, 0x00, 0x0e, 0x7b, 0x7f, 0xa1, 0x96, 0x73, 0x5e, 0x39, 0x16, 0x4c, 0x8d, 0x1b, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x2c, 0x5f, 0x14, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x00, 0x10, 0x2c, 0x1e, 0x85, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x2e, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x71, 0xb4, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x25, 0x0b, 0x19, 0x5d, 0x26, 0x19, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x2e, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x6c, 0xe3, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x56, 0x53, 0x22, 0x38, 0x7f, 0x32, 0x2e, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x70, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x66, 0xa4, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x2a, 0x1b, 0x00, 0x00, 0x00, 0x18, 0x45, 0x50, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xdf, 0x47, 0x19, 0x00, 0x00},
  {0x00, 0x0d, 0x6f, 0x76, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x08, 0x27, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x96, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x69, 0x3e, 0x37, 0x46, 0x4d, 0x2f},
  {0x69, 0x8d, 0x54, 0x4e, 0x1e, 0x00, 0x00, 0x00, 0x0b, 0x2b, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0xf5, 0xb0, 0x15, 0x00, 0x00, 0x00, 0x00, 0x48, 0x22, 0x00, 0x00, 0x00, 0x28, 0x4c},
  {0x37, 0xa4, 0x47, 0x4c, 0x2c, 0x00, 0x00, 0x0d, 0x33, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x67, 0x6d, 0xd3, 0xa5, 0x5c, 0x4c, 0x3e, 0x83, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x79, 0x9f, 0x88, 0x81, 0x2b, 0x1e, 0x3d, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x69, 0x59, 0x02, 0x00, 0x5e, 0x74, 0x3f, 0x50, 0x59, 0xb7, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x05, 0xb2, 0x98, 0x41, 0x5d, 0x82, 0xb0, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x6f, 0x3e, 0x00, 0x00, 0x00, 0x3b, 0x30, 0x00, 0x00, 0x00, 0x04, 0x8a, 0x9b, 0x17, 0x00, 0x00, 0x00, 0x00},
  {0x91, 0xa9, 0x0f, 0x00, 0x00, 0x19, 0x78, 0x94, 0x1c, 0x00, 0x00, 0x09, 0x57, 0x68, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x43, 0x33, 0x00, 0x00, 0x00, 0x00, 0x06, 0x73, 0xa6, 0x63, 0x2d, 0x15, 0x1c},
  {0xca, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x8b, 0x32, 0x2b, 0x6a, 0x53, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x78, 0x69, 0x5f, 0x83},
  {0x7b, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xb1, 0x93, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3d},
  {0x65, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c},
  {0x65, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x51, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32},
  {0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x7c, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53},
  {0x75, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0xb2, 0xc1, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x8a},
  {0x1f, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x4c, 0x70, 0x6b, 0x8a, 0xb1, 0x95, 0x40, 0x00, 0x00, 0x1a, 0x51, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x5a, 0xa7, 0x8b},
  {0x1a, 0x00, 0x21, 0x24, 0x00, 0x00, 0x31, 0x71, 0x60, 0x20, 0x00, 0x00, 0x26, 0x80, 0xb3, 0x90, 0x4a, 0x5d, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6d, 0x91, 0x78, 0x4d, 0x3a},
  {0x1f, 0x18, 0x00, 0x21, 0x3c, 0x59, 0x6e, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x7f, 0xb8, 0x81, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x67, 0xa1, 0x74, 0x2a, 0x00, 0x00, 0x00},
  {0x00, 0x1e, 0x17, 0x11, 0x82, 0x72, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x7a, 0x65, 0x73, 0x64, 0x54, 0x45, 0x4a, 0x87, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x25, 0x60, 0x7b, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xb1, 0x8e, 0x8a, 0x8a, 0x95, 0xdc, 0xa9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x05, 0x99, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x7f, 0x09, 0x00, 0x04, 0x10, 0x66, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x8c, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x89, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x93, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x8d, 0x25, 0x0d, 0x0d, 0x0a, 0x02, 0x00},
  {0x11, 0x00, 0x36, 0xda, 0x97, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x95, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x91, 0x19, 0x15, 0x18, 0x1c, 0x1f},
  {0x3b, 0x7d, 0x97, 0x7a, 0x95, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x69, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x51, 0x00, 0x00, 0x00, 0x04, 0x16},
  {0x2b, 0xb9, 0x39, 0x00, 0x16, 0x8e, 0x78, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x75, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x8f, 0x8d, 0x0f, 0x00, 0x1a, 0x08, 0x24, 0x5a, 0x82, 0x81, 0x6b, 0x6c, 0x78, 0x79, 0xca, 0xd7, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x4d, 0x05, 0x00, 0x00, 0x00, 0x02},
  {0x95, 0x29, 0x00, 0x09, 0x05, 0x00, 0x00, 0x00, 0x27, 0x8f, 0xc3, 0xa3, 0x56, 0x3b, 0x4c, 0xb6, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x68, 0x1f, 0x33, 0x49, 0x67},
  {0x66, 0x49, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0b, 0x31, 0x1b, 0x00, 0x00, 0x00, 0x14, 0xb9, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xad, 0xbd, 0x6d, 0x70, 0x61, 0x44},
  {0x1a, 0x75, 0x55, 0x0a, 0x00, 0x00, 0x00, 0x05, 0x06, 0x00, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xba, 0x23, 0x00, 0x00, 0x00, 0x0e, 0x2e, 0x4b, 0xb6, 0xdd, 0x4c, 0x13, 0x03, 0x00, 0x00},
  {0x00, 0x40, 0xa5, 0x11, 0x00, 0x00, 0x01, 0x05, 0x00, 0x00, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a, 0xa2, 0x31, 0x42, 0x67, 0x79, 0x71, 0x5a, 0xa5, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x07, 0x93, 0x2e, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00, 0x04, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xd9, 0xad, 0x5a, 0x46, 0x24, 0x03, 0x00, 0x24, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x7c, 0x50, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x17, 0x15, 0x00, 0x00, 0x00, 0x05, 0x50, 0xc5, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x5a, 0x02, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x6b, 0x7f, 0x0b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x68, 0x2c, 0x27, 0x2b, 0x2d, 0x93, 0xbc, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x59, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x66, 0xaf, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x2e, 0x1a, 0x10, 0x12, 0x10, 0x07, 0x38, 0xaf, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xa7, 0x98, 0x3c, 0x24, 0x00, 0x00},
  {0x09, 0x00, 0x8a, 0xa9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa3, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x3e, 0x06, 0x26, 0x3f, 0x4b, 0x38},
  {0x49, 0x59, 0xc8, 0x79, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0xcb, 0xc8, 0x40, 0x26, 0x13, 0x07, 0x3a, 0x54, 0x00, 0x00, 0x00, 0x00, 0x18, 0x43},
  {0x0d, 0x76, 0xdd, 0x61, 0x00, 0x00, 0x00, 0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x5e, 0x9a, 0x93, 0x54, 0x54, 0x58, 0x5f, 0xcc, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x29, 0xc3, 0x81, 0x19, 0x00, 0x1e, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x64, 0x2d, 0x26, 0x46, 0x00, 0x00, 0x0d, 0x1c, 0x68, 0x89, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x62, 0x9b, 0x48, 0x53, 0x69, 0x65, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4b, 0x61, 0x1a, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x87, 0x22, 0x00, 0x00, 0x00, 0x00},
  {0x4f, 0xb2, 0x5a, 0x00, 0x19, 0x6a, 0x94, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x5f, 0x4b, 0x01, 0x00, 0x00, 0x18, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x75, 0x5e, 0x3e, 0x26, 0x21},
  {0x7e, 0x8b, 0x1b, 0x00, 0x00, 0x00, 0x4b, 0x7c, 0x20, 0x00, 0x01, 0x3e, 0x66, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x40, 0x5d, 0x5f, 0x57},
  {0x27, 0x53, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x44, 0x77, 0x4b, 0x52, 0x53, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05},
  {0x2c, 0x61, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x98, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x6d, 0x7d, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
  {0x64, 0x22, 0x2b, 0x28, 0x03, 0x00, 0x00, 0x00, 0x00, 0x45, 0x5e, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58},
  {0x08, 0x00, 0x00, 0x23, 0x30, 0x04, 0x00, 0x00, 0x1f, 0x4e, 0x24, 0x31, 0x36, 0x0b, 0x00, 0x00, 0x00, 0x44, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x71},
  {0x00, 0x00, 0x00, 0x00, 0x1f, 0x30, 0x0e, 0x2c, 0x62, 0x5b, 0x31, 0x2c, 0x51, 0x67, 0x40, 0x24, 0x2b, 0x59, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x82, 0xb2, 0x26},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x79, 0x58, 0x25, 0x09, 0x13, 0x21, 0x30, 0x72, 0xa4, 0x4c, 0x0f, 0x04, 0x22, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7c, 0x93, 0x78, 0x59, 0x27},
  {0x1d, 0x00, 0x00, 0x00, 0x00, 0x45, 0x7a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x58, 0x57, 0x00, 0x00, 0x00, 0x24, 0x1b, 0x00, 0x00, 0x00, 0x24, 0x82, 0x96, 0x66, 0x1b, 0x00, 0x00, 0x1d},
  {0x1a, 0x1d, 0x00, 0x00, 0x00, 0x61, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x41, 0x00, 0x00, 0x1f, 0x7d, 0x7d, 0x60, 0x60, 0x95, 0x81, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x1d, 0x1f, 0x00, 0x24, 0x69, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x66, 0x61, 0x56, 0x6f, 0x86, 0x8b, 0x91, 0xce, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x21, 0x27, 0x5f, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xbd, 0x63, 0x29, 0x07, 0x00, 0x00, 0x5c, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x5d, 0x92, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x5b, 0x92, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x83, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x72, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79, 0x61, 0x04, 0x02, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x36, 0x9c, 0xb2, 0x60, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xb2, 0x3d, 0x07, 0x0a, 0x0e, 0x0e},
  {0x39, 0x70, 0x73, 0x3f, 0x5a, 0x85, 0x74, 0x5f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x8d, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x75, 0x1f, 0x00, 0x02, 0x08, 0x10}
 },
 {
  {0x5b, 0x9f, 0xa1, 0x20, 0x00, 0x00, 0x00, 0x02, 0x2e, 0x74, 0xb4, 0xa5, 0x77, 0x7e, 0xd4, 0xaf, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7d, 0x14, 0x00, 0x20, 0x44},
  {0xed, 0xc6, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x9f, 0x57, 0x0a, 0x00, 0x1e, 0xb0, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x89, 0x7c, 0x55, 0x7d, 0xa9},
  {0x6f, 0x98, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xc6, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0xe8, 0x98, 0x4f, 0x3b, 0x27},
  {0x00, 0x86, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xc4, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4f, 0xda, 0x6c, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x65, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x27, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x92, 0x00, 0x00, 0x18, 0x3d, 0x57, 0x6c, 0xe1, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x40, 0x87, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x17, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xb8, 0x8c, 0x58, 0x6a, 0x69, 0x4c, 0x2f, 0x77, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x1f, 0x8b, 0x13, 0x00, 0x00, 0x01, 0x05, 0x01, 0x00, 0x12, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xc9, 0xb8, 0x30, 0x14, 0x00, 0x00, 0x00, 0x2d, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x08, 0x87, 0x2f, 0x00, 0x01, 0x07, 0x02, 0x00, 0x00, 0x13, 0x6c, 0x38, 0x21, 0x24, 0x28, 0x2a, 0x67, 0xd7, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xaa, 0x36, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x7e, 0x40, 0x00, 0x0d, 0x04, 0x00, 0x00, 0x03, 0x2c, 0x39, 0x25, 0x21, 0x26, 0x25, 0x1c, 0x2a, 0xa0, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x96, 0x5c, 0x3e, 0x2d, 0x0a, 0x00},
  {0x13, 0x02, 0x83, 0x58, 0x0b, 0x07, 0x00, 0x00, 0x04, 0x23, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xa4, 0x17, 0x00, 0x00, 0x00, 0x19, 0x59, 0x00, 0x00, 0x1a, 0x38, 0x49, 0x3f},
  {0x46, 0x74, 0xd7, 0x90, 0x0d, 0x00, 0x00, 0x06, 0x29, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0xb5, 0x53, 0x49, 0x3f, 0x4e, 0x98, 0x27, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x36},
  {0x03, 0x86, 0xeb, 0x91, 0x3c, 0x04, 0x04, 0x30, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0xa6, 0x48, 0x0e, 0x21, 0x31, 0x53, 0xb0, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x65, 0x79, 0x1a, 0x42, 0x60, 0x67, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x8a, 0x4a, 0x10, 0x00, 0x00, 0x00, 0x00, 0x33, 0x84, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x11, 0x90, 0x30, 0x00, 0x00, 0x38, 0x8e, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x57, 0x4f, 0x24, 0x02, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x59, 0x85, 0x33, 0x00, 0x00, 0x00, 0x00},
  {0x95, 0x91, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x66, 0x03, 0x00, 0x00, 0x00, 0x00, 0x33, 0x5d, 0x2f, 0x00, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x62, 0x64, 0x4c, 0x33, 0x31},
  {0x9a, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x45, 0x00, 0x00, 0x0d, 0x4f, 0x57, 0x13, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x4e, 0x54, 0x56},
  {0x3d, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x67, 0x44, 0x36, 0x58, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x4e, 0x97, 0x3c, 0x05, 0x00, 0x00, 0x00, 0x00, 0x52, 0xa3, 0x8e, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x13, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x80, 0x5c, 0x4b, 0x4c, 0x30, 0x03, 0x00, 0x0a, 0x52, 0x3b, 0x25, 0x37, 0x2b, 0x01, 0x00, 0x00, 0x00, 0x28, 0x3c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f},
  {0x33, 0x00, 0x00, 0x1e, 0x47, 0x49, 0x27, 0x47, 0x33, 0x00, 0x00, 0x00, 0x29, 0x38, 0x17, 0x0a, 0x1e, 0x6d, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x84},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x78, 0x73, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x60, 0x45, 0x20, 0x21, 0x39, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x91, 0x44},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x89, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x1f, 0x00, 0x00, 0x01, 0x31, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x47, 0x89, 0x72, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x93, 0x46, 0x1d, 0x0c, 0x00, 0x00, 0x00, 0x19, 0x06, 0x00, 0x00, 0x00, 0x0b, 0x34, 0x07, 0x00, 0x0b, 0x1f, 0x1e, 0x4e, 0x81, 0x66, 0x43, 0x48, 0x08},
  {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x62, 0x1a, 0x26, 0x33, 0x2e, 0x20, 0x31, 0x46, 0x02, 0x00, 0x00, 0x00, 0x00, 0x12, 0x3e, 0x26, 0x15, 0x13, 0x6f, 0xaa, 0x4b, 0x0a, 0x01, 0x1d, 0x2d},
  {0x25, 0x04, 0x00, 0x00, 0x00, 0x07, 0x67, 0x28, 0x00, 0x00, 0x04, 0x18, 0x22, 0x49, 0x7a, 0x22, 0x00, 0x00, 0x00, 0x00, 0x17, 0x93, 0x6a, 0x00, 0x03, 0x64, 0x28, 0x00, 0x00, 0x00, 0x00, 0x12},
  {0x12, 0x27, 0x04, 0x00, 0x00, 0x30, 0x66, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x61, 0x13, 0x08, 0x35, 0x60, 0x80, 0x9d, 0x88, 0x74, 0x7d, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x16, 0x2b, 0x00, 0x00, 0x5a, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x99, 0x85, 0x74, 0x5b, 0x30, 0x0d, 0x1c, 0x8a, 0xae, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1e, 0x26, 0x24, 0x67, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xaf, 0x4e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x36, 0x7e, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x8b, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x33, 0xc3, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x79, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x86, 0xd5, 0x8a, 0x5b, 0x38, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x94, 0x19, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x09, 0x83, 0xaa, 0x40, 0x22, 0x49, 0x6d, 0x73, 0x4f, 0x1a, 0x15, 0x2b, 0x47, 0xae, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x85, 0x10, 0x02, 0x00, 0x00}
 },
 {
  {0x3f, 0xa2, 0x9d, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x92, 0xa5, 0x46, 0x50, 0xae, 0x96, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x7e, 0x53, 0x16, 0x1b, 0x20},
  {0xf3, 0xa8, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x2c, 0x00, 0x00, 0x13, 0xb4, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0xf5, 0xbe, 0xa2, 0xb4},
  {0xa4, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x5d, 0x01, 0x00, 0x00, 0x00, 0x20, 0xca, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xb4, 0xa5, 0x4c, 0x32, 0x3d},
  {0x25, 0x7f, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0xc4, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xac, 0x8b, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x81, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x09, 0x30, 0xb0, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x6d, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0xa5, 0x47, 0x16, 0x37, 0x58, 0x5f, 0x7a, 0xc3, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x53, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3f, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0xc4, 0x5a, 0x4f, 0x41, 0x1d, 0x0b, 0x5a, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x38, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x59, 0x49, 0x18, 0x14, 0x13, 0x18, 0x20, 0x3d, 0xbf, 0xa6, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x65, 0x96, 0x28, 0x03, 0x00, 0x00, 0x00},
  {0x00, 0x21, 0x7c, 0x07, 0x00, 0x00, 0x03, 0x0c, 0x00, 0x14, 0x47, 0x3d, 0x28, 0x2d, 0x30, 0x31, 0x2d, 0x31, 0x8d, 0x86, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6c, 0x4d, 0x3d, 0x3d, 0x32, 0x15, 0x00},
  {0x1c, 0x40, 0x9a, 0x1c, 0x00, 0x02, 0x14, 0x00, 0x18, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0xb9, 0x4f, 0x2c, 0x1e, 0x28, 0x69, 0x27, 0x00, 0x00, 0x0e, 0x2c, 0x42, 0x3d},
  {0x49, 0xb3, 0xe0, 0x72, 0x4f, 0x47, 0x11, 0x1c, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x85, 0x72, 0x46, 0x36, 0x38, 0x76, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25},
  {0x05, 0xae, 0x90, 0x3d, 0x5f, 0x76, 0x6b, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7e, 0x46, 0x0a, 0x17, 0x00, 0x00, 0x12, 0x74, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x18, 0x86, 0x15, 0x00, 0x00, 0x1b, 0x87, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x68, 0x00, 0x00, 0x11, 0x02, 0x00, 0x00, 0x26, 0x84, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x66, 0x76, 0x00, 0x00, 0x00, 0x00, 0x18, 0x6e, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x86, 0x03, 0x00, 0x00, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x43, 0x70, 0x42, 0x0e, 0x00, 0x00, 0x00},
  {0xb4, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x95, 0x1c, 0x00, 0x00, 0x00, 0x0b, 0x07, 0x00, 0x00, 0x00, 0x00, 0x13, 0x4f, 0x60, 0x51, 0x3a, 0x61},
  {0x97, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x42, 0x00, 0x00, 0x1b, 0x4d, 0x54, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x38, 0x40, 0x7e},
  {0x68, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x8a, 0x7f, 0x7a, 0x87, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
  {0x9c, 0x74, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x84, 0x70, 0x5c, 0x5f, 0x30, 0x04, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
  {0x89, 0x61, 0x59, 0x48, 0x15, 0x00, 0x00, 0x02, 0x59, 0x33, 0x00, 0x00, 0x00, 0x2c, 0x60, 0x67, 0x33, 0x14, 0x14, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a},
  {0x09, 0x00, 0x16, 0x47, 0x5f, 0x3c, 0x0b, 0x41, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x52, 0x1f, 0x1e, 0x40, 0x5a, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x7a},
  {0x00, 0x00, 0x00, 0x00, 0x16, 0x4c, 0x7f, 0x7e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x16, 0x00, 0x00, 0x02, 0x2c, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x79, 0x9a, 0x10},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x18, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x26, 0x03, 0x1c, 0x18, 0x12, 0x20, 0x51, 0x5a, 0x62, 0x3c, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x18, 0x00, 0x00, 0x00, 0x00, 0x03, 0x54, 0x58, 0x2b, 0x1c, 0x33, 0x80, 0x55, 0x07, 0x00, 0x18, 0x01},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x95, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3d, 0x00, 0x00, 0x0a, 0x51, 0x00, 0x00, 0x00, 0x3a, 0x20},
  {0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x8d, 0x63, 0x2c, 0x27, 0x14, 0x02, 0x09, 0x30, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x1c, 0x00, 0x00, 0x3c, 0x49, 0x03, 0x00, 0x02, 0x11, 0x2e},
  {0x29, 0x11, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x61, 0x0c, 0x14, 0x2b, 0x34, 0x30, 0x59, 0x61, 0x00, 0x00, 0x00, 0x12, 0x40, 0x76, 0xbd, 0x8e, 0x3a, 0x48, 0x5e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x05},
  {0x06, 0x2b, 0x10, 0x00, 0x00, 0x00, 0x5a, 0x37, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x2b, 0x68, 0x4e, 0x39, 0x65, 0x83, 0x7b, 0x5d, 0x41, 0x51, 0x9a, 0xcf, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x0a, 0x33, 0x0b, 0x00, 0x1b, 0x5d, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xa7, 0x94, 0x5a, 0x2c, 0x01, 0x00, 0x00, 0x00, 0x11, 0x99, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x15, 0x36, 0x0f, 0x4e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x85, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x8d, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x3c, 0xa4, 0xba, 0x60, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x05, 0x8e, 0xcf, 0x82, 0x62, 0x67, 0x58, 0x2d, 0x00, 0x00, 0x00, 0x1b, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x95, 0x18, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x0e, 0x92, 0xaa, 0x2c, 0x00, 0x00, 0x1e, 0x46, 0x6c, 0x75, 0x6a, 0x5d, 0xa1, 0xbd, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x72, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x3c, 0xb3, 0x9f, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x71, 0x0f, 0x20, 0xa6, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x85, 0x54, 0x08, 0x06, 0x0a},
  {0xea, 0x93, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x36, 0x00, 0x00, 0x17, 0xc0, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0xc9, 0x9e, 0x94, 0xb5},
  {0xc2, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x66, 0x14, 0x00, 0x00, 0x00, 0x28, 0xd5, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x93, 0xc1, 0x6b, 0x50, 0x74},
  {0x5c, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0xcc, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d, 0xb0, 0x1d, 0x00, 0x00, 0x00},
  {0x2f, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xbf, 0x1e, 0x00, 0x00, 0x00, 0x00},
  {0x0b, 0x84, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xab, 0x30, 0x00, 0x00, 0x0b, 0x26, 0x6c, 0xca, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x79, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x95, 0x2f, 0x43, 0x5a, 0x57, 0x82, 0xa1, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x63, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x98, 0x16, 0x06, 0x01, 0x00, 0x04, 0x0e, 0x23, 0x9d, 0xdc, 0x61, 0x2e, 0x18, 0x00, 0x23, 0x91, 0x61, 0x2d, 0x0f, 0x00, 0x00, 0x00},
  {0x00, 0x6d, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x98, 0x6d, 0x32, 0x2e, 0x33, 0x35, 0x36, 0x39, 0x43, 0x8e, 0xd1, 0x5c, 0x0e, 0x00, 0x09, 0x56, 0x40, 0x1c, 0x33, 0x3c, 0x35, 0x20, 0x00},
  {0x48, 0x97, 0xb0, 0x33, 0x03, 0x00, 0x00, 0x2f, 0x80, 0x2b, 0x00, 0x00, 0x05, 0x0d, 0x10, 0x0c, 0x01, 0x0b, 0x70, 0x85, 0x5d, 0x3e, 0x34, 0x79, 0x76, 0x00, 0x00, 0x00, 0x02, 0x21, 0x3a, 0x47},
  {0x7c, 0x5a, 0x85, 0x9c, 0x6e, 0x68, 0x89, 0x9c, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x65, 0x0e, 0x28, 0x1c, 0x09, 0x47, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24},
  {0x2e, 0x3d, 0x34, 0x26, 0x32, 0x4c, 0x9d, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x88, 0x0f, 0x00, 0x0e, 0x1a, 0x00, 0x00, 0x61, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x4c, 0x50, 0x03, 0x00, 0x00, 0x00, 0x00, 0x69, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x99, 0x27, 0x00, 0x00, 0x02, 0x1a, 0x02, 0x00, 0x25, 0x7e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x84, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x70, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x92, 0x44, 0x00, 0x00, 0x00, 0x00, 0x16, 0x08, 0x00, 0x00, 0x22, 0x60, 0x4e, 0x20, 0x00, 0x00, 0x26},
  {0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x78, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x5a, 0x50, 0x55, 0xac},
  {0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x65, 0x60, 0x2b, 0x35, 0x86, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x20, 0x44, 0xab},
  {0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0xc6, 0x8f, 0x91, 0xe3, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55},
  {0xb7, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x74, 0x50, 0x15, 0x0c, 0x47, 0x8e, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6b},
  {0x8e, 0x6f, 0x62, 0x35, 0x00, 0x00, 0x00, 0x00, 0x62, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x66, 0x85, 0x2e, 0x22, 0x19, 0x1f, 0x36, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0xa2},
  {0x00, 0x09, 0x3e, 0x6d, 0x66, 0x25, 0x00, 0x3d, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x40, 0x11, 0x1c, 0x21, 0x41, 0x6e, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xa4, 0x50},
  {0x00, 0x00, 0x00, 0x02, 0x3f, 0x6b, 0x76, 0x89, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x22, 0x00, 0x00, 0x00, 0x00, 0x23, 0x49, 0x19, 0x0e, 0x09, 0x05, 0x00, 0x20, 0x55, 0x9f, 0x7d, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xae, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x92, 0x43, 0x22, 0x36, 0x7b, 0x83, 0x41, 0x23, 0x22, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x98, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x65, 0x08, 0x00, 0x0a, 0x69, 0x2e, 0x00, 0x00, 0x0c, 0x02},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x96, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x21, 0x0e},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x8f, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x10, 0x00, 0x00, 0x19, 0x3b, 0x00, 0x00, 0x00, 0x34, 0x39},
  {0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x8d, 0x1e, 0x08, 0x00, 0x00, 0x04, 0x32, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x64, 0xd0, 0x81, 0x0e, 0x0e, 0x6f, 0x3c, 0x02, 0x00, 0x00, 0x01, 0x26},
  {0x21, 0x22, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6b, 0x6e, 0x36, 0x3c, 0x38, 0x2a, 0x4d, 0x4a, 0x05, 0x17, 0x4e, 0x80, 0x8f, 0x88, 0x81, 0x89, 0x9a, 0xd0, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x26, 0x24, 0x00, 0x00, 0x00, 0x1c, 0x55, 0x09, 0x00, 0x0e, 0x21, 0x2e, 0x67, 0x92, 0x7e, 0x81, 0x81, 0x59, 0x22, 0x00, 0x00, 0x00, 0x36, 0xc9, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x35, 0x22, 0x00, 0x09, 0x69, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x97, 0x78, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x01, 0x5a, 0x86, 0xa5, 0xba, 0x7d, 0x3f, 0x16, 0x00, 0x00, 0x00, 0x2a, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x0d, 0xb1, 0xdf, 0x7d, 0x40, 0x3a, 0x53, 0x62, 0x50, 0x2d, 0x35, 0x87, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x9d, 0x1a, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x17, 0xa6, 0xb1, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x19, 0x6f, 0xa2, 0x7c, 0xb0, 0x98, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x7c, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x30, 0xa5, 0xa0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x60, 0x10, 0x35, 0x6e, 0x65, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x64, 0x15, 0x0b, 0x0f, 0x11},
  {0x70, 0x90, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x47, 0x00, 0x00, 0x33, 0x8d, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x06, 0x00, 0x00, 0x14},
  {0xbd, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 0x24, 0x00, 0x00, 0x00, 0x37, 0xac, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x87, 0x71, 0x55, 0x54, 0x87},
  {0x9a, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x5b, 0x06, 0x00, 0x00, 0x00, 0x00, 0x5e, 0xb1, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6b, 0x95, 0x73, 0x3e, 0x23, 0x43},
  {0x5d, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x6a, 0x65, 0x34, 0x01, 0x00, 0x00, 0x00},
  {0x3e, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0xa6, 0x2b, 0x00, 0x00, 0x00, 0x3a, 0x70, 0x3d, 0x09, 0x07, 0x00, 0x00, 0x00, 0x00},
  {0x21, 0x75, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x7a, 0x0a, 0x14, 0x4d, 0x62, 0x21, 0x00, 0x05, 0x0c, 0x00, 0x00, 0x00, 0x00},
  {0x1c, 0xab, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x8c, 0xc8, 0x6b, 0x6f, 0x54, 0x07, 0x00, 0x13, 0x55, 0x5f, 0x1b, 0x00, 0x00, 0x00},
  {0x38, 0x96, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0xa6, 0x36, 0x29, 0x2b, 0x2b, 0x2f, 0x39, 0x55, 0xb1, 0xbe, 0x81, 0x75, 0x56, 0x37, 0x44, 0x47, 0x31, 0x32, 0x35, 0x32, 0x32, 0x23},
  {0x0c, 0x09, 0x78, 0x86, 0x3a, 0x17, 0x06, 0x10, 0x6b, 0x6a, 0x0f, 0x0f, 0x19, 0x22, 0x23, 0x21, 0x19, 0x59, 0x7e, 0x38, 0x43, 0x45, 0x39, 0x7b, 0x7e, 0x06, 0x00, 0x00, 0x00, 0x12, 0x56, 0x55},
  {0x00, 0x00, 0x31, 0xa5, 0x8d, 0x7e, 0x85, 0xc0, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x7d, 0x2c, 0x00, 0x02, 0x2b, 0x05, 0x27, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x17},
  {0x00, 0x01, 0x36, 0x1e, 0x0a, 0x1f, 0x3a, 0x8f, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x80, 0x4e, 0x00, 0x00, 0x00, 0x1b, 0x16, 0x00, 0x56, 0x48, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0c},
  {0x00, 0x26, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x72, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x21, 0x00, 0x15, 0x5c, 0x40, 0x00, 0x00, 0x00, 0x06, 0x10},
  {0x0c, 0x36, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x6b, 0x06, 0x00, 0x00, 0x00, 0x48, 0x8a, 0x07, 0x00, 0x00, 0x00, 0x00, 0x05, 0x26, 0x06, 0x00, 0x06, 0x47, 0x4e, 0x2c, 0x18, 0x29, 0x01},
  {0x34, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x57, 0x00, 0x00, 0x2e, 0x92, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2d, 0x0e, 0x00, 0x00, 0x00, 0x21, 0x45, 0x7b, 0x6f, 0x11},
  {0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x9c, 0x85, 0xd2, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x69, 0x75},
  {0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x9a, 0x8e, 0x6e, 0xb6, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x99},
  {0x82, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x79, 0x4e, 0x00, 0x00, 0x12, 0x96, 0x59, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x19, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xbb},
  {0x87, 0x72, 0x57, 0x16, 0x00, 0x00, 0x00, 0x00, 0x62, 0x69, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x93, 0x35, 0x28, 0x25, 0x1c, 0x2d, 0x5d, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0xb7},
  {0x00, 0x29, 0x64, 0x7f, 0x56, 0x0a, 0x00, 0x35, 0x80, 0x09, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3c, 0x03, 0x10, 0x1d, 0x1f, 0x3e, 0x88, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x82, 0xa9, 0x1f},
  {0x00, 0x00, 0x00, 0x21, 0x66, 0x74, 0x5a, 0x8b, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x9b, 0x50, 0x27, 0x32, 0x49, 0x69, 0x68, 0x7d, 0x4b, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xcc, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x8c, 0x3c, 0x15, 0x24, 0x8c, 0x80, 0x0b, 0x00, 0x1a, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x36, 0x00, 0x00, 0x00, 0x24, 0x11, 0x00, 0x00, 0x11, 0x06},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0xa3, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x20, 0x00, 0x00, 0x00, 0x19, 0x01, 0x00, 0x00, 0x0b, 0x06},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x9e, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x0d, 0x00, 0x00, 0x0a, 0x22, 0x00, 0x00, 0x00, 0x2a, 0x23},
  {0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x41, 0xc0, 0x5c, 0x00, 0x00, 0x46, 0x33, 0x00, 0x00, 0x00, 0x23, 0x45},
  {0x2f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x85, 0x14, 0x00, 0x00, 0x00, 0x0e, 0x39, 0x00, 0x00, 0x2a, 0x63, 0x87, 0xa0, 0xb9, 0xac, 0x83, 0xa1, 0x8d, 0x19, 0x00, 0x00, 0x00, 0x00, 0x10},
  {0x0f, 0x30, 0x07, 0x00, 0x00, 0x00, 0x00, 0x30, 0x88, 0x57, 0x35, 0x29, 0x1d, 0x4f, 0x6e, 0x5c, 0x79, 0x90, 0x7b, 0x4b, 0x18, 0x00, 0x15, 0x5d, 0xef, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x17, 0x37, 0x04, 0x00, 0x00, 0x2d, 0x83, 0x82, 0x3e, 0x30, 0x37, 0x59, 0xa7, 0x9b, 0x6e, 0x4d, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x93, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x21, 0x58, 0x6f, 0x98, 0xaa, 0x92, 0x64, 0x4c, 0x39, 0x23, 0x4b, 0x7e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x20, 0xca, 0xe2, 0x88, 0x41, 0x0e, 0x06, 0x1b, 0x48, 0x7d, 0x73, 0x36, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x9f, 0x28, 0x00, 0x00, 0x00, 0x00},
  {0x07, 0x2f, 0xaf, 0xaf, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x78, 0x6f, 0x4b, 0x44, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x85, 0x16, 0x0a, 0x09, 0x07}
 },
 {
  {0x00, 0x3d, 0xa4, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x38, 0x07, 0x0e, 0x51, 0x08, 0x00, 0x16, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x49, 0x02, 0x00, 0x00, 0x00, 0x00},
  {0x23, 0x9e, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3f, 0x10, 0x00, 0x48, 0x4e, 0x00, 0x00, 0x24, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x31, 0x00, 0x00, 0x00, 0x00},
  {0x9d, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5b, 0x30, 0x00, 0x00, 0x39, 0x3b, 0x00, 0x07, 0x29, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x93, 0x7f, 0x40, 0x3f, 0x35, 0x42},
  {0xad, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x3d, 0x30, 0x00, 0x23, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x15, 0x71, 0x61, 0x27, 0x22, 0x2a, 0x2c, 0x6b},
  {0x85, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x51, 0x01, 0x00, 0x00, 0x00, 0x02, 0x4a, 0x19, 0x00, 0x31, 0x00, 0x00, 0x00, 0x30, 0x73, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
  {0x8a, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x47, 0x01, 0x29, 0x2e, 0x14, 0x4b, 0x6d, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
  {0x82, 0x85, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x4b, 0x4f, 0x7f, 0x7f, 0x61, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x11},
  {0x1f, 0x71, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x9f, 0x59, 0x33, 0x49, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x2f, 0x17},
  {0x00, 0x16, 0x63, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0xb3, 0x35, 0x1b, 0x19, 0x18, 0x1b, 0x2c, 0x97, 0xac, 0x23, 0x00, 0x00, 0x20, 0x02, 0x00, 0x00, 0x09, 0x1e, 0x40, 0x39, 0x0c, 0x00},
  {0x00, 0x00, 0x1e, 0x79, 0x86, 0x51, 0x31, 0x23, 0x47, 0x8c, 0x52, 0x29, 0x26, 0x2d, 0x2e, 0x2f, 0x56, 0xa3, 0x82, 0x4b, 0x3b, 0x28, 0x3a, 0x45, 0x1a, 0x25, 0x25, 0x22, 0x2e, 0x09, 0x00, 0x00},
  {0x00, 0x00, 0x09, 0x75, 0x8c, 0x82, 0x81, 0x96, 0xd1, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x6a, 0x14, 0x14, 0x30, 0x56, 0x72, 0x7b, 0x91, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x2f, 0x34, 0x00, 0x00, 0x09, 0x1f, 0x6f, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7f, 0x0e, 0x00, 0x00, 0x00, 0x06, 0x48, 0x47, 0x5e, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x14, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x64, 0x20, 0x00, 0x00, 0x00, 0x27, 0x8d, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x33, 0x00, 0x34, 0x46, 0x11, 0x00, 0x01, 0x00, 0x00},
  {0x01, 0x3c, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x66, 0x0a, 0x00, 0x16, 0x71, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x35, 0x00, 0x00, 0x28, 0x5f, 0x54, 0x00, 0x00, 0x00},
  {0x2b, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x77, 0x25, 0x2b, 0x4e, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x30, 0x00, 0x00, 0x00, 0x18, 0x6e, 0x32, 0x00, 0x00},
  {0x3d, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0xc5, 0x73, 0x6c, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x28, 0x00, 0x00, 0x00, 0x00, 0x13, 0x62, 0x1a, 0x0d},
  {0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x86, 0x76, 0x3e, 0x89, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x6a, 0x5f},
  {0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x66, 0x00, 0x00, 0x06, 0x91, 0x84, 0x1f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0xdb},
  {0x81, 0x6f, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x80, 0x00, 0x00, 0x00, 0x00, 0x34, 0x8e, 0x38, 0x29, 0x2b, 0x26, 0x20, 0x62, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0xaf, 0xb6},
  {0x0e, 0x4c, 0x80, 0x7d, 0x38, 0x00, 0x00, 0x2b, 0x90, 0x15, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3b, 0x00, 0x02, 0x10, 0x18, 0x1a, 0x5b, 0x96, 0x43, 0x1c, 0x1b, 0x0e, 0x20, 0x56, 0xa3, 0x83, 0x02},
  {0x00, 0x00, 0x02, 0x48, 0x80, 0x69, 0x3a, 0x89, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x87, 0x2f, 0x3a, 0x83, 0x9e, 0x4c, 0x38, 0x29, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x07, 0x54, 0xd7, 0xaf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x5e, 0x08, 0x00, 0x00, 0x4d, 0x50, 0x00, 0x00, 0x19, 0x02},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0xad, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x34, 0x00, 0x00, 0x00, 0x15, 0x0f, 0x00, 0x00, 0x14, 0x09},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0xa8, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x23, 0x00, 0x00, 0x00, 0x21, 0x09, 0x00, 0x00, 0x0e, 0x09},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0xa9, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0e, 0x00, 0x00, 0x08, 0x25, 0x00, 0x00, 0x00, 0x0d, 0x0b},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x90, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x20, 0x9d, 0x33, 0x00, 0x00, 0x24, 0x1a, 0x00, 0x00, 0x00, 0x25, 0x3d},
  {0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x75, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3b, 0x04, 0x00, 0x0a, 0x3b, 0x6b, 0xa2, 0xde, 0xb5, 0x64, 0x68, 0x74, 0x16, 0x00, 0x00, 0x00, 0x0f, 0x3c},
  {0x2b, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x8a, 0x40, 0x00, 0x00, 0x02, 0x44, 0x68, 0x46, 0x60, 0x88, 0x8d, 0x6e, 0x40, 0x20, 0x42, 0x81, 0xf6, 0xb2, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x02, 0x33, 0x20, 0x00, 0x00, 0x00, 0x21, 0x67, 0xb4, 0xae, 0x80, 0x70, 0x79, 0xac, 0xb6, 0x89, 0x6a, 0x3e, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x8f, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x16, 0x5d, 0x50, 0x60, 0x94, 0xa7, 0x8d, 0x5d, 0x59, 0x9c, 0xbb, 0x71, 0x49, 0x5b, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x36, 0x01, 0x01, 0x01, 0x00, 0x00},
  {0x08, 0x0e, 0x30, 0x9f, 0xdf, 0x9b, 0x4c, 0x11, 0x00, 0x00, 0x3a, 0x6f, 0x35, 0x00, 0x00, 0x28, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x3e, 0x00, 0x02, 0x03, 0x05, 0x06},
  {0x01, 0x00, 0x53, 0xa5, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x2d, 0x3a, 0x18, 0x00, 0x08, 0x32, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x4a, 0x00, 0x00, 0x00, 0x02, 0x03}
 },
 {
  {0x00, 0x08, 0x94, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x24, 0x00, 0x16, 0x48, 0x02, 0x00, 0x00, 0x08, 0x30, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x01, 0x7c, 0x93, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x24, 0x00, 0x00, 0x39, 0x24, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x6b, 0x15, 0x0c, 0x06, 0x00, 0x00},
  {0x89, 0xaf, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x23, 0x00, 0x00, 0x18, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x0b, 0x00, 0x00, 0x00, 0x13, 0x94, 0x92, 0x55, 0x54, 0x56, 0x4e, 0x47},
  {0xa7, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x22, 0x00, 0x00, 0x00, 0x55, 0x33, 0x00, 0x00, 0x00, 0x1b, 0x2a, 0x00, 0x00, 0x26, 0x76, 0x4f, 0x0d, 0x0c, 0x15, 0x20, 0x26, 0x34},
  {0x66, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x31, 0x00, 0x00, 0x00, 0x09, 0x4c, 0x17, 0x00, 0x00, 0x00, 0x35, 0x26, 0x42, 0x71, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x71, 0x93, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x5d, 0x05, 0x00, 0x00, 0x00, 0x13, 0x46, 0x00, 0x00, 0x00, 0x6c, 0xb4, 0x71, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x6e, 0x42, 0x3e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x5c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x43, 0x26, 0x52, 0x6e, 0x7b, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39},
  {0x29, 0x06, 0x0f, 0x3b, 0x10, 0x00, 0x00, 0x00, 0x00, 0x16, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xb8, 0x85, 0x39, 0x02, 0x03, 0x2f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x34, 0x34},
  {0x00, 0x0c, 0x00, 0x0c, 0x3b, 0x10, 0x00, 0x00, 0x00, 0x20, 0x8e, 0x2b, 0x04, 0x00, 0x09, 0x34, 0x7c, 0xab, 0x3d, 0x00, 0x00, 0x00, 0x1d, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3a, 0x1e, 0x00},
  {0x00, 0x04, 0x0b, 0x00, 0x2f, 0x9a, 0x77, 0x4c, 0x4d, 0x8e, 0x96, 0x43, 0x2e, 0x53, 0x73, 0x67, 0x3a, 0x2e, 0x41, 0x0f, 0x00, 0x00, 0x00, 0x2c, 0x0e, 0x00, 0x00, 0x2d, 0x36, 0x0b, 0x00, 0x00},
  {0x00, 0x00, 0x10, 0x51, 0x5c, 0x72, 0x7c, 0x73, 0x96, 0xbe, 0x2e, 0x00, 0x0e, 0x3f, 0x2f, 0x00, 0x00, 0x12, 0x6c, 0x5e, 0x3e, 0x21, 0x00, 0x11, 0x3c, 0x21, 0x36, 0x2b, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x26, 0x66, 0x1e, 0x00, 0x00, 0x00, 0x04, 0x56, 0x59, 0x0e, 0x01, 0x00, 0x00, 0x00, 0x06, 0x39, 0x25, 0x19, 0x32, 0x48, 0x51, 0x4d, 0x88, 0x97, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x04, 0x47, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x82, 0x39, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x36, 0x82, 0x64, 0x6f, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x34, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x38, 0x00, 0x00, 0x00, 0x18, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0d, 0x06, 0x5d, 0x2f, 0x00, 0x00, 0x00, 0x00},
  {0x19, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x40, 0x00, 0x00, 0x00, 0x2b, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x34, 0x09, 0x00, 0x15, 0x66, 0x1d, 0x00, 0x00, 0x00},
  {0x44, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x91, 0x1a, 0x00, 0x14, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x37, 0x03, 0x00, 0x00, 0x26, 0x64, 0x0c, 0x00, 0x00},
  {0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xa0, 0xae, 0x57, 0x55, 0x9d, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x32, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x54, 0x00, 0x24},
  {0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x82, 0x10, 0x08, 0x25, 0xa5, 0xb5, 0x35, 0x15, 0x09, 0x00, 0x00, 0x00, 0x33, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xa3, 0xa2},
  {0x89, 0x60, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x96, 0x05, 0x00, 0x00, 0x00, 0x21, 0x81, 0x38, 0x25, 0x2b, 0x2b, 0x28, 0x32, 0x7d, 0x48, 0x00, 0x00, 0x00, 0x00, 0x17, 0x91, 0xed, 0xb8},
  {0x2c, 0x6e, 0x8e, 0x6b, 0x19, 0x00, 0x00, 0x22, 0x9f, 0x23, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3c, 0x00, 0x00, 0x02, 0x0b, 0x11, 0x1a, 0x8b, 0xb6, 0x47, 0x3e, 0x59, 0x71, 0x70, 0x85, 0x5e, 0x08},
  {0x00, 0x00, 0x20, 0x6e, 0x8c, 0x53, 0x1d, 0x89, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x3a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x63, 0x18, 0x1c, 0x74, 0x99, 0x16, 0x06, 0x1c, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x25, 0x75, 0xd1, 0xb3, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x3d, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x53, 0x00, 0x00, 0x00, 0x15, 0x27, 0x00, 0x00, 0x19, 0x03},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x38, 0x00, 0x00, 0x00, 0x1b, 0x19, 0x00, 0x00, 0x15, 0x0a},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0xad, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x23, 0x00, 0x00, 0x00, 0x23, 0x11, 0x00, 0x00, 0x10, 0x0c},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0xb1, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x10, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x00, 0x0c, 0x0c},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x9c, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x26, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x79, 0x15, 0x00, 0x00, 0x27, 0x1e, 0x00, 0x00, 0x00, 0x0e, 0x17},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x00, 0x00, 0x15, 0x44, 0x92, 0xec, 0xaa, 0x47, 0x57, 0x92, 0x33, 0x08, 0x03, 0x01, 0x18, 0x4c},
  {0x49, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0xb9, 0x6a, 0x26, 0x09, 0x0f, 0x56, 0x82, 0x41, 0x41, 0x71, 0x8d, 0x85, 0x68, 0x53, 0x78, 0xcb, 0xbb, 0x57, 0x2e, 0x29, 0x21, 0x03, 0x06, 0x35},
  {0x4d, 0x5d, 0x33, 0x0c, 0x00, 0x00, 0x3a, 0x63, 0x54, 0x63, 0x83, 0x8f, 0x96, 0xb7, 0xba, 0xb7, 0x9c, 0x65, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x32, 0x62, 0x00, 0x00, 0x02, 0x07, 0x01, 0x00, 0x00},
  {0x00, 0x21, 0x48, 0x52, 0x68, 0x9f, 0x9b, 0x41, 0x01, 0x0a, 0x6d, 0xbd, 0x74, 0x34, 0x25, 0x4c, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x4b, 0xd3, 0xbe, 0x5a, 0x2b, 0x24, 0x42, 0x67, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x1b, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x15, 0x96, 0x77, 0x0c, 0x00, 0x00, 0x05, 0x42, 0x3c, 0x0b, 0x49, 0x20, 0x00, 0x00, 0x00, 0x2e, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x4f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x00, 0x00, 0x57, 0xb1, 0x35, 0x00, 0x0d, 0x16, 0x5f, 0x74, 0x00, 0x00, 0x1e, 0x52, 0x01, 0x00, 0x00, 0x00, 0x01, 0x35, 0x0e, 0x00, 0x00, 0x00, 0x4d, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x41, 0xb3, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x25, 0x3c, 0x00, 0x00, 0x00, 0x45, 0x28, 0x00, 0x00, 0x00, 0x00, 0x15, 0x31, 0x00, 0x00, 0x00, 0x00, 0x83, 0x5c, 0x2b, 0x23, 0x19, 0x0e, 0x04},
  {0x6d, 0xc7, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x39, 0x00, 0x00, 0x00, 0x1c, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x21, 0x00, 0x00, 0x28, 0x91, 0x77, 0x5c, 0x63, 0x66, 0x63, 0x57},
  {0x67, 0xc1, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x37, 0x00, 0x00, 0x00, 0x00, 0x44, 0x17, 0x00, 0x00, 0x00, 0x00, 0x13, 0x67, 0x41, 0x3c, 0x50, 0x1a, 0x00, 0x00, 0x06, 0x10, 0x1c, 0x23},
  {0x28, 0xad, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x35, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x04, 0xbb, 0xac, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x54, 0x56, 0x3d, 0x21, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3d, 0x0d, 0x00, 0x00, 0x00, 0x20, 0x65, 0x00, 0x00, 0x00, 0x0f, 0x6c, 0xc4, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x71, 0x00, 0x00, 0x37, 0x24, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x40, 0x48, 0x1a, 0x48, 0x72, 0x56, 0x35, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d},
  {0x46, 0x00, 0x00, 0x02, 0x37, 0x24, 0x00, 0x00, 0x00, 0x25, 0x46, 0x00, 0x00, 0x00, 0x00, 0x3d, 0xd3, 0xb1, 0x67, 0x24, 0x00, 0x00, 0x2f, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x5e},
  {0x09, 0x0e, 0x00, 0x00, 0x01, 0x37, 0x2b, 0x00, 0x00, 0x1c, 0xaa, 0x6f, 0x33, 0x44, 0x59, 0x6a, 0x84, 0x81, 0x0b, 0x00, 0x00, 0x00, 0x07, 0x3e, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x3f, 0x35, 0x06},
  {0x00, 0x0c, 0x05, 0x00, 0x00, 0x1d, 0xa6, 0x8f, 0x69, 0xb0, 0xda, 0x84, 0x56, 0x51, 0x36, 0x09, 0x00, 0x2f, 0x27, 0x00, 0x00, 0x00, 0x00, 0x20, 0x35, 0x00, 0x00, 0x22, 0x44, 0x21, 0x00, 0x00},
  {0x00, 0x02, 0x17, 0x2c, 0x3e, 0x57, 0x65, 0x5b, 0x5f, 0xc1, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x39, 0x32, 0x34, 0x3e, 0x0e, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x21, 0x86, 0x4c, 0x14, 0x00, 0x00, 0x00, 0x4a, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x7b, 0x3b, 0x1a, 0x00, 0x00, 0x1a, 0x85, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x45, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x69, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x3b, 0x26, 0x33, 0x48, 0x44, 0x18, 0x39, 0x86, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x23, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x73, 0x12, 0x00, 0x00, 0x00, 0x00, 0x09, 0x2f, 0x02, 0x00, 0x00, 0x01, 0x2d, 0x69, 0x91, 0x92, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x08, 0x4f, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x6d, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x5c, 0x3b, 0x61, 0x0d, 0x00, 0x00, 0x00, 0x00},
  {0x3d, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x46, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x22, 0x00, 0x3a, 0x5b, 0x01, 0x00, 0x00, 0x00},
  {0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xbf, 0xb3, 0x49, 0x35, 0x15, 0x3e, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x58, 0x21, 0x00, 0x00, 0x4d, 0x46, 0x00, 0x00, 0x10},
  {0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0xa9, 0x46, 0x39, 0x4d, 0x89, 0xca, 0x7b, 0x23, 0x1b, 0x06, 0x00, 0x00, 0x04, 0x3a, 0x20, 0x00, 0x00, 0x00, 0x66, 0x61, 0x40, 0x80},
  {0x92, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0xa8, 0x12, 0x00, 0x00, 0x00, 0x3e, 0x98, 0x36, 0x22, 0x34, 0x15, 0x00, 0x00, 0x00, 0x2d, 0x8a, 0x35, 0x1c, 0x26, 0x89, 0xe4, 0xdf, 0xcd},
  {0x4e, 0x87, 0x8c, 0x4e, 0x0c, 0x00, 0x00, 0x1e, 0xaa, 0x33, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3d, 0x00, 0x00, 0x00, 0x03, 0x01, 0x02, 0x27, 0x94, 0x84, 0x48, 0x79, 0xa9, 0x59, 0x5c, 0x6d, 0x2b},
  {0x00, 0x00, 0x46, 0x98, 0x88, 0x25, 0x2a, 0xac, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x3d, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x10, 0x98, 0x5c, 0x00, 0x00, 0x2e, 0x5f, 0x00, 0x00, 0x17, 0x00},
  {0x00, 0x00, 0x00, 0x08, 0x55, 0x1e, 0x29, 0xb7, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x28, 0x62, 0x00, 0x00, 0x00, 0x10, 0x21, 0x00, 0x00, 0x18, 0x04},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x4b, 0x89, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x44, 0x35, 0x00, 0x00, 0x00, 0x1c, 0x22, 0x00, 0x00, 0x16, 0x0b},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x90, 0xb7, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x21, 0x00, 0x00, 0x00, 0x22, 0x17, 0x00, 0x00, 0x0f, 0x0d},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xc2, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4d, 0x0f, 0x00, 0x00, 0x00, 0x25, 0x03, 0x00, 0x00, 0x0b, 0x0a},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa2, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x03, 0x60, 0x05, 0x00, 0x00, 0x4b, 0x47, 0x00, 0x00, 0x00, 0x07, 0x14},
  {0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0xb2, 0x1e, 0x00, 0x00, 0x00, 0x11, 0x5d, 0x1e, 0x00, 0x00, 0x00, 0x1a, 0x6f, 0xe4, 0x93, 0x3e, 0x61, 0x9b, 0x60, 0x20, 0x17, 0x14, 0x3f, 0x7a},
  {0x67, 0x32, 0x02, 0x00, 0x00, 0x00, 0x3e, 0x9a, 0xa7, 0x97, 0x76, 0x43, 0x36, 0x51, 0x83, 0x71, 0x44, 0x50, 0x79, 0x87, 0x85, 0x8b, 0xd0, 0xba, 0x52, 0x16, 0x0c, 0x15, 0x16, 0x16, 0x28, 0x5b},
  {0x1d, 0x4f, 0x51, 0x34, 0x1f, 0x5a, 0x78, 0x27, 0x00, 0x36, 0x89, 0x7c, 0x5c, 0x6e, 0x8b, 0xb3, 0xd0, 0xb4, 0x5e, 0x21, 0x00, 0x00, 0x1c, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x20, 0x51, 0x9c, 0x8a, 0x10, 0x00, 0x00, 0x00, 0x14, 0x9a, 0x82, 0x49, 0x2d, 0x1c, 0x38, 0x59, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x39, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x15, 0xb4, 0x61, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xae, 0x72, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x37, 0x02, 0x00, 0x00, 0x00, 0x20, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x6f, 0xb6, 0x56, 0x28, 0x22, 0x39, 0x6a, 0x50, 0x28, 0x5b, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x04, 0x5d, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x00, 0x00, 0x52, 0x3d, 0x03, 0x41, 0x32, 0x21, 0x4d, 0x72, 0x24, 0x00, 0x22, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x32, 0x00, 0x00, 0x15, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x0a, 0x3a, 0x64, 0x19, 0x0f, 0x24, 0x26, 0x4c, 0xa3, 0x2f, 0x00, 0x00, 0x00, 0x4a, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x2d, 0x00, 0x00, 0x00, 0x6e, 0x95, 0x40, 0x38, 0x2e, 0x22, 0x14},
  {0x68, 0xa8, 0x77, 0x1b, 0x07, 0x00, 0x00, 0x08, 0x50, 0x08, 0x00, 0x00, 0x00, 0x21, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x39, 0x00, 0x00, 0x1a, 0x89, 0x7f, 0x57, 0x5e, 0x65, 0x68, 0x60},
  {0x32, 0xb2, 0xac, 0x08, 0x00, 0x00, 0x00, 0x00, 0x39, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x49, 0x15, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x6e, 0x20, 0x32, 0x5b, 0x29, 0x00, 0x00, 0x00, 0x01, 0x0b, 0x15},
  {0x19, 0x75, 0x5e, 0x35, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x36, 0x37, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe4, 0xb2, 0x40, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x57, 0x2c, 0x00, 0x2a, 0x32, 0x00, 0x00, 0x00, 0x37, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x19, 0x40, 0x00, 0x00, 0x00, 0x32, 0x82, 0xb2, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x69, 0x00, 0x00, 0x00, 0x28, 0x33, 0x00, 0x00, 0x2a, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x43, 0x2c, 0x69, 0x7a, 0x38, 0x05, 0x3b, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35},
  {0x51, 0x00, 0x00, 0x00, 0x00, 0x28, 0x32, 0x00, 0x01, 0x49, 0x00, 0x00, 0x00, 0x24, 0x75, 0xe2, 0xe2, 0x96, 0x4f, 0x09, 0x00, 0x00, 0x15, 0x41, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x7b},
  {0x1d, 0x06, 0x00, 0x00, 0x00, 0x00, 0x26, 0x3c, 0x27, 0x98, 0xa6, 0x6d, 0x85, 0x94, 0x81, 0x4c, 0x6d, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x29, 0x00, 0x00, 0x00, 0x01, 0x34, 0x42, 0x24},
  {0x01, 0x12, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x94, 0xb7, 0xe4, 0xb3, 0x60, 0x47, 0x1d, 0x00, 0x00, 0x00, 0x41, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x08, 0x43, 0x09, 0x00, 0x11, 0x43, 0x35, 0x01, 0x00},
  {0x00, 0x08, 0x17, 0x04, 0x18, 0x42, 0x5c, 0x3f, 0x52, 0x97, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x48, 0x31, 0x46, 0x21, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x20, 0x7a, 0x60, 0x3c, 0x0e, 0x00, 0x00, 0x61, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x7c, 0x0e, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x36, 0x60, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x81, 0x3d, 0x0a, 0x00, 0x00, 0x00, 0x68, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x0e, 0x4d, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x40, 0x39, 0x3f, 0x30, 0x00, 0x00, 0x5f, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x45, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1c, 0x00, 0x00, 0x0a, 0x43, 0x5c, 0x68, 0x8d, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x70, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x08, 0x00, 0x00, 0x00, 0x0a, 0x56, 0xac, 0xa1, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x47, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xb7, 0x67, 0x1a, 0x03, 0x00, 0x00, 0x11, 0x50, 0x0e, 0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x50, 0x55, 0x26, 0x00, 0x00, 0x00, 0x00},
  {0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6b, 0xc9, 0x6e, 0x4f, 0x56, 0x52, 0x45, 0x8d, 0x79, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x46, 0x2b, 0x6d, 0x4c, 0x11, 0x0d, 0x53},
  {0x84, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xa8, 0x26, 0x00, 0x01, 0x1b, 0x61, 0xb5, 0x6e, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0xa1, 0x74, 0xae, 0xcb, 0xac, 0xb8, 0xcf},
  {0x65, 0x87, 0x7c, 0x47, 0x23, 0x17, 0x19, 0x3d, 0xab, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0d, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x4b, 0x74, 0x37, 0x50, 0x8b, 0x43, 0x63, 0x8f, 0x56},
  {0x00, 0x1a, 0x89, 0x7c, 0x0f, 0x0d, 0x18, 0xac, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x13, 0x00, 0x00, 0x02, 0x02, 0x1a, 0x70, 0x6e, 0x07, 0x00, 0x02, 0x2f, 0x00, 0x00, 0x17, 0x00},
  {0x00, 0x00, 0x00, 0x2b, 0x01, 0x00, 0x00, 0x6d, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x90, 0x00, 0x00, 0x00, 0x0f, 0x25, 0x00, 0x00, 0x14, 0x03},
  {0x00, 0x00, 0x00, 0x0a, 0x29, 0x01, 0x00, 0x5d, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x43, 0x30, 0x00, 0x00, 0x00, 0x17, 0x23, 0x00, 0x00, 0x14, 0x0b},
  {0x00, 0x00, 0x00, 0x00, 0x16, 0x25, 0x1e, 0x80, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x41, 0x06, 0x00, 0x00, 0x00, 0x00, 0x49, 0x1a, 0x00, 0x00, 0x00, 0x1a, 0x1a, 0x00, 0x00, 0x0d, 0x0b},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x70, 0xb6, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x45, 0x00, 0x00, 0x00, 0x00, 0x06, 0x4b, 0x0c, 0x00, 0x00, 0x00, 0x2b, 0x02, 0x00, 0x00, 0x05, 0x06},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xc3, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x5d, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x05, 0x51, 0x01, 0x00, 0x06, 0x64, 0x82, 0x13, 0x07, 0x05, 0x2b, 0x42},
  {0x43, 0x01, 0x00, 0x00, 0x00, 0x00, 0x32, 0xcc, 0xc5, 0x63, 0x32, 0x2a, 0x30, 0x32, 0x35, 0x39, 0x1b, 0x00, 0x00, 0x00, 0x3d, 0xbc, 0x7c, 0x4a, 0x61, 0x70, 0x44, 0x21, 0x15, 0x15, 0x3c, 0x79},
  {0x4a, 0x4f, 0x2a, 0x00, 0x00, 0x3e, 0x84, 0x57, 0x56, 0x9c, 0x8a, 0x36, 0x10, 0x00, 0x00, 0x00, 0x4e, 0x66, 0x5c, 0x69, 0x84, 0xd1, 0xc3, 0x51, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f},
  {0x00, 0x20, 0x46, 0x56, 0x82, 0x94, 0x2c, 0x00, 0x00, 0x0c, 0x60, 0x3d, 0x00, 0x1a, 0x46, 0x67, 0x89, 0xcc, 0xc0, 0x54, 0x16, 0x1a, 0x55, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x57, 0xc2, 0x33, 0x00, 0x00, 0x00, 0x00, 0x06, 0x83, 0x8d, 0x6f, 0x62, 0x4a, 0x2b, 0x29, 0x52, 0x1b, 0x00, 0x00, 0x39, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x52, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0xc2, 0xbb, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x09, 0x00, 0x2c, 0x76, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x15, 0x67, 0x43, 0x0c, 0x00, 0x00, 0x00, 0x1f, 0x67, 0x64, 0x70, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x5a, 0x1a, 0x00, 0x17, 0x5a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x00, 0x3e, 0x59, 0x00, 0x00, 0x10, 0x0b, 0x00, 0x00, 0x55, 0x5c, 0x09, 0x27, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x53, 0x15, 0x00, 0x00, 0x00, 0x57, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3a, 0x71, 0x16, 0x00, 0x00, 0x00, 0x12, 0x39, 0x76, 0x52, 0x00, 0x00, 0x00, 0x4c, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x21, 0x00, 0x00, 0x00, 0x4d, 0xb9, 0x56, 0x46, 0x40, 0x33, 0x23},
  {0xa4, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xa8, 0x82, 0x00, 0x00, 0x00, 0x00, 0x25, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x2e, 0x00, 0x00, 0x0c, 0x79, 0x7d, 0x4c, 0x51, 0x5b, 0x5f, 0x5e},
  {0x46, 0x9f, 0x51, 0x17, 0x08, 0x07, 0x0e, 0x68, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x11, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x6f, 0x0d, 0x2a, 0x5e, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
  {0x27, 0x93, 0x61, 0x4c, 0x6e, 0x30, 0x00, 0x29, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x33, 0x00, 0x00, 0x00, 0x00, 0x4b, 0xf4, 0xaf, 0x55, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x5c, 0x30, 0x00, 0x03, 0x30, 0x44, 0x07, 0x19, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x3f, 0x00, 0x00, 0x0a, 0x54, 0x87, 0x86, 0x88, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x60, 0x00, 0x00, 0x00, 0x00, 0x11, 0x32, 0x3a, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x90, 0x54, 0x48, 0x79, 0x6c, 0x19, 0x00, 0x27, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b},
  {0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x5c, 0x83, 0x26, 0x00, 0x00, 0x08, 0x32, 0x83, 0xec, 0xe3, 0x80, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x44, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x84},
  {0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xcd, 0xd2, 0x76, 0x75, 0x8c, 0x92, 0x74, 0x44, 0x6e, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x42, 0x00, 0x00, 0x00, 0x00, 0x22, 0x45, 0x4b},
  {0x0c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0xb6, 0xc8, 0x88, 0x53, 0x3a, 0x10, 0x00, 0x00, 0x07, 0x49, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x26, 0x00, 0x01, 0x37, 0x40, 0x11, 0x00},
  {0x00, 0x11, 0x10, 0x00, 0x00, 0x21, 0x49, 0x5b, 0x5b, 0x52, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x4c, 0x35, 0x43, 0x31, 0x00, 0x00, 0x00},
  {0x00, 0x01, 0x21, 0x55, 0x58, 0x51, 0x33, 0x01, 0x1c, 0x61, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x50, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x98, 0x28, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x27, 0x81, 0x33, 0x00, 0x00, 0x00, 0x05, 0x6e, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x47, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x4f, 0x07, 0x00, 0x00, 0x00, 0x4b, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x30, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa2, 0x76, 0x5d, 0x34, 0x11, 0x5d, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x13, 0x4a, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x50, 0x1e, 0x29, 0x49, 0x61, 0x86, 0xac, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3e, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x88, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0xce, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xb6, 0x54, 0x43, 0x37, 0x14, 0x00, 0x3a, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0xed, 0x4f, 0x0a, 0x00, 0x00, 0x27},
  {0x6e, 0x05, 0x00, 0x15, 0x1a, 0x18, 0x0d, 0x00, 0x2e, 0xa4, 0x45, 0x17, 0x2a, 0x42, 0x5f, 0x84, 0xa5, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x77, 0xe1, 0xdf, 0x9a, 0x82, 0x87, 0xb2},
  {0x73, 0x90, 0x6a, 0x31, 0x23, 0x24, 0x26, 0x59, 0xbf, 0x55, 0x00, 0x00, 0x00, 0x00, 0x12, 0x8e, 0x64, 0x0f, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x65, 0x3c, 0x25, 0x79, 0x5e, 0x77, 0xa4, 0x79},
  {0x00, 0x65, 0x67, 0x00, 0x00, 0x00, 0x00, 0x56, 0xb8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x18, 0x00, 0x08, 0x07, 0x03, 0x00, 0x2a, 0x6f, 0x2b, 0x00, 0x00, 0x26, 0x00, 0x00, 0x20, 0x00},
  {0x00, 0x00, 0x2c, 0x08, 0x00, 0x00, 0x00, 0x23, 0x76, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x1b, 0x00, 0x00, 0x04, 0x08, 0x50, 0x8a, 0x1e, 0x00, 0x00, 0x09, 0x23, 0x00, 0x00, 0x0e, 0x01},
  {0x00, 0x00, 0x12, 0x31, 0x00, 0x00, 0x00, 0x32, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x19, 0x00, 0x00, 0x00, 0x00, 0x68, 0x43, 0x00, 0x00, 0x00, 0x10, 0x21, 0x00, 0x00, 0x10, 0x0a},
  {0x00, 0x00, 0x00, 0x21, 0x31, 0x00, 0x00, 0x42, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x66, 0x17, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x11, 0x00, 0x00, 0x00, 0x10, 0x18, 0x00, 0x00, 0x08, 0x06},
  {0x00, 0x00, 0x00, 0x00, 0x25, 0x33, 0x1d, 0x74, 0x52, 0x00, 0x00, 0x00, 0x04, 0x17, 0x30, 0x4c, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x42, 0x06, 0x00, 0x00, 0x00, 0x56, 0x21, 0x00, 0x00, 0x13, 0x16},
  {0x11, 0x00, 0x00, 0x00, 0x00, 0x11, 0x78, 0xf3, 0x90, 0x1e, 0x1b, 0x22, 0x24, 0x1e, 0x07, 0x00, 0x19, 0x20, 0x00, 0x00, 0x0a, 0x4f, 0x09, 0x00, 0x23, 0x64, 0x7d, 0x2e, 0x0f, 0x0e, 0x40, 0x68},
  {0x51, 0x2b, 0x00, 0x00, 0x00, 0x1b, 0x93, 0xbd, 0xb3, 0x7b, 0x2d, 0x13, 0x06, 0x00, 0x00, 0x00, 0x00, 0x12, 0x1c, 0x00, 0x1e, 0x9c, 0x7a, 0x4d, 0x56, 0x3c, 0x06, 0x03, 0x07, 0x08, 0x10, 0x37},
  {0x11, 0x3e, 0x42, 0x28, 0x46, 0x8d, 0x4b, 0x00, 0x1e, 0x6f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x5b, 0x97, 0xbd, 0x5f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1c, 0x7b, 0xc4, 0x46, 0x00, 0x00, 0x00, 0x0a, 0x6a, 0x44, 0x00, 0x00, 0x18, 0x3e, 0x5c, 0x6d, 0x87, 0xac, 0x88, 0x78, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x7b, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x7a, 0x72, 0x67, 0x76, 0x73, 0x5e, 0x44, 0x37, 0x56, 0x6a, 0x71, 0x64, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1f, 0x7b, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0xe9, 0x58, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7d, 0x30, 0x15, 0x4e, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x02, 0x61, 0x34, 0x09, 0x10, 0x00, 0x00, 0x00, 0x00, 0x44, 0x94, 0x9c, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x57, 0x0b, 0x00, 0x00, 0x4b, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x19, 0x6f, 0x10, 0x00, 0x00, 0x0f, 0x0e, 0x00, 0x00, 0x22, 0x6e, 0x3d, 0x3b, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x57, 0x08, 0x00, 0x00, 0x00, 0x47, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x86, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1b, 0x4b, 0x79, 0x27, 0x00, 0x00, 0x4c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x02, 0x53, 0x13, 0x00, 0x00, 0x00, 0x28, 0xc3, 0x6f, 0x50, 0x4e, 0x3f, 0x43},
  {0xb0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xaf, 0x1d, 0x00, 0x00, 0x00, 0x27, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x21, 0x00, 0x00, 0x01, 0x69, 0x78, 0x3f, 0x40, 0x4c, 0x4f, 0x77},
  {0x6a, 0x6f, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x53, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x02, 0x48, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x45, 0x71, 0x01, 0x1f, 0x5e, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
  {0x49, 0xb5, 0x5e, 0x47, 0x3a, 0x16, 0x03, 0x69, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x7b, 0xf1, 0xaa, 0x6c, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x62, 0x46, 0x17, 0x2d, 0x47, 0x49, 0x72, 0xbe, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x46, 0x00, 0x00, 0x25, 0x70, 0x7e, 0x5b, 0x8a, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x5b, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3c, 0xd7, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xb6, 0x72, 0x63, 0x7c, 0x52, 0x01, 0x00, 0x0b, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28},
  {0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xd0, 0x2f, 0x00, 0x09, 0x22, 0x46, 0x72, 0xa0, 0xc4, 0x72, 0x10, 0x00, 0x00, 0x00, 0x00, 0x35, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b},
  {0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xdb, 0xcc, 0x76, 0x69, 0x71, 0x64, 0x30, 0x1e, 0x6b, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0x0f, 0x00, 0x00, 0x00, 0x10, 0x43, 0x6f},
  {0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x5d, 0x73, 0x81, 0x3d, 0x1d, 0x08, 0x00, 0x00, 0x2b, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x3f, 0x00, 0x00, 0x26, 0x43, 0x22, 0x00},
  {0x02, 0x17, 0x05, 0x00, 0x00, 0x01, 0x4e, 0x64, 0x00, 0x17, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x3b, 0x3c, 0x0b, 0x00, 0x00},
  {0x00, 0x07, 0x21, 0x29, 0x39, 0x52, 0x78, 0x2d, 0x00, 0x14, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x53, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x99, 0x52, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1f, 0x86, 0x53, 0x1f, 0x07, 0x08, 0x00, 0x14, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x7a, 0x13, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x38, 0x37, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x34, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x59, 0x22, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x19, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x33, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xaf, 0x61, 0x40, 0x15, 0x00, 0x3b, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x03, 0x44, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x46, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x62, 0x48, 0x48, 0x61, 0x6b, 0x5e, 0x7f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x2c, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x43, 0x70, 0x2d, 0x0e, 0x04, 0x00, 0x00, 0x00, 0x2d, 0x56, 0x03, 0x00, 0x00, 0x00, 0x15, 0x50, 0xc6, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x72, 0x2b, 0x11, 0x14, 0x18, 0x15, 0x0b, 0x23, 0x5e, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xd3, 0x35, 0x00, 0x00, 0x00, 0x09},
  {0x5e, 0x18, 0x2e, 0x33, 0x33, 0x32, 0x2b, 0x32, 0x79, 0x54, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x2b, 0x8a, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0xe5, 0xce, 0x79, 0x57, 0x4f, 0x83},
  {0x99, 0x81, 0x34, 0x19, 0x0e, 0x11, 0x1a, 0x53, 0xc9, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x8f, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x53, 0x3f, 0x8a, 0x7c, 0x80, 0xa2, 0x91},
  {0x3c, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x63, 0x28, 0x07, 0x00, 0x00, 0x00, 0x00, 0x53, 0x4b, 0x00, 0x00, 0x26, 0x01, 0x03, 0x31, 0x04},
  {0x00, 0x32, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x47, 0x00, 0x0a, 0x0d, 0x0b, 0x18, 0x60, 0x42, 0x00, 0x00, 0x02, 0x1e, 0x00, 0x00, 0x0a, 0x00},
  {0x00, 0x12, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x72, 0x29, 0x00, 0x00, 0x00, 0x00, 0x13, 0x3d, 0x36, 0x03, 0x00, 0x04, 0x13, 0x79, 0x58, 0x00, 0x00, 0x00, 0x06, 0x1b, 0x00, 0x00, 0x0b, 0x08},
  {0x00, 0x00, 0x27, 0x36, 0x00, 0x00, 0x00, 0x0b, 0x7c, 0x1d, 0x00, 0x04, 0x0f, 0x16, 0x13, 0x00, 0x08, 0x1d, 0x06, 0x00, 0x00, 0x4e, 0x10, 0x00, 0x00, 0x00, 0x17, 0x26, 0x00, 0x00, 0x08, 0x07},
  {0x00, 0x00, 0x00, 0x31, 0x39, 0x02, 0x00, 0x4d, 0xa7, 0x36, 0x13, 0x17, 0x13, 0x07, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x06, 0x07, 0x38, 0x00, 0x00, 0x00, 0x11, 0x6d, 0x4c, 0x0a, 0x08, 0x38, 0x42},
  {0x39, 0x08, 0x00, 0x00, 0x29, 0x5d, 0x91, 0xf2, 0xab, 0x1c, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0x37, 0x5d, 0x19, 0x15, 0x3a, 0x57, 0x41, 0x14, 0x09, 0x08, 0x20, 0x4a},
  {0x2c, 0x3d, 0x23, 0x00, 0x1d, 0xa2, 0xb8, 0x94, 0x8a, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0xb7, 0x76, 0x43, 0x3c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x0f, 0x35, 0x65, 0xa6, 0x62, 0x00, 0x00, 0x1d, 0x79, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0xab, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x00, 0x9c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x7c, 0x4c, 0x00, 0x00, 0x00, 0x0f, 0x31, 0x4b, 0x56, 0x71, 0xb9, 0xac, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x20, 0x91, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x7f, 0x54, 0x42, 0x69, 0x7e, 0x7b, 0x6b, 0x58, 0x7b, 0xc6, 0x82, 0x4e, 0x4c, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x04, 0x65, 0x43, 0x1a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xf2, 0x89, 0x4b, 0x27, 0x08, 0x00, 0x00, 0x16, 0x68, 0x04, 0x00, 0x3b, 0x63, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x48, 0x59, 0x00, 0x05, 0x14, 0x00, 0x00, 0x00, 0x00, 0x10, 0x99, 0xd8, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x51, 0x00, 0x00, 0x00, 0x2d, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x65, 0x3d, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x4d, 0x6b, 0x63, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x52, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6d, 0x11, 0x00, 0x00, 0x00, 0x00},
  {0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x16, 0x1e, 0x67, 0x5a, 0x00, 0x00, 0x49, 0x16, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x52, 0x05, 0x00, 0x00, 0x00, 0x07, 0xb2, 0x87, 0x53, 0x51, 0x49, 0x83},
  {0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xa3, 0x6c, 0x00, 0x00, 0x00, 0x28, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x11, 0x00, 0x00, 0x00, 0x58, 0x71, 0x2f, 0x2b, 0x36, 0x41, 0x9c},
  {0x78, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x7c, 0x06, 0x00, 0x00, 0x00, 0x04, 0x43, 0x09, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x6f, 0x00, 0x13, 0x58, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16},
  {0x76, 0xa5, 0x3d, 0x28, 0x0e, 0x00, 0x00, 0x34, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x22, 0x00, 0x00, 0x00, 0x0b, 0x9f, 0xdb, 0x9e, 0x80, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x71, 0x6e, 0x3b, 0x4b, 0x56, 0x47, 0x2f, 0x75, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6d, 0x00, 0x00, 0x41, 0x7c, 0x66, 0x37, 0x76, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x58, 0x00, 0x00, 0x00, 0x0f, 0x2c, 0x4c, 0xcc, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x15, 0x6e, 0xbb, 0x93, 0x86, 0x72, 0x2f, 0x00, 0x00, 0x00, 0x3d, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29},
  {0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xee, 0x62, 0x2c, 0x39, 0x4c, 0x57, 0x45, 0x2c, 0x85, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67},
  {0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xc0, 0xaf, 0x61, 0x41, 0x2c, 0x09, 0x00, 0x00, 0x22, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x28, 0x00, 0x00, 0x00, 0x01, 0x3b, 0x81},
  {0x1d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x11, 0x5e, 0x22, 0x41, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x45, 0x07, 0x00, 0x13, 0x3c, 0x31, 0x1b},
  {0x0b, 0x16, 0x00, 0x00, 0x00, 0x05, 0x60, 0x2e, 0x00, 0x0b, 0x4c, 0x1d, 0x02, 0x03, 0x03, 0x02, 0x1f, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x4b, 0x34, 0x3f, 0x1b, 0x00, 0x00},
  {0x00, 0x10, 0x1c, 0x04, 0x1e, 0x69, 0x41, 0x00, 0x00, 0x00, 0x4a, 0x39, 0x02, 0x01, 0x01, 0x00, 0x00, 0x29, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b, 0x76, 0x08, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1d, 0x6a, 0x7a, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x3c, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x23, 0x57, 0x17, 0x03, 0x00, 0x00, 0x00, 0x00, 0x2b, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x09, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x07, 0x3e, 0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2b, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0x92, 0x41, 0x1d, 0x00, 0x00, 0x15, 0x5d, 0x11, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x31, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x51, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x6e, 0x6b, 0x5c, 0x67, 0x62, 0x39, 0x43, 0x59, 0x04, 0x00, 0x00, 0x00, 0x00},
  {0x15, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x60, 0x4d, 0x1a, 0x15, 0x0c, 0x00, 0x00, 0x19, 0x56, 0x13, 0x00, 0x00, 0x0a, 0x33, 0x5c, 0xa7, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x39, 0x20, 0x08, 0x1e, 0x25, 0x25, 0x3c, 0x1e, 0x00, 0x3f, 0x25, 0x00, 0x05, 0x11, 0x19, 0x1b, 0x32, 0x62, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0xab, 0x31, 0x00, 0x00, 0x00, 0x00},
  {0x6d, 0x53, 0x42, 0x38, 0x31, 0x33, 0x57, 0x8c, 0x7f, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x73, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x9c, 0x81, 0x5b, 0x2e, 0x1b, 0x4b},
  {0x9f, 0x3b, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x50, 0xb8, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x5c, 0x60, 0x80, 0x89, 0x7b, 0x86, 0xa7},
  {0x63, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x64, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x53, 0x1b, 0x00, 0x36, 0x1c, 0x17, 0x45, 0x4a},
  {0x31, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x4e, 0x00, 0x00, 0x07, 0x1a, 0x28, 0x2e, 0x55, 0x8f, 0x54, 0x04, 0x00, 0x00, 0x2c, 0x53, 0x10, 0x00, 0x00, 0x15, 0x00, 0x00, 0x05, 0x00},
  {0x09, 0x45, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x8a, 0x1b, 0x24, 0x32, 0x2e, 0x20, 0x0c, 0x00, 0x0e, 0x60, 0x57, 0x25, 0x44, 0x5b, 0x0a, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x07, 0x00},
  {0x00, 0x26, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x92, 0x1d, 0x15, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x62, 0x7f, 0x17, 0x00, 0x00, 0x00, 0x28, 0x52, 0x0a, 0x04, 0x2d, 0x26},
  {0x1e, 0x00, 0x3b, 0x36, 0x00, 0x00, 0x00, 0x4d, 0xa1, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x6d, 0x00, 0x00, 0x01, 0x2c, 0x52, 0x2f, 0x0b, 0x07, 0x24, 0x43},
  {0x31, 0x2d, 0x1c, 0x45, 0x54, 0x62, 0x95, 0xfa, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x99, 0x58, 0x2a, 0x3c, 0x3c, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x0a},
  {0x00, 0x1f, 0x35, 0x50, 0xb8, 0xca, 0x91, 0x89, 0x8f, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x8d, 0x9d, 0x39, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x09, 0x96, 0xa9, 0x18, 0x00, 0x00, 0x22, 0x84, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x08, 0x33, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1c, 0x9c, 0x48, 0x00, 0x00, 0x00, 0x00, 0x11, 0x86, 0x52, 0x00, 0x00, 0x00, 0x00, 0x05, 0x20, 0x4c, 0x2c, 0x00, 0x63, 0x8d, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x02, 0x61, 0x5e, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x88, 0x3f, 0x15, 0x41, 0x67, 0x77, 0x7c, 0x89, 0x7b, 0x7d, 0x83, 0x68, 0x5f, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x47, 0x5a, 0x02, 0x16, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0xd7, 0x98, 0x6b, 0x53, 0x31, 0x15, 0x09, 0x5f, 0xa3, 0x0d, 0x00, 0x1f, 0x64, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1c, 0x70, 0x0f, 0x00, 0x08, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0xff, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x51, 0x00, 0x00, 0x00, 0x0e, 0x67, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x61, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x11, 0x00, 0x00, 0x00, 0x19, 0x71, 0x92, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x44, 0x00, 0x00, 0x00, 0x00, 0x09, 0x6f, 0x32, 0x06, 0x00, 0x00, 0x3f},
  {0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x15, 0x07, 0x33, 0x6c, 0x26, 0x00, 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x92, 0x4c, 0x49, 0x66, 0x9f},
  {0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x6b, 0x94, 0x1b, 0x00, 0x00, 0x26, 0x33, 0x00, 0x00, 0x00, 0x00, 0x06, 0x48, 0x00, 0x00, 0x00, 0x00, 0x43, 0x66, 0x20, 0x17, 0x1e, 0x43, 0x94},
  {0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x45, 0x00, 0x00, 0x00, 0x06, 0x39, 0x02, 0x00, 0x00, 0x00, 0x00, 0x70, 0x64, 0x00, 0x08, 0x4a, 0x59, 0x06, 0x00, 0x00, 0x00, 0x00, 0x44},
  {0x8a, 0x5b, 0x14, 0x00, 0x00, 0x00, 0x00, 0x01, 0x54, 0x13, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1f, 0x00, 0x00, 0x00, 0x26, 0xab, 0xb8, 0x8a, 0x87, 0x4c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b},
  {0x88, 0x83, 0x44, 0x4b, 0x43, 0x27, 0x03, 0x19, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x96, 0x27, 0x1d, 0x54, 0x74, 0x43, 0x1d, 0x55, 0x72, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
  {0x56, 0x01, 0x02, 0x1a, 0x37, 0x48, 0x48, 0x88, 0x9c, 0x12, 0x00, 0x09, 0x21, 0x41, 0x69, 0x74, 0x8b, 0x9e, 0x61, 0x10, 0x00, 0x00, 0x00, 0x29, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29},
  {0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x9c, 0xf5, 0x81, 0x42, 0x43, 0x44, 0x31, 0x05, 0x00, 0x31, 0x65, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x41, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51},
  {0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x82, 0x70, 0x24, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x05, 0x38, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x39, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x79},
  {0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x40, 0x00, 0x37, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x1e, 0x00, 0x03, 0x2c, 0x3c, 0x38},
  {0x15, 0x0e, 0x00, 0x00, 0x00, 0x31, 0x55, 0x05, 0x00, 0x16, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x5e, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x47, 0x31, 0x38, 0x26, 0x00, 0x00},
  {0x00, 0x17, 0x11, 0x00, 0x34, 0x59, 0x0c, 0x00, 0x00, 0x00, 0x3d, 0x3c, 0x08, 0x02, 0x03, 0x02, 0x0c, 0x56, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x84, 0x1a, 0x00, 0x00, 0x00},
  {0x00, 0x01, 0x24, 0x6a, 0x66, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x5d, 0x12, 0x02, 0x02, 0x01, 0x00, 0x08, 0x52, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x58, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x1e, 0x86, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x39, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x38, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x61, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x55, 0x2c, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x16, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x73, 0x2c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x6f, 0x7d, 0x5c, 0x59, 0x48, 0x23, 0x36, 0x81, 0x37, 0x00, 0x00, 0x00, 0x00},
  {0x02, 0x34, 0x07, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x42, 0x1e, 0x17, 0x1a, 0x11, 0x00, 0x09, 0x4b, 0x24, 0x00, 0x06, 0x24, 0x4c, 0x82, 0x66, 0x43, 0x4c, 0x16, 0x00, 0x00, 0x00},
  {0x33, 0x5c, 0x3c, 0x43, 0x67, 0x61, 0x2d, 0x00, 0x00, 0x36, 0x2c, 0x00, 0x00, 0x00, 0x0d, 0x19, 0x35, 0x69, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x37, 0x00, 0x18, 0x46, 0x1c, 0x00, 0x00},
  {0x88, 0x65, 0x34, 0x1e, 0x1b, 0x37, 0x59, 0x65, 0x5c, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x6c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x23, 0x00, 0x00, 0x14, 0x40, 0x20, 0x31},
  {0x6a, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0xb1, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x45, 0x00, 0x00, 0x00, 0x18, 0x70, 0xad},
  {0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7e, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x3a, 0x95, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x54, 0x59, 0x24, 0x17, 0x1a, 0x2d, 0x69, 0x93},
  {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x3e, 0x00, 0x00, 0x0f, 0x21, 0x2d, 0x2e, 0x34, 0x55, 0x72, 0x30, 0x00, 0x00, 0x04, 0x40, 0x32, 0x07, 0x16, 0x4b, 0x37, 0x13, 0x1e, 0x47},
  {0x50, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x86, 0x23, 0x2c, 0x30, 0x29, 0x19, 0x04, 0x00, 0x00, 0x1e, 0x5a, 0x4e, 0x33, 0x4b, 0x28, 0x00, 0x00, 0x00, 0x47, 0x22, 0x00, 0x21, 0x35},
  {0x5b, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x7d, 0x1b, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9a, 0x50, 0x00, 0x00, 0x01, 0x31, 0x34, 0x0d, 0x06, 0x1c, 0x37},
  {0x3e, 0x85, 0x51, 0x00, 0x00, 0x00, 0x00, 0x63, 0x93, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x60, 0x00, 0x16, 0x32, 0x27, 0x00, 0x00, 0x00, 0x00, 0x0c},
  {0x01, 0x3f, 0x91, 0x6b, 0x40, 0x5e, 0xa0, 0xf9, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x52, 0x94, 0x5f, 0x2a, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x2d, 0xbd, 0xe3, 0x9c, 0x7f, 0x7d, 0x8c, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x1b, 0x03, 0x5c, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x12, 0x9b, 0x75, 0x00, 0x00, 0x00, 0x23, 0x86, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x1b, 0x00, 0x00, 0x2f, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x55, 0x6c, 0x19, 0x00, 0x00, 0x00, 0x00, 0x12, 0x88, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x00, 0x00, 0x00, 0x7c, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x3d, 0x59, 0x17, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x8a, 0x36, 0x00, 0x12, 0x38, 0x59, 0x91, 0x67, 0x05, 0x11, 0x56, 0x7e, 0x76, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x1a, 0x6a, 0x12, 0x00, 0x17, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0xae, 0x80, 0x6e, 0x69, 0x56, 0x48, 0x4a, 0x7a, 0x97, 0x41, 0x00, 0x02, 0x4e, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x5f, 0x39, 0x00, 0x00, 0x07, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0xf4, 0x9d, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x76, 0x00, 0x00, 0x00, 0x00, 0x55, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}
 },
 {
  {0x1f, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x13, 0x00, 0x00, 0x00, 0x00, 0x50, 0xc0, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x5a, 0x14, 0x0c, 0x26, 0x6f},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x15, 0x05, 0x07, 0x58, 0x54, 0x1c, 0x3e, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x22, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x98, 0x46, 0x47, 0x9b, 0x76},
  {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x3a, 0x8e, 0x58, 0x00, 0x00, 0x26, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x12, 0x45, 0x00, 0x00, 0x00, 0x00, 0x31, 0x65, 0x17, 0x06, 0x0e, 0x58, 0x75},
  {0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7a, 0x00, 0x00, 0x00, 0x07, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x5a, 0x00, 0x01, 0x3e, 0x60, 0x11, 0x00, 0x00, 0x00, 0x00, 0x69},
  {0x7a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x37, 0x00, 0x00, 0x00, 0x00, 0x47, 0x3e, 0x00, 0x00, 0x00, 0x46, 0xaf, 0xa2, 0x7c, 0x8f, 0x60, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f},
  {0xa5, 0x78, 0x3d, 0x36, 0x1d, 0x00, 0x00, 0x00, 0x5f, 0x32, 0x00, 0x00, 0x00, 0x1e, 0x81, 0x97, 0x54, 0x4e, 0x68, 0x64, 0x25, 0x0f, 0x3d, 0x78, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16},
  {0x67, 0x25, 0x25, 0x3e, 0x4d, 0x4c, 0x3e, 0x38, 0x7b, 0x72, 0x2c, 0x2d, 0x3d, 0x44, 0x2e, 0x23, 0x5a, 0xa4, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b},
  {0x24, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x5b, 0xa0, 0xa5, 0x86, 0x3d, 0x2a, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x47, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48},
  {0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x7a, 0x6d, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x3f, 0x09, 0x00, 0x00, 0x00, 0x23, 0x69},
  {0x0c, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x55, 0x13, 0x00, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x33, 0x00, 0x00, 0x1c, 0x48, 0x50},
  {0x1c, 0x04, 0x00, 0x00, 0x09, 0x56, 0x29, 0x00, 0x00, 0x23, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x36, 0x2f, 0x2d, 0x09, 0x02},
  {0x07, 0x1c, 0x04, 0x12, 0x57, 0x30, 0x00, 0x00, 0x00, 0x00, 0x42, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x81, 0x3c, 0x00, 0x00, 0x00},
  {0x00, 0x0a, 0x50, 0x75, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x52, 0x16, 0x02, 0x03, 0x04, 0x05, 0x3b, 0x61, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x62, 0x0a, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x5c, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x46, 0x03, 0x03, 0x02, 0x00, 0x00, 0x40, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x5a, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x05, 0x4b, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x5a, 0x31, 0x01, 0x00, 0x00, 0x01, 0x25, 0x6f, 0x76, 0x0a, 0x00, 0x00, 0x00},
  {0x00, 0x28, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x64, 0x57, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x70, 0x85, 0x51, 0x4d, 0x48, 0x4c, 0x3e, 0x25, 0x37, 0x45, 0x08, 0x00, 0x00},
  {0x09, 0x65, 0x63, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x38, 0x09, 0x10, 0x1a, 0x1e, 0x16, 0x0c, 0x3e, 0x37, 0x14, 0x1f, 0x50, 0x87, 0x37, 0x00, 0x00, 0x00, 0x29, 0x44, 0x0e, 0x00},
  {0x4a, 0x5a, 0x67, 0x66, 0x52, 0x44, 0x17, 0x00, 0x00, 0x2f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x20, 0x6a, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x23, 0x47, 0x36},
  {0x4d, 0x31, 0x1e, 0x17, 0x25, 0x46, 0x5e, 0x4f, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x28, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x7a},
  {0x3d, 0x09, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x77, 0xae, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x22, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x60},
  {0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x8b, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x29, 0x7f, 0x77, 0x05, 0x00, 0x00, 0x00, 0x21, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x69},
  {0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x35, 0x00, 0x05, 0x17, 0x29, 0x32, 0x30, 0x29, 0x22, 0x4f, 0x5a, 0x1f, 0x00, 0x00, 0x3b, 0x21, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x5a, 0x91},
  {0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x84, 0x27, 0x30, 0x30, 0x26, 0x11, 0x00, 0x00, 0x00, 0x00, 0x2a, 0x54, 0x43, 0x47, 0x54, 0x1e, 0x15, 0x30, 0x42, 0x4d, 0x4e, 0x6a, 0xb0},
  {0xaa, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xaa, 0x6b, 0x16, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5b, 0xa3, 0x2f, 0x00, 0x3e, 0x5f, 0x45, 0x2d, 0x15, 0x06, 0x48},
  {0x56, 0xa4, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x3a, 0x8e, 0x6c, 0x2f, 0x21, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x57, 0x98, 0x56, 0x44, 0x6d, 0xb5, 0xff, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x2d, 0x16, 0x2b, 0x86, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x5a, 0xe3, 0xd5, 0x95, 0x77, 0x78, 0x92, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x2e, 0x09, 0x00, 0x00, 0x53, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x00, 0x4d, 0x97, 0x52, 0x00, 0x00, 0x00, 0x26, 0x8e, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x2d, 0x03, 0x00, 0x00, 0x00, 0x4a, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x35, 0x5c, 0x2d, 0x12, 0x00, 0x00, 0x00, 0x00, 0x13, 0x90, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x00, 0x0b, 0x92, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x17, 0x6a, 0x18, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x92, 0x37, 0x00, 0x00, 0x0c, 0x4e, 0x66, 0x00, 0x00, 0x00, 0x19, 0x66, 0x97, 0x73, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x5e, 0x3c, 0x00, 0x00, 0x17, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x99, 0x5b, 0x5c, 0x6b, 0x85, 0x81, 0x47, 0x2b, 0x4d, 0x60, 0x2e, 0x00, 0x31, 0x62, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x60, 0x00, 0x00, 0x00, 0x06, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd5, 0xc6, 0x45, 0x20, 0x02, 0x05, 0x2f, 0x98, 0x9f, 0x0d, 0x00, 0x00, 0x00, 0x35, 0x53, 0x00, 0x00, 0x00, 0x00, 0x37}
 },
 {
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x15, 0x00, 0x00, 0x00, 0x00, 0x18, 0xd6, 0xab, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4b, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x84, 0x25, 0x26, 0x72, 0x4d},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x0b, 0x00, 0x28, 0x70, 0x57, 0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x98, 0x41, 0x64, 0xa9, 0x28},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x23, 0x6d, 0x8c, 0x22, 0x00, 0x27, 0x23, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x45, 0x00, 0x00, 0x00, 0x00, 0x22, 0x69, 0x16, 0x00, 0x09, 0x72, 0x49},
  {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x9a, 0x3e, 0x00, 0x00, 0x06, 0x3f, 0x06, 0x00, 0x00, 0x00, 0x1a, 0xa8, 0x50, 0x04, 0x00, 0x33, 0x69, 0x1f, 0x00, 0x00, 0x00, 0x2c, 0x79},
  {0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x19, 0x3f, 0x06, 0x00, 0x00, 0x04, 0x89, 0x65, 0x22, 0x1c, 0x28, 0x72, 0xb7, 0x93, 0x75, 0x97, 0x7d, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85},
  {0x61, 0x2d, 0x30, 0x20, 0x00, 0x00, 0x05, 0x11, 0x03, 0x17, 0x3d, 0x19, 0x24, 0x49, 0x6e, 0x55, 0x20, 0x18, 0x2f, 0x5d, 0x1a, 0x06, 0x2b, 0x6f, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59},
  {0x01, 0x00, 0x19, 0x3a, 0x52, 0x50, 0x22, 0x00, 0x00, 0x2d, 0x8e, 0x49, 0x2c, 0x16, 0x00, 0x0d, 0x06, 0x00, 0x0b, 0x19, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x08, 0x36},
  {0x00, 0x00, 0x00, 0x00, 0x2a, 0x71, 0x4e, 0x0e, 0x2c, 0x74, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x17, 0x2d, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x11, 0x30},
  {0x01, 0x00, 0x00, 0x00, 0x00, 0x11, 0x92, 0x6e, 0x90, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x21, 0x00, 0x00, 0x00, 0x28, 0x56},
  {0x05, 0x00, 0x00, 0x00, 0x00, 0x40, 0x5c, 0x1e, 0x26, 0x59, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x3e, 0x06, 0x00, 0x0b, 0x57, 0x69},
  {0x1a, 0x00, 0x00, 0x00, 0x38, 0x4f, 0x00, 0x00, 0x00, 0x2f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x41, 0x27, 0x30, 0x1f, 0x1c},
  {0x14, 0x18, 0x0b, 0x40, 0x4f, 0x05, 0x00, 0x00, 0x00, 0x01, 0x4d, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x44, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x60, 0x08, 0x00, 0x00},
  {0x00, 0x30, 0x7a, 0x4f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x65, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x83, 0x3e, 0x00, 0x00, 0x00},
  {0x00, 0x2a, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x3a, 0x00, 0x03, 0x06, 0x06, 0x20, 0x6e, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x56, 0x82, 0x53, 0x00, 0x00, 0x00},
  {0x00, 0x55, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0xa4, 0x4d, 0x0d, 0x00, 0x00, 0x00, 0x21, 0x55, 0x0c, 0x00, 0x00, 0x2a, 0x51, 0x4d, 0x25, 0x0d, 0x3f, 0x3c, 0x00, 0x00},
  {0x33, 0x75, 0x49, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x6b, 0x3b, 0x24, 0x16, 0x02, 0x00, 0x00, 0x6e, 0x7e, 0x59, 0x5f, 0x50, 0x27, 0x00, 0x00, 0x00, 0x00, 0x39, 0x41, 0x0f},
  {0x5d, 0x17, 0x16, 0x25, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x3f, 0x00, 0x00, 0x0b, 0x1e, 0x23, 0x22, 0x3b, 0x4d, 0x39, 0x6e, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80},
  {0x26, 0x00, 0x00, 0x05, 0x2d, 0x33, 0x11, 0x00, 0x00, 0x2a, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x49, 0x70, 0x03, 0x00, 0x05, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x80},
  {0x0e, 0x00, 0x05, 0x06, 0x13, 0x3b, 0x54, 0x39, 0x3b, 0x50, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x3f, 0x00, 0x00, 0x00, 0x1c, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x60},
  {0x0b, 0x04, 0x0e, 0x05, 0x00, 0x00, 0x17, 0x64, 0x99, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x66, 0x00, 0x00, 0x00, 0x1f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x61},
  {0x15, 0x0b, 0x01, 0x00, 0x00, 0x00, 0x00, 0x24, 0x86, 0x16, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1d, 0x2e, 0x57, 0x89, 0x47, 0x00, 0x00, 0x23, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x5d},
  {0x1b, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x7b, 0x30, 0x00, 0x0e, 0x21, 0x31, 0x37, 0x34, 0x25, 0x0c, 0x13, 0x4e, 0x4a, 0x41, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x55},
  {0x22, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x99, 0x87, 0x2d, 0x35, 0x32, 0x22, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x90, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1a, 0x76, 0x71},
  {0x64, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xb8, 0x5c, 0x11, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0xc3, 0x59, 0x09, 0x18, 0x32, 0x4b, 0x57, 0x59, 0x72, 0x85},
  {0x7c, 0x80, 0x16, 0x00, 0x00, 0x00, 0x0a, 0x93, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2e, 0x3f, 0x6e, 0xb8, 0x95, 0x60, 0x51, 0x44, 0x2a, 0x10, 0x00, 0x27},
  {0x15, 0x7b, 0x8c, 0x4e, 0x55, 0x86, 0xca, 0xff, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x3c, 0x2b, 0x00, 0x00, 0x56, 0x9a, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x12, 0xa1, 0xe7, 0xd0, 0x9b, 0x70, 0x7b, 0xa1, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3d, 0x1c, 0x00, 0x00, 0x00, 0x18, 0x5e, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x00, 0x2a, 0x72, 0x75, 0x46, 0x00, 0x00, 0x00, 0x2b, 0x9e, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x20, 0x00, 0x00, 0x00, 0x00, 0x17, 0x5e, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x14, 0x6c, 0x22, 0x0a, 0x16, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x61, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x90, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x61, 0x45, 0x00, 0x00, 0x1f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1b, 0xa3, 0x3c, 0x00, 0x00, 0x00, 0x48, 0x24, 0x00, 0x00, 0x00, 0x00, 0x27, 0x8d, 0xb2, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x66, 0x00, 0x00, 0x00, 0x17, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x98, 0x35, 0x35, 0x6e, 0xb4, 0x59, 0x0f, 0x00, 0x0b, 0x53, 0x5c, 0x29, 0x1c, 0x69, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x3d},
  {0x1c, 0x00, 0x00, 0x00, 0x05, 0x1a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb3, 0xda, 0x68, 0x51, 0x4e, 0x3a, 0x16, 0x39, 0x91, 0x56, 0x00, 0x00, 0x00, 0x13, 0x66, 0x0e, 0x00, 0x00, 0x10, 0x6f}
 },
 {
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf, 0xe8, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x51, 0x00, 0x00, 0x00, 0x00, 0x50, 0x4c, 0x00, 0x00, 0x47, 0x52},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1e, 0x14, 0x0d, 0x20, 0x64, 0x9f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x59, 0xab, 0x3d, 0x54, 0xa2, 0x2d},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x5e, 0x51, 0x54, 0x6c, 0x0f, 0x36, 0x4b, 0x0f, 0x15, 0x2a, 0x25, 0x34, 0x73, 0x05, 0x00, 0x00, 0x00, 0x11, 0x6e, 0x47, 0x37, 0x4f, 0x79, 0x39},
  {0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x22, 0x0d, 0x06, 0x0a, 0x00, 0x2b, 0x56, 0x23, 0x2a, 0x44, 0x57, 0x83, 0xd3, 0x70, 0x0f, 0x00, 0x24, 0x67, 0x2e, 0x00, 0x00, 0x00, 0x12, 0x76},
  {0x54, 0x35, 0x26, 0x08, 0x00, 0x00, 0x0e, 0x0b, 0x00, 0x00, 0x00, 0x19, 0x3f, 0x42, 0x04, 0x00, 0x02, 0x02, 0x01, 0x08, 0x5a, 0xb6, 0x7c, 0x89, 0x90, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x04, 0x63},
  {0x00, 0x18, 0x31, 0x3c, 0x45, 0x2f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x72, 0x7f, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x32, 0x21, 0x4f, 0x60, 0x00, 0x00, 0x00, 0x00, 0x06, 0x3b, 0x18},
  {0x00, 0x00, 0x00, 0x0a, 0x54, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x6d, 0x0d, 0x04, 0x11, 0x03, 0x00, 0x00, 0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x26, 0x2a, 0x00, 0x00, 0x00, 0x1a, 0x49, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x35, 0x75, 0x0b, 0x00, 0x00, 0x04, 0x0d, 0x03, 0x00, 0x00, 0x11, 0x1e, 0x00, 0x00, 0x00, 0x03, 0x3c, 0x0f, 0x00, 0x00, 0x22, 0x37, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x76, 0x40, 0x6c, 0xa0, 0x26, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0c, 0x00, 0x00, 0x1f, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x00, 0x00, 0x28, 0x31, 0x00},
  {0x00, 0x00, 0x00, 0x00, 0x05, 0x84, 0x9a, 0x55, 0x74, 0x8b, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0e, 0x23, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x1d, 0x00, 0x37, 0x36, 0x00},
  {0x00, 0x00, 0x00, 0x16, 0x75, 0x5e, 0x06, 0x00, 0x00, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x60, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x3a, 0x23, 0x5a, 0x56, 0x07},
  {0x19, 0x02, 0x33, 0x7a, 0x48, 0x00, 0x00, 0x00, 0x00, 0x05, 0x54, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x9d, 0x3b, 0x23, 0x29},
  {0x2d, 0x75, 0x81, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x52, 0x6a, 0x80, 0x3e, 0x00, 0x02},
  {0x25, 0x9b, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x57, 0x00, 0x00, 0x00, 0x27, 0x56, 0x58, 0x2f, 0x01, 0x08, 0x47, 0x33, 0x00},
  {0x66, 0x52, 0x2f, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x9d, 0x54, 0x31, 0x22, 0x11, 0x2f, 0x99, 0x8e, 0x4f, 0x4f, 0x5d, 0x59, 0x33, 0x01, 0x00, 0x00, 0x00, 0x04, 0x4b, 0x61},
  {0x56, 0x00, 0x0e, 0x27, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x81, 0x57, 0x53, 0x5f, 0x5e, 0x69, 0x40, 0x16, 0x32, 0x8c, 0x61, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x96},
  {0x2a, 0x00, 0x00, 0x01, 0x1b, 0x22, 0x13, 0x00, 0x00, 0x00, 0x2d, 0x4a, 0x00, 0x00, 0x00, 0x07, 0x4e, 0x5f, 0x00, 0x00, 0x00, 0x2a, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x72},
  {0x23, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x20, 0x20, 0x0e, 0x2b, 0x50, 0x03, 0x00, 0x00, 0x00, 0x00, 0x13, 0x38, 0x00, 0x00, 0x00, 0x21, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x75},
  {0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x51, 0x7f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x2d, 0x00, 0x00, 0x00, 0x26, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x78},
  {0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x64, 0x1b, 0x00, 0x00, 0x24, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x75},
  {0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x45, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x25, 0x44, 0x8a, 0x75, 0x1c, 0x00, 0x2b, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x71},
  {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x60, 0x19, 0x14, 0x2a, 0x36, 0x39, 0x30, 0x1f, 0x0f, 0x39, 0x58, 0x5e, 0x65, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x68},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0xa2, 0x5e, 0x30, 0x2d, 0x1a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x5e, 0xb0, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x5c},
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x81, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xbb, 0xd2, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x8b, 0x71},
  {0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x84, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x47, 0x46, 0x81, 0xbb, 0x75, 0x2d, 0x35, 0x4c, 0x58, 0x5b, 0x78, 0x87},
  {0x6f, 0x47, 0x10, 0x0d, 0x29, 0x57, 0x83, 0xce, 0x8f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x45, 0x0d, 0x00, 0x00, 0x37, 0xc4, 0xa9, 0x56, 0x3f, 0x28, 0x0d, 0x00, 0x2c},
  {0x1d, 0x8c, 0xa8, 0xa3, 0xb9, 0x9f, 0x8a, 0x95, 0xa7, 0x5f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x0f, 0x81, 0x7c, 0x81, 0x74, 0x0e, 0x00, 0x00, 0x32, 0xa4, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
  {0x60, 0x49, 0x00, 0x08, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x19, 0xa9, 0x65, 0x00, 0x00, 0x00, 0x00, 0x36, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06},
  {0x70, 0x00, 0x00, 0x00, 0x1d, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xab, 0x3f, 0x00, 0x00, 0x21, 0x82, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0xb7, 0x9c, 0x19, 0x02, 0x01, 0x01, 0x05, 0x63},
  {0x38, 0x00, 0x00, 0x00, 0x17, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x99, 0x18, 0x21, 0x8a, 0x81, 0x2a, 0x11, 0x10, 0x03, 0x1b, 0x5c, 0x5e, 0x32, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x76},
  {0x08, 0x00, 0x00, 0x00, 0x04, 0x1a, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c, 0xc8, 0x9d, 0x4d, 0x00, 0x02, 0x0b, 0x14, 0x5a, 0x9d, 0x3f, 0x00, 0x00, 0x05, 0x69, 0x0a, 0x00, 0x00, 0x0d, 0x5c}
 }
};
uint8_t GIFframe = 0U;  // текущий кадр анимации (не важно, какой в начале)
uint8_t GIFshiftx = 0U; // какой-то там сдвиг текстуры по радиусу лампы
uint8_t GIFshifty = 0U; // какой-то там сдвиг текстуры по высоте

#define CAUSTICS_BR                     (100U)                // яркость бликов в процентах (от чистого белого света)

void waterpoolRoutine()
{
  if (modes[EFF_WATERPOLL].Speed != 255U) // если регулятор скорости на максимуме, то будет работать старый эффект "цвет" (без анимации бликов воды)
  {
    if (GIFframe > 24U) // количество кадров в анимации -1 (отсчёт с нуля)
      GIFframe = 0U;
    if (GIFframe > 0U && GIFframe < 3U) // пару раз за цикл анимации двигаем текстуру по радиусу лампы. а может и не двигаем. как повезёт
    {
      if (random(2U) == 0U)
      {
        GIFshiftx++;
        if (GIFshiftx > 31U) GIFshiftx = 0U;
      }
    }
    if (GIFframe > 11U && GIFframe < 14U) // пару раз за цикл анимации двигаем текстуру по вертикали. а может и не двигаем. как повезёт
    {
      if (random(2U) == 0U)
      {
        GIFshifty++;
        if (GIFshifty > 31U) GIFshifty = 0U;
      }
    }
      
    for(uint8_t x = 0U; x < WIDTH ; x++) {
      for (uint8_t y = 0U; y < HEIGHT; y++) {
        // y%32, x%32 - это для масштабирования эффекта на лампы размером большим, чем размер анимации 32х32, а также для произвольного сдвига текстуры
        leds[getPixelNumber(x, y)] = CHSV(modes[EFF_WATERPOLL].Scale * 2.55, 255U - pgm_read_byte(&aquariumGIF[GIFframe][(y+GIFshifty)%32U][(x+GIFshiftx)%32U]) * CAUSTICS_BR / 100U, 255U);
        // чтобы регулятор Масштаб начал вместо цвета регулировать яркость бликов, нужно закомментировать предыдущую строчку и раскоментировать следующую
        //leds[getPixelNumber(x, y)] = CHSV(158U, 255U - pgm_read_byte(&aquariumGIF[GIFframe][(y+GIFshifty)%32U][(x+GIFshiftx)%32U]) * modes[EFF_WATERPOLL].Scale / 100U, 255U);
      }
    }
    GIFframe++;    
  }
  else if (loadingFlag)
  {
    loadingFlag = false;
    FastLED.clear();

    for (int16_t i = 0U; i < NUM_LEDS; i++)
    {
      leds[i] = CHSV(modes[EFF_WATERPOLL].Scale * 2.55, 255U, 255U);
    }
  }  
}


// ------------------------------ ЭФФЕКТ КУБИК РУБИКА 2D ----------------------
// (c) SottNick

void setCurrentPalette(){
      if (modes[currentMode].Scale > 100U) modes[currentMode].Scale = 100U; // чтобы не было проблем при прошивке без очистки памяти
      curPalette = palette_arr[(uint8_t)(modes[currentMode].Scale/100.0F*((sizeof(palette_arr)/sizeof(TProgmemRGBPalette16 *))-0.01F))];
}

#define PAUSE_MAX 7 // пропустить 7 кадров после завершения анимации сдвига ячеек

//uint8_t noise3d[1][WIDTH][HEIGHT]; // тут используем только нулевую колонку и нулевую строку. просто для экономии памяти взяли существующий трёхмерный массив
//uint8_t hue2; // осталось шагов паузы
//uint8_t step; // текущий шаг сдвига (от 0 до deltaValue-1)
uint8_t deltaValue; // всего шагов сдвига (до razmer? до (razmer?+1)*shtuk?)
//uint8_t deltaHue, deltaHue2; // глобальный X и глобальный Y нашего "кубика"
uint8_t razmerX, razmerY; // размеры ячеек по горизонтали / вертикали
uint8_t shtukX, shtukY; // количество ячеек по горизонтали / вертикали
uint8_t poleX, poleY; // размер всего поля по горизонтали / вертикали (в том числе 1 дополнительная пустая дорожка-разделитель с какой-то из сторон)
int8_t globalShiftX, globalShiftY; // нужно ли сдвинуть всё поле по окончаии цикла и в каком из направлений (-1, 0, +1)
bool seamlessX; // получилось ли сделать поле по Х бесшовным
bool krutimVertikalno; // направление вращения в данный момент

void cube2dRoutine(){
    uint8_t x, y;
    uint8_t anim0; // будем считать тут начальный пиксель для анимации сдвига строки/колонки
    int8_t shift, kudaVse; // какое-то расчётное направление сдвига (-1, 0, +1)
    CRGB color, color2;
    
    if (loadingFlag)
    {
      loadingFlag = false;
      setCurrentPalette();
      FastLED.clear();

      razmerX = (modes[currentMode].Scale - 1U) % 11U + 1U; // размер ячейки от 1 до 11 пикселей для каждой из 9 палитр
      razmerY = razmerX;
      if (modes[currentMode].Speed & 0x01) // по идее, ячейки не обязательно должны быть квадратными, поэтому можно тут поизвращаться
        razmerY = (razmerY << 1U) + 1U;

      shtukY = HEIGHT / (razmerY + 1U);
      if (shtukY < 2U)
        shtukY = 2U;
      y = HEIGHT / shtukY - 1U;
      if (razmerY > y)
        razmerY = y;
      poleY = (razmerY + 1U) * shtukY;
      shtukX = WIDTH / (razmerX + 1U);
      if (shtukX < 2U)
        shtukX = 2U;
      x = WIDTH / shtukX - 1U;
      if (razmerX > x)
        razmerX = x;
      poleX = (razmerX + 1U) * shtukX;
      seamlessX = (poleX == WIDTH);
      deltaHue = 0U;
      deltaHue2 = 0U;
      globalShiftX = 0;
      globalShiftY = 0;

      for (uint8_t j = 0U; j < shtukY; j++)
      {
        y = j * (razmerY + 1U); // + deltaHue2 т.к. оно =0U
        for (uint8_t i = 0U; i < shtukX; i++)
        {
          x = i * (razmerX + 1U); // + deltaHue т.к. оно =0U
          if (modes[currentMode].Scale == 100U)
            color = CHSV(45U, 0U, 128U + random8(128U));
          else  
            color = ColorFromPalette(*curPalette, random8());
          for (uint8_t k = 0U; k < razmerY; k++)
            for (uint8_t m = 0U; m < razmerX; m++)
              leds[getPixelNumber(x+m, y+k)] = color;
        }
      }
      step = 4U; // текущий шаг сдвига первоначально с перебором (от 0 до deltaValue-1)
      deltaValue = 4U; // всего шагов сдвига (от razmer? до (razmer?+1) * shtuk?)
      hue2 = 0U; // осталось шагов паузы

      //это лишнее обнуление
      //krutimVertikalno = true;
      //for (uint8_t i = 0U; i < shtukX; i++)
      //  noise3d[0][i][0] = 0U;
    }

  //двигаем, что получилось...
  if (hue2 == 0 && step < deltaValue) // если пауза закончилась, а цикл вращения ещё не завершён
  {
    step++;
    if (krutimVertikalno)
    {
      for (uint8_t i = 0U; i < shtukX; i++)
      {
        x = (deltaHue + i * (razmerX + 1U)) % WIDTH;
        if (noise3d[0][i][0] > 0) // в нулевой ячейке храним оставшееся количество ходов прокрутки
        {
          noise3d[0][i][0]--;
          shift = noise3d[0][i][1] - 1; // в первой ячейке храним направление прокрутки

          if (globalShiftY == 0)
            anim0 = (deltaHue2 == 0U) ? 0U : deltaHue2 - 1U;
          else if (globalShiftY > 0)
            anim0 = deltaHue2;
          else
            anim0 = deltaHue2 - 1U;
          
          if (shift < 0) // если крутим столбец вниз
          {
            color = leds[getPixelNumber(x, anim0)];                                   // берём цвет от нижней строчки
            for (uint8_t k = anim0; k < anim0+poleY-1; k++)
            {
              color2 = leds[getPixelNumber(x,k+1)];                                   // берём цвет от строчки над нашей
              for (uint8_t m = x; m < x + razmerX; m++)
                leds[getPixelNumber(m % WIDTH,k)] = color2;                           // копируем его на всю нашу строку
            }
            for   (uint8_t m = x; m < x + razmerX; m++)
              leds[getPixelNumber(m % WIDTH,anim0+poleY-1)] = color;                  // цвет нижней строчки копируем на всю верхнюю
          }
          else if (shift > 0) // если крутим столбец вверх
          {
            color = leds[getPixelNumber(x,anim0+poleY-1)];                            // берём цвет от верхней строчки
            for (uint8_t k = anim0+poleY-1; k > anim0 ; k--)
            {
              color2 = leds[getPixelNumber(x,k-1)];                                   // берём цвет от строчки под нашей
              for (uint8_t m = x; m < x + razmerX; m++)
                leds[getPixelNumber(m % WIDTH,k)] = color2;                           // копируем его на всю нашу строку
            }
            for   (uint8_t m = x; m < x + razmerX; m++)
              leds[getPixelNumber(m % WIDTH, anim0)] = color;                         // цвет верхней строчки копируем на всю нижнюю
          }
        }
      }
    }
    else
    {
      for (uint8_t j = 0U; j < shtukY; j++)
      {
        y = deltaHue2 + j * (razmerY + 1U);
        if (noise3d[0][0][j] > 0) // в нулевой ячейке храним оставшееся количество ходов прокрутки
        {
          noise3d[0][0][j]--;
          shift = noise3d[0][1][j] - 1; // в первой ячейке храним направление прокрутки
      
          if (seamlessX)
            anim0 = 0U;
          else if (globalShiftX == 0)
            anim0 = (deltaHue == 0U) ? 0U : deltaHue - 1U;
          else if (globalShiftX > 0)
            anim0 = deltaHue;
          else
            anim0 = deltaHue - 1U;
          
          if (shift < 0) // если крутим строку влево
          {
            color = leds[getPixelNumber(anim0, y)];                            // берём цвет от левой колонки (левого пикселя)
            for (uint8_t k = anim0; k < anim0+poleX-1; k++)
            {
              color2 = leds[getPixelNumber(k+1, y)];                           // берём цвет от колонки (пикселя) правее
              for (uint8_t m = y; m < y + razmerY; m++)
                leds[getPixelNumber(k, m)] = color2;                           // копируем его на всю нашу колонку
            }
            for   (uint8_t m = y; m < y + razmerY; m++)
              leds[getPixelNumber(anim0+poleX-1, m)] = color;                  // цвет левой колонки копируем на всю правую
          }
          else if (shift > 0) // если крутим столбец вверх
          {
            color = leds[getPixelNumber(anim0+poleX-1, y)];                    // берём цвет от правой колонки
            for (uint8_t k = anim0+poleX-1; k > anim0 ; k--)
            {
              color2 = leds[getPixelNumber(k-1, y)];                           // берём цвет от колонки левее
              for (uint8_t m = y; m < y + razmerY; m++)
                leds[getPixelNumber(k, m)] = color2;                           // копируем его на всю нашу колонку
            }
            for   (uint8_t m = y; m < y + razmerY; m++)
              leds[getPixelNumber(anim0, m)] = color;                          // цвет правой колонки копируем на всю левую
          }
        }
      }
    }
   
  }
  else if (hue2 != 0U) // пропускаем кадры после прокрутки кубика (делаем паузу)
    hue2--;

  if (step >= deltaValue) // если цикл вращения завершён, меняем местами соответствующие ячейки (цвет в них) и точку первой ячейки
    {
      step = 0U; 
      hue2 = PAUSE_MAX;
      //если часть ячеек двигалась на 1 пиксель, пододвигаем глобальные координаты начала
      deltaHue2 = deltaHue2 + globalShiftY; //+= globalShiftY;
      globalShiftY = 0;
      //deltaHue += globalShiftX; для бесшовной не годится
      deltaHue = (WIDTH + deltaHue + globalShiftX) % WIDTH;
      globalShiftX = 0;

      //пришла пора выбрать следующие параметры вращения
      kudaVse = 0;
      krutimVertikalno = random8(2U);
      if (krutimVertikalno) // идём по горизонтали, крутим по вертикали (столбцы двигаются)
      {
        for (uint8_t i = 0U; i < shtukX; i++)
        {
          noise3d[0][i][1] = random8(3);
          shift = noise3d[0][i][1] - 1; // в первой ячейке храним направление прокрутки
          if (kudaVse == 0)
            kudaVse = shift;
          else if (shift != 0 && kudaVse != shift)
            kudaVse = 50;
        }
        deltaValue = razmerY + ((deltaHue2 - kudaVse >= 0 && deltaHue2 - kudaVse + poleY < (int)HEIGHT) ? random8(2U) : 1U);

/*        if (kudaVse == 0) // пытался сделать, чтобы при совпадении "весь кубик стоит" сдвинуть его весь на пиксель, но заколебался
        {
          deltaValue = razmerY;
          kudaVse = (random8(2)) ? 1 : -1;
          if (deltaHue2 - kudaVse < 0 || deltaHue2 - kudaVse + poleY >= (int)HEIGHT)
            kudaVse = 0 - kudaVse;
        }
*/
        if (deltaValue == razmerY) // значит полюбому kudaVse было = (-1, 0, +1) - и для нуля в том числе мы двигаем весь куб на 1 пиксель
        {
          globalShiftY = 1 - kudaVse; //временно на единичку больше, чем надо
          for (uint8_t i = 0U; i < shtukX; i++)
            if (noise3d[0][i][1] == 1U) // если ячейка никуда не планировала двигаться
            {
              noise3d[0][i][1] = globalShiftY;
              noise3d[0][i][0] = 1U; // в нулевой ячейке храним количество ходов сдвига
            }
            else
              noise3d[0][i][0] = deltaValue; // в нулевой ячейке храним количество ходов сдвига
          globalShiftY--;
        }
        else
        {
          x = 0;
          for (uint8_t i = 0U; i < shtukX; i++)
            if (noise3d[0][i][1] != 1U)
              {
                y = random8(shtukY);
                if (y > x)
                  x = y;
                noise3d[0][i][0] = deltaValue * (x + 1U); // в нулевой ячейке храним количество ходов сдвига
              }  
          deltaValue = deltaValue * (x + 1U);
        }      
              
      }
      else // идём по вертикали, крутим по горизонтали (строки двигаются)
      {
        for (uint8_t j = 0U; j < shtukY; j++)
        {
          noise3d[0][1][j] = random8(3);
          shift = noise3d[0][1][j] - 1; // в первой ячейке храним направление прокрутки
          if (kudaVse == 0)
            kudaVse = shift;
          else if (shift != 0 && kudaVse != shift)
            kudaVse = 50;
        }
        if (seamlessX)
          deltaValue = razmerX + ((kudaVse < 50) ? random8(2U) : 1U);
        else  
          deltaValue = razmerX + ((deltaHue - kudaVse >= 0 && deltaHue - kudaVse + poleX < (int)WIDTH) ? random8(2U) : 1U);
        
/*        if (kudaVse == 0) // пытался сделать, чтобы при совпадении "весь кубик стоит" сдвинуть его весь на пиксель, но заколебался
        {
          deltaValue = razmerX;
          kudaVse = (random8(2)) ? 1 : -1;
          if (deltaHue - kudaVse < 0 || deltaHue - kudaVse + poleX >= (int)WIDTH)
            kudaVse = 0 - kudaVse;
        }
*/          
        if (deltaValue == razmerX) // значит полюбому kudaVse было = (-1, 0, +1) - и для нуля в том числе мы двигаем весь куб на 1 пиксель
        {
          globalShiftX = 1 - kudaVse; //временно на единичку больше, чем надо
          for (uint8_t j = 0U; j < shtukY; j++)
            if (noise3d[0][1][j] == 1U) // если ячейка никуда не планировала двигаться
            {
              noise3d[0][1][j] = globalShiftX;
              noise3d[0][0][j] = 1U; // в нулевой ячейке храним количество ходов сдвига
            }
            else
              noise3d[0][0][j] = deltaValue; // в нулевой ячейке храним количество ходов сдвига
          globalShiftX--;
        }
        else
        {
          y = 0;
          for (uint8_t j = 0U; j < shtukY; j++)
            if (noise3d[0][1][j] != 1U)
              {
                x = random8(shtukX);
                if (x > y)
                  y = x;
                noise3d[0][0][j] = deltaValue * (x + 1U); // в нулевой ячейке храним количество ходов сдвига
              }  
          deltaValue = deltaValue * (y + 1U);
        }      
      }
   }
}


// ============= BOUNCE / ПРЫЖКИ / МЯЧИКИ БЕЗ ГРАНИЦ ===============
// Aurora : https://github.com/pixelmatix/aurora/blob/master/PatternBounce.h
// Copyright(c) 2014 Jason Coon
// v1.0 - Updating for GuverLamp v1.7 by Palpalych 14.04.2020
//#define e_bnc_COUNT (WIDTH) // теперь enlargedObjectNUM. хз, почему использовалась ширина матрицы тут, если по параметру идёт обращение к массиву boids, у которого может быть меньший размер
#define e_bnc_SIDEJUMP (true)
PVector gravity = PVector(0, -0.0125);
void bounceRoutine()
{
  if (loadingFlag) {
    loadingFlag = false;
    setCurrentPalette();
    //hue2 = 255U - scale8(64U, myScale8(modes[currentMode].Scale * 2.55));
    //hue2 = 254U - ((modes[currentMode].Scale - 1U) % 11U) * 3;
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) % 11U / 10.0 * (AVAILABLE_BOID_COUNT - 1U) + 1U;
    uint8_t colorWidth = 256U / enlargedObjectNUM;
    for (uint8_t i = 0; i < enlargedObjectNUM; i++)
    {
      Boid boid = Boid(i, HEIGHT / 8);
      boid.velocity.x = 0;
      boid.location.y = 0;//(HEIGHT -1) / 4;
      boid.velocity.y = i * -0.01;
      boid.colorIndex = colorWidth * i;
      boid.maxforce = 10;
      boid.maxspeed = 10;
      boids[i] = boid;
    }
  }
  blurScreen(beatsin8(5U, 1U, 5U));
  dimAll(255U - modes[currentMode].Speed); // dimAll(hue2);
  for (uint8_t i = 0; i < enlargedObjectNUM; i++)
  {
    Boid boid = boids[i];
    boid.applyForce(gravity);
    boid.update();
    CRGB color = ColorFromPalette(*curPalette, boid.colorIndex); // boid.colorIndex + hue
    drawPixelXY((uint32_t)(boid.location.x) % WIDTH, boid.location.y, color);
    if (boid.location.y <= 0)
    {
      boid.location.y = 0;
      boid.velocity.y *= -1.0;
      boid.velocity.x *= 0.9;
      if (!random8() || boid.velocity.y < 0.01)
      {
#if e_bnc_SIDEJUMP
        boid.applyForce(PVector((float)random(127) / 255 - 0.25, (float)random(255) / 255));
#else
        boid.applyForce(PVector(0, (float)random(255) / 255));
#endif
      }
    }
    boids[i] = boid;
  }
//  EVERY_N_MILLIS(20)
//  {
//  hue++;
//  }
}


// ----------- Эффект "ДНК"
// База https://pastebin.com/jwvC1sNF адаптация и доработки kostyamat

void wu_pixel(uint32_t x, uint32_t y, CRGB * col) {      //awesome wu_pixel procedure by reddit u/sutaburosu
  // extract the fractional parts and derive their inverses
  uint8_t xx = x & 0xff, yy = y & 0xff, ix = 255 - xx, iy = 255 - yy;
  // calculate the intensities for each affected pixel
  #define WU_WEIGHT(a,b) ((uint8_t) (((a)*(b)+(a)+(b))>>8))
  uint8_t wu[4] = {WU_WEIGHT(ix, iy), WU_WEIGHT(xx, iy),
                   WU_WEIGHT(ix, yy), WU_WEIGHT(xx, yy)};
  // multiply the intensities by the colour, and saturating-add them to the pixels
  for (uint8_t i = 0; i < 4; i++) {
    uint16_t xy = XY((x >> 8) + (i & 1), (y >> 8) + ((i >> 1) & 1));
    if (xy < NUM_LEDS){
      leds[xy].r = qadd8(leds[xy].r, col->r * wu[i] >> 8);
      leds[xy].g = qadd8(leds[xy].g, col->g * wu[i] >> 8);
      leds[xy].b = qadd8(leds[xy].b, col->b * wu[i] >> 8);
    }
  }
}

void DNARoutine()
{
  double freq = 3000;
  float mn =255.0/13.8;
  uint8_t speeds = map8(modes[currentMode].Speed, 10U, 60U);
  
  fadeToBlackBy(leds, NUM_LEDS, speeds);

#if HEIGHT + HEIGHT > WIDTH + 4
  for (uint8_t i = 0; i < WIDTH; i++)
  {
    uint16_t ms = millis();
    uint32_t x = beatsin16(speeds, 0, (HEIGHT - 1) * 256, 0, i * freq);
    uint32_t y = i * 256;
    uint32_t x1 = beatsin16(speeds, 0, (HEIGHT - 1) * 256, 0, i * freq + 32768);

    CRGB col = CHSV(ms / 29 + i * 255 / (WIDTH - 1), 255, 255);// beatsin8(speeds, 60, 255U, 0, i * mn)); пропадала середина с такой яркостью
    CRGB col1 = CHSV(ms / 29 + i * 255 / (WIDTH - 1) + 128, 255, 255);//beatsin8(speeds, 60, 255U, 0, i * mn + 128));  пропадала середина с такой яркостью
    wu_pixel (x , y, &col);
    wu_pixel (x1 , y, &col1);
  }
#else // для узких горизонтально расположенных матриц будем рисовать горизонтально
  for (uint8_t i = 0; i < HEIGHT; i++)
  {
    uint16_t ms = millis();
    uint32_t x = beatsin16(speeds, 0, (WIDTH - 1) * 256, 0, i * freq);
    uint32_t y = i * 256;
    uint32_t x1 = beatsin16(speeds, 0, (WIDTH - 1) * 256, 0, i * freq + 32768);

    CRGB col = CHSV(ms / 29 + i * 255 / (HEIGHT - 1), 255, beatsin8(speeds, 60, 255U, 0, i * mn));
    CRGB col1 = CHSV(ms / 29 + i * 255 / (HEIGHT - 1) + 128, 255, beatsin8(speeds, 60, 255U, 0, i * mn + 128));
    wu_pixel (y , x, &col);
    wu_pixel (y , x1, &col1);
  }
#endif

  blurScreen(16);
}


// ------------- Змейки --------------
// (c) SottNick

//#define enlargedOBJECT_MAX_COUNT            (WIDTH * 2)          // максимальное количество червяков
//uint8_t enlargedObjectNUM;                                   // выбранное количество червяков
//long  enlargedObjectTime[enlargedOBJECT_MAX_COUNT] ;  // тут будет траектория тела червяка
//float trackingObjectPosX[trackingOBJECT_MAX_COUNT]; // тут будет позиция головы 
//float trackingObjectPosY[trackingOBJECT_MAX_COUNT]; // тут будет позиция головы
//float trackingObjectSpeedX[trackingOBJECT_MAX_COUNT]; // тут будет скорость червяка
//float trackingObjectSpeedY[trackingOBJECT_MAX_COUNT]; // тут будет дробная часть позиции головы
//float trackingObjectShift[trackingOBJECT_MAX_COUNT]; не пригодилось пока что
//uint8_t trackingObjectHue[trackingOBJECT_MAX_COUNT]; // тут будет начальный цвет червяка
//uint8_t trackingObjectState[trackingOBJECT_MAX_COUNT]; тут будет направление червяка

#define SNAKES_LENGTH (8U) // длина червяка от 2 до 15 (+ 1 пиксель голова/хвостик), ограничена размером переменной для хранения трактории тела червяка

void snakesRoutine(){
  if (loadingFlag)
  {
    loadingFlag = false;
    speedfactor = (float)modes[currentMode].Speed / 555.0f + 0.001f;
    
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) / 99.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
    for (uint8_t i = 0; i < enlargedObjectNUM; i++){
      enlargedObjectTime[i] = 0;
      trackingObjectPosX[i] = random8(WIDTH);
      trackingObjectPosY[i] = random8(HEIGHT);
      trackingObjectSpeedX[i] = (255. + random8()) / 255.;
      trackingObjectSpeedY[i] = 0;
      //trackingObjectShift[i] = 0;
      trackingObjectHue[i] = random8();
      trackingObjectState[i] = random8(4);//     B00           направление головы змейки
                                           // B10     B11
                                           //     B01
    }
    
  }
  //hue++;
  //dimAll(220);
  FastLED.clear();

  int8_t dx, dy;
  for (uint8_t i = 0; i < enlargedObjectNUM; i++){
   trackingObjectSpeedY[i] += trackingObjectSpeedX[i] * speedfactor;
   if (trackingObjectSpeedY[i] >= 1)
   {
    trackingObjectSpeedY[i] = trackingObjectSpeedY[i] - (int)trackingObjectSpeedY[i];
    if (random8(9U) == 0U) // вероятность поворота
      if (random8(2U)){ // <- поворот налево
        enlargedObjectTime[i] = (enlargedObjectTime[i] << 2) | B01; // младший бит = поворот
        switch (trackingObjectState[i]) {
          case B10:
            trackingObjectState[i] = B01;
            if (trackingObjectPosY[i] == 0U)
              trackingObjectPosY[i] = HEIGHT - 1U;
            else
              trackingObjectPosY[i]--;
            break;
          case B11:
            trackingObjectState[i] = B00;
            if (trackingObjectPosY[i] >= HEIGHT - 1U)
              trackingObjectPosY[i] = 0U;
            else
              trackingObjectPosY[i]++;
            break;
          case B00:
            trackingObjectState[i] = B10;
            if (trackingObjectPosX[i] == 0U)
              trackingObjectPosX[i] = WIDTH - 1U;
            else
              trackingObjectPosX[i]--;
            break;
          case B01:
            trackingObjectState[i] = B11;
            if (trackingObjectPosX[i] >= WIDTH - 1U)
              trackingObjectPosX[i] = 0U;
            else
              trackingObjectPosX[i]++;
            break;
        }
      }
      else{ // -> поворот направо
        enlargedObjectTime[i] = (enlargedObjectTime[i] << 2) | B11; // младший бит = поворот, старший = направо
        switch (trackingObjectState[i]) {
          case B11:
            trackingObjectState[i] = B01;
            if (trackingObjectPosY[i] == 0U)
              trackingObjectPosY[i] = HEIGHT - 1U;
            else
              trackingObjectPosY[i]--;
            break;
          case B10:
            trackingObjectState[i] = B00;
            if (trackingObjectPosY[i] >= HEIGHT - 1U)
              trackingObjectPosY[i] = 0U;
            else
              trackingObjectPosY[i]++;
            break;
          case B01:
            trackingObjectState[i] = B10;
            if (trackingObjectPosX[i] == 0U)
              trackingObjectPosX[i] = WIDTH - 1U;
            else
              trackingObjectPosX[i]--;
            break;
          case B00:
            trackingObjectState[i] = B11;
            if (trackingObjectPosX[i] >= WIDTH - 1U)
              trackingObjectPosX[i] = 0U;
            else
              trackingObjectPosX[i]++;
            break;
        }
      }
    else { // двигаем без поворота
        enlargedObjectTime[i] = (enlargedObjectTime[i] << 2);
        switch (trackingObjectState[i]) {
          case B01:
            if (trackingObjectPosY[i] == 0U)
              trackingObjectPosY[i] = HEIGHT - 1U;
            else
              trackingObjectPosY[i]--;
            break;
          case B00:
            if (trackingObjectPosY[i] >= HEIGHT - 1U)
              trackingObjectPosY[i] = 0U;
            else
              trackingObjectPosY[i]++;
            break;
          case B10:
            if (trackingObjectPosX[i] == 0U)
              trackingObjectPosX[i] = WIDTH - 1U;
            else
              trackingObjectPosX[i]--;
            break;
          case B11:
            if (trackingObjectPosX[i] >= WIDTH - 1U)
              trackingObjectPosX[i] = 0U;
            else
              trackingObjectPosX[i]++;
            break;
        }
      
    }
   }
   
    switch (trackingObjectState[i]) {
     case B01:
       dy = 1;
       dx = 0;
       break;
     case B00:
       dy = -1;
       dx = 0;
       break;
     case B10:
       dy = 0;
       dx = 1;
       break;
     case B11:
       dy = 0;
       dx = -1;
       break;
    }
    long temp = enlargedObjectTime[i];
    uint8_t x = trackingObjectPosX[i];
    uint8_t y = trackingObjectPosY[i];
    //CHSV color = CHSV(trackingObjectHue[i], 255U, 255U);
    //drawPixelXY(x, y, color);
    //drawPixelXYF(x, y, CHSV(trackingObjectHue[i], 255U, trackingObjectSpeedY[i] * 255)); // тут рисуется голова // слишком сложно для простого сложения цветов
    leds[getPixelNumber(x,y)] += CHSV(trackingObjectHue[i], 255U, trackingObjectSpeedY[i] * 255); // тут рисуется голова

    for (uint8_t m = 0; m < SNAKES_LENGTH; m++){ // 16 бит распаковываем, 14 ещё остаётся без дела в запасе, 2 на хвостик
      x = (WIDTH + x + dx) % WIDTH;
      y = (HEIGHT + y + dy) % HEIGHT;
      //drawPixelXYF(x, y, CHSV(trackingObjectHue[i] + m*4U, 255U, 255U)); // тут рисуется тело // слишком сложно для простого сложения цветов
      //leds[getPixelNumber(x,y)] += CHSV(trackingObjectHue[i] + m*4U, 255U, 255U); // тут рисуется тело
      leds[getPixelNumber(x,y)] += CHSV(trackingObjectHue[i] + (m + trackingObjectSpeedY[i])*4U, 255U, 255U); // тут рисуется тело
 
      if (temp & B01){ // младший бит = поворот, старший = направо
        temp = temp >> 1;
        if (temp & B01){ // старший бит = направо
          if (dx == 0){
            dx = 0 - dy;
            dy = 0;
          }
          else{
            dy = dx;
            dx = 0;
          }
        }
        else{ // иначе налево
          if (dx == 0){
            dx = dy;
            dy = 0;
          }
          else{
            dy = 0 - dx;
            dx = 0;
          }
        }
        temp = temp >> 1;
      }
      else { // если без поворота
        temp = temp >> 2;
      }
    }
    x = (WIDTH + x + dx) % WIDTH;
    y = (HEIGHT + y + dy) % HEIGHT;
    //drawPixelXYF(x, y, CHSV(trackingObjectHue[i] + SNAKES_LENGTH*4U, 255U, (1 - trackingObjectSpeedY[i]) * 255)); // хвостик // слишком сложно для простого сложения цветов
    //leds[getPixelNumber(x,y)] += CHSV(trackingObjectHue[i] + SNAKES_LENGTH*4U, 255U, (1 - trackingObjectSpeedY[i]) * 255); // хвостик
    leds[getPixelNumber(x,y)] += CHSV(trackingObjectHue[i] + (SNAKES_LENGTH + trackingObjectSpeedY[i])*4U, 255U, (1 - trackingObjectSpeedY[i]) * 255); // хвостик
  }
}
// ----------------------------- Жидкая лампа ---------------------
// ----------- Эффект "Лавовая лампа" (c) obliterator
// https://github.com/DmytroKorniienko/FireLamp_JeeUI/commit/9bad25adc2c917fbf3dfa97f4c498769aaf76ebe
// с генератором палитр by SottNick


//аналог ардуино функции map(), но только для float
float fmap(const float x, const float in_min, const float in_max, const float out_min, const float out_max){
        return (out_max - out_min) * (x - in_min) / (in_max - in_min) + out_min;
    }
float mapcurve(const float x, const float in_min, const float in_max, const float out_min, const float out_max, float (*curve)(float,float,float,float)){
        if (x <= in_min) return out_min;
        if (x >= in_max) return out_max;
        return curve((x - in_min), out_min, (out_max - out_min), (in_max - in_min));
    }
float InQuad(float t, float b, float c, float d) { t /= d; return c * t * t + b; }    
float OutQuart(float t, float b, float c, float d) { t = t / d - 1; return -c * (t * t * t * t - 1) + b; }
float InOutQuad(float t, float b, float c, float d) {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        --t;
        return -c / 2 * (t * (t - 2) - 1) + b;
    }

    unsigned MASS_MIN = 10;
    unsigned MASS_MAX = 50;

//        float hot = 0;
float liquidLampHot[enlargedOBJECT_MAX_COUNT];        
//        float spf = 0;
float liquidLampSpf[enlargedOBJECT_MAX_COUNT];        
//        int mass = 0;
//uint8_t trackingObjectState[enlargedOBJECT_MAX_COUNT];
//        unsigned mx = 0;
unsigned liquidLampMX[enlargedOBJECT_MAX_COUNT];        
//        unsigned sc = 0;
unsigned liquidLampSC[enlargedOBJECT_MAX_COUNT];        
//        unsigned tr = 0;
unsigned liquidLampTR[enlargedOBJECT_MAX_COUNT];        

void LiquidLampPosition(){
  //bool physic_on = modes[currentMode].Speed & 0x01;
  for (uint8_t i = 0; i < enlargedObjectNUM; i++) {
    liquidLampHot[i] += mapcurve(trackingObjectPosY[i], 0, HEIGHT-1, 5, -5, InOutQuad) * speedfactor;

    float heat = (liquidLampHot[i] / trackingObjectState[i]) - 1;
    if (heat > 0 && trackingObjectPosY[i] < HEIGHT-1) {
      trackingObjectSpeedY[i] += heat * liquidLampSpf[i];
    }
    if (trackingObjectPosY[i] > 0) {
      trackingObjectSpeedY[i] -= 0.07;
    }

    if (trackingObjectSpeedY[i]) trackingObjectSpeedY[i] *= 0.85;
    trackingObjectPosY[i] += trackingObjectSpeedY[i] * speedfactor;

    //if (physic_on) {
      if (trackingObjectSpeedX[i]) trackingObjectSpeedX[i] *= 0.7;
      trackingObjectPosX[i] += trackingObjectSpeedX[i] * speedfactor;
    //}

    if (trackingObjectPosX[i] > WIDTH-1) trackingObjectPosX[i] -= WIDTH-1;
    if (trackingObjectPosX[i] < 0) trackingObjectPosX[i] += WIDTH-1;
    if (trackingObjectPosY[i] > HEIGHT-1) trackingObjectPosY[i] = HEIGHT-1;
    if (trackingObjectPosY[i] < 0) trackingObjectPosY[i] = 0;
  };
}

void LiquidLampPhysic(){
  for (uint8_t i = 0; i < enlargedObjectNUM; i++) {
    //Particle *p1 = (Particle *)&particles[i];
    // отключаем физику на границах, чтобы не слипались шары
    if (trackingObjectPosY[i] < 3 || trackingObjectPosY[i] > HEIGHT - 1) continue;
    for (uint8_t j = 0; j < enlargedObjectNUM; j++) {
      //Particle *p2 = (Particle *)&particles[j];
      if (trackingObjectPosY[j] < 3 || trackingObjectPosY[j] > HEIGHT - 1) continue;
      float radius = 3;//(trackingObjectShift[i] + trackingObjectShift[j]);
      if (trackingObjectPosX[i] + radius > trackingObjectPosX[j]
       && trackingObjectPosX[i] < radius + trackingObjectPosX[j]
       && trackingObjectPosY[i] + radius > trackingObjectPosY[j]
       && trackingObjectPosY[i] < radius + trackingObjectPosY[j]
      ){
          //float dist = EffectMath::distance(p1->position_x, p1->position_y, p2->position_x, p2->position_y);
          float dx =  min((float)fabs(trackingObjectPosX[i] - trackingObjectPosX[j]), (float)WIDTH + trackingObjectPosX[i] - trackingObjectPosX[j]); //по идее бесшовный икс
          float dy =  fabs(trackingObjectPosY[i] - trackingObjectPosY[j]);
          float dist = sqrt3((dx * dx) + (dy * dy));
          
          if (dist <= radius) {
            float nx = (trackingObjectPosX[j] - trackingObjectPosX[i]) / dist;
            float ny = (trackingObjectPosY[j] - trackingObjectPosY[i]) / dist;
            float p = 2 * (trackingObjectSpeedX[i] * nx + trackingObjectSpeedY[i] * ny - trackingObjectSpeedX[j] * nx - trackingObjectSpeedY[j] * ny) / (trackingObjectState[i] + trackingObjectState[j]);
            float pnx = p * nx, pny = p * ny;
            trackingObjectSpeedX[i] = trackingObjectSpeedX[i] - pnx * trackingObjectState[i];
            trackingObjectSpeedY[i] = trackingObjectSpeedY[i] - pny * trackingObjectState[i];
            trackingObjectSpeedX[j] = trackingObjectSpeedX[j] + pnx * trackingObjectState[j];
            trackingObjectSpeedY[j] = trackingObjectSpeedY[j] + pny * trackingObjectState[j];
          }
        }
    }
  }
}


/*
DEFINE_GRADIENT_PALETTE(MBVioletColors_gp){ 
    0,  255,  0,  0, // red
    1,  46,  123,  87, // seaBlue
    80,  0,  0,  139, // DarkBlue
    150,  128,  0,  128, // purple
    255,  255,  0,  0
};
*/
// генератор палитр для Жидкой лампы (c) SottNick
static const uint8_t MBVioletColors_arr[5][4] PROGMEM = // та же палитра, но в формате CHSV
{
  {0  , 0  , 255, 255}, //  0, 255,   0,   0, // red
//  {1  , 108, 161, 122}, //  1,  46, 123,  87, // seaBlue
  {1  , 155, 209, 255}, //  1,  46, 124, 255, // сделал поярче цвет воды
  {80 , 170, 255, 140}, // 80,   0,   0, 139, // DarkBlue
  {150, 213, 255, 128}, //150, 128,   0, 128, // purple
  {255, 0  , 255, 255}  //255, 255,   0,   0  // red again
};

CRGBPalette16 myPal;

void fillMyPal16(uint8_t hue, bool isInvert = false){
  int8_t lastSlotUsed = -1;
  uint8_t istart8, iend8;
  CRGB rgbstart, rgbend;
  
  // начинаем с нуля
  if (isInvert)
    //с неявным преобразованием оттенков цвета получаются, как в фотошопе, но для данного эффекта не красиво выглядят
    //rgbstart = CHSV(256 + hue - pgm_read_byte(&MBVioletColors_arr[0][1]), pgm_read_byte(&MBVioletColors_arr[0][2]), pgm_read_byte(&MBVioletColors_arr[0][3])); // начальная строчка палитры с инверсией
    hsv2rgb_spectrum(CHSV(256 + hue - pgm_read_byte(&MBVioletColors_arr[0][1]), pgm_read_byte(&MBVioletColors_arr[0][2]), pgm_read_byte(&MBVioletColors_arr[0][3])), rgbstart);
  else
    //rgbstart = CHSV(hue + pgm_read_byte(&MBVioletColors_arr[0][1]), pgm_read_byte(&MBVioletColors_arr[0][2]), pgm_read_byte(&MBVioletColors_arr[0][3])); // начальная строчка палитры
    hsv2rgb_spectrum(CHSV(hue + pgm_read_byte(&MBVioletColors_arr[0][1]), pgm_read_byte(&MBVioletColors_arr[0][2]), pgm_read_byte(&MBVioletColors_arr[0][3])), rgbstart);
  int indexstart = 0; // начальный индекс палитры
  for (uint8_t i = 1U; i < 5U; i++) { // в палитре @obliterator всего 5 строчек
    int indexend = pgm_read_byte(&MBVioletColors_arr[i][0]);
    if (isInvert)
      //rgbend = CHSV(256 + hue - pgm_read_byte(&MBVioletColors_arr[i][1]), pgm_read_byte(&MBVioletColors_arr[i][2]), pgm_read_byte(&MBVioletColors_arr[i][3])); // следующая строчка палитры с инверсией
      hsv2rgb_spectrum(CHSV(256 + hue - pgm_read_byte(&MBVioletColors_arr[i][1]), pgm_read_byte(&MBVioletColors_arr[i][2]), pgm_read_byte(&MBVioletColors_arr[i][3])), rgbend);
    else
      //rgbend = CHSV(hue + pgm_read_byte(&MBVioletColors_arr[i][1]), pgm_read_byte(&MBVioletColors_arr[i][2]), pgm_read_byte(&MBVioletColors_arr[i][3])); // следующая строчка палитры
      hsv2rgb_spectrum(CHSV(hue + pgm_read_byte(&MBVioletColors_arr[i][1]), pgm_read_byte(&MBVioletColors_arr[i][2]), pgm_read_byte(&MBVioletColors_arr[i][3])), rgbend);
    istart8 = indexstart / 16;
    iend8   = indexend   / 16;
    if ((istart8 <= lastSlotUsed) && (lastSlotUsed < 15)) {
       istart8 = lastSlotUsed + 1;
       if (iend8 < istart8)
         iend8 = istart8;
    }
    lastSlotUsed = iend8;
    fill_gradient_RGB( myPal, istart8, rgbstart, iend8, rgbend);
    indexstart = indexend;
    rgbstart = rgbend;
  }
}

void LiquidLampRoutine(bool isColored){
  if (loadingFlag)
  {
    loadingFlag = false;
    speedfactor = modes[currentMode].Speed / 64.0 + 0.1; // 127 БЫЛО
    
    //setCurrentPalette();    
    //FastLED.clear();
    if (isColored){
      fillMyPal16((modes[currentMode].Scale - 1U) * 2.55, !(modes[currentMode].Scale & 0x01));
      enlargedObjectNUM = enlargedOBJECT_MAX_COUNT / 2U - 2U; //14U;
    }
    else{
      enlargedObjectNUM = (modes[currentMode].Scale - 1U) / 99.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
      hue = random8();
      deltaHue = random8(2U);
      fillMyPal16(hue, deltaHue);

      //myPal = MBVioletColorsSimple1_gp; // лучшая палитра 1
      //fillMyPal16test((modes[currentMode].Scale - 1U) * 2.55, !(modes[currentMode].Scale & 0x01));
    }
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
    else if (enlargedObjectNUM < 2U) enlargedObjectNUM = 2U;

    double minSpeed = 0.2, maxSpeed = 0.8;
    
    for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) { 
      trackingObjectPosX[i] = random8(WIDTH);
      trackingObjectPosY[i] = 0; //random8(HEIGHT);
      trackingObjectState[i] = random(MASS_MIN, MASS_MAX);
      liquidLampSpf[i] = fmap(trackingObjectState[i], MASS_MIN, MASS_MAX, 0.0015, 0.0005);
      trackingObjectShift[i] = fmap(trackingObjectState[i], MASS_MIN, MASS_MAX, 2, 3);
      liquidLampMX[i] = map(trackingObjectState[i], MASS_MIN, MASS_MAX, 60, 80); // сила возмущения
      liquidLampSC[i] = map(trackingObjectState[i], MASS_MIN, MASS_MAX, 6, 10); // радиус возмущения
      liquidLampTR[i] = liquidLampSC[i]  * 2 / 3; // отсечка расчетов (оптимизация скорости)
    }

  }
  
  LiquidLampPosition();
  //bool physic_on = modes[currentMode].Speed & 0x01;
  //if (physic_on) 
  LiquidLampPhysic;

  if (!isColored){
    hue2++;
    if (hue2 % 0x10 == 0U){
      hue++;
      fillMyPal16(hue, deltaHue);
    }
  }

  for (uint8_t x = 0; x < WIDTH; x++) {
    for (uint8_t y = 0; y < HEIGHT; y++) {
      float sum = 0;
      //for (unsigned i = 0; i < numParticles; i++) {
      for (uint8_t i = 0; i < enlargedObjectNUM; i++) {
        //Particle *p1 = (Particle *)&particles[i];
        if (abs(x - trackingObjectPosX[i]) > liquidLampTR[i] || abs(y - trackingObjectPosY[i]) > liquidLampTR[i]) continue;
        //float d = EffectMath::distance(x, y, p1->position_x, p1->position_y);
        float dx =  min((float)fabs(trackingObjectPosX[i] - (float)x), (float)WIDTH + trackingObjectPosX[i] - (float)x); //по идее бесшовный икс
        float dy =  fabs(trackingObjectPosY[i] - (float)y);
        float d = sqrt3((dx * dx) + (dy * dy));
        
        if (d < trackingObjectShift[i]) {
          sum += mapcurve(d, 0, trackingObjectShift[i], 255, liquidLampMX[i], InQuad);
        } 
        else if (d < liquidLampSC[i]){
          sum += mapcurve(d, trackingObjectShift[i], liquidLampSC[i], liquidLampMX[i], 0, OutQuart);
        }
        if (sum >= 255) { sum = 255; break; }
      }
      if (sum < 16) sum = 16;// отрезаем смазанный кусок палитры из-за отсутствия параметра NOBLEND
      CRGB color = ColorFromPalette(myPal, sum); // ,255, NOBLEND
      drawPixelXY(x, y, color);
    }
  }
}


// ----------- Эфеект "Попкорн"
// (C) Aaron Gotwalt (Soulmate)
// https://editor.soulmatelights.com/gallery/117
// переосмысление (c) SottNick

    //uint8_t NUM_ROCKETS = 10;
//enlargedObjectNUM = (modes[currentMode].Scale - 1U) % 11U / 10.0 * (AVAILABLE_BOID_COUNT - 1U) + 1U;

//    typedef struct
//    {
//        int32_t x, y, xd, yd;
//    } Rocket;
///////float trackingObjectPosX[trackingOBJECT_MAX_COUNT];
///////float trackingObjectPosY[trackingOBJECT_MAX_COUNT];
///////float trackingObjectSpeedX[trackingOBJECT_MAX_COUNT];
///////float trackingObjectSpeedY[trackingOBJECT_MAX_COUNT];

void popcornRestart_rocket(uint8_t r) {
  //deltaHue = !deltaHue; // "Мальчик" <> "Девочка"
  trackingObjectSpeedX[r] = (float)(random(-(WIDTH * HEIGHT + (WIDTH*2)), WIDTH*HEIGHT + (WIDTH*2))) / 256.0; // * (deltaHue ? 1 : -1); // Наклон. "Мальчики" налево, "девочки" направо. :)
  if ((trackingObjectPosX[r] < 0 && trackingObjectSpeedX[r] < 0) || (trackingObjectPosX[r] > (WIDTH-1) && trackingObjectSpeedX[r] > 0)) { // меняем направление только после выхода за пределы экрана
    // leap towards the centre of the screen
    trackingObjectSpeedX[r] = -trackingObjectSpeedX[r];
  }
  // controls the leap height
  trackingObjectSpeedY[r] = (float)(random8() * 8 + HEIGHT * 10) / 256.0;
  trackingObjectHue[r] = random8();
  trackingObjectPosX[r] = random8(WIDTH);
}

void popcornRoutine() {
  if (loadingFlag) {
    loadingFlag = false;
    speedfactor = fmap((float)modes[currentMode].Speed, 1., 255., 0.25, 1.0);
    //speedfactor = (float)modes[currentMode].Speed / 127.0f + 0.001f;

    setCurrentPalette();
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) % 11U / 10.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
  
    for (uint8_t r = 0; r < enlargedObjectNUM; r++) {
      trackingObjectPosX[r] = random8(WIDTH);
      trackingObjectPosY[r] = random8(HEIGHT);
      trackingObjectSpeedX[r] = 0;
      trackingObjectSpeedY[r] = -1;
      trackingObjectHue[r] = random8();
    }
  }
  float popcornGravity = 0.1 * speedfactor;
  if (modes[currentMode].Speed & 0x01) fadeToBlackBy(leds, NUM_LEDS, 60);
  else FastLED.clear();// fadeToBlackBy(leds, NUM_LEDS, 250);

//void popcornMove(float popcornGravity) {
  for (uint8_t r = 0; r < enlargedObjectNUM; r++) {
    // add the X & Y velocities to the positions
    trackingObjectPosX[r] += trackingObjectSpeedX[r] ;
    if (trackingObjectPosX[r] > WIDTH - 1)
      trackingObjectPosX[r] = trackingObjectPosX[r] - (WIDTH - 1);
    if (trackingObjectPosX[r] < 0)
      trackingObjectPosX[r] = WIDTH - 1 + trackingObjectPosX[r];
    trackingObjectPosY[r] += trackingObjectSpeedY[r] * speedfactor;
    
    if (trackingObjectPosY[r] > HEIGHT - 1){
      trackingObjectPosY[r] = HEIGHT+HEIGHT - 2 - trackingObjectPosY[r];
      trackingObjectSpeedY[r] = -trackingObjectSpeedY[r];
    }  
    

    // bounce off the floor?
    if (trackingObjectPosY[r] < 0 && trackingObjectSpeedY[r] < -0.7) { // 0.7 вычислено в экселе. скорость свободного падения ниже этой не падает. если ниже, значит ещё есть ускорение
      trackingObjectSpeedY[r] = (-trackingObjectSpeedY[r]) * 0.9375;//* 240) >> 8;
      //trackingObjectPosY[r] = trackingObjectSpeedY[r]; чё это значило вообще?!
      trackingObjectPosY[r] = -trackingObjectPosY[r];
    }

    // settled on the floor?
    if (trackingObjectPosY[r] <= -1)
      popcornRestart_rocket(r);

    // bounce off the sides of the screen?
    /*if (rockets[r].x < 0 || rockets[r].x > (int)WIDTH * 256) {
      trackingObjectSpeedX[r] = (-trackingObjectSpeedX[r] * 248) >> 8;
      // force back onto the screen, otherwise they eventually sneak away
      if (rockets[r].x < 0) {
        rockets[r].x = trackingObjectSpeedX[r];
        trackingObjectSpeedY[r] += trackingObjectSpeedX[r];
      } else {
        rockets[r].x = (WIDTH * 256) - trackingObjectSpeedX[r];
      }
    }*/

    // popcornGravity
    trackingObjectSpeedY[r] -= popcornGravity;

    // viscosity
    trackingObjectSpeedX[r] *= 0.875;
    trackingObjectSpeedY[r] *= 0.875;

  
//void popcornPaint() {
    // make the acme gray, because why not
    if (-0.004 > trackingObjectSpeedY[r] and trackingObjectSpeedY[r] < 0.004)
      drawPixelXYF(trackingObjectPosX[r], trackingObjectPosY[r], (modes[currentMode].Brightness & 0x01) ?
                ColorFromPalette(*curPalette, trackingObjectHue[r]) 
              : CRGB::Pink);
    else
      drawPixelXYF(trackingObjectPosX[r], trackingObjectPosY[r], (modes[currentMode].Brightness & 0x01) ? 
                CRGB::Gray 
              : ColorFromPalette(*curPalette, trackingObjectHue[r]));
  }
}

// ------------- Светлячки 2 - Светлячки в банке - Мотыльки - Лампа с мотыльками --------------
// (c) SottNick

//#define trackingOBJECT_MAX_COUNT           (100U) // максимальное количество мотыльков
#define BUTTERFLY_FIX_COUNT               (20U) // количество мотыльков для режима, когда бегунок Масштаб регулирует цвет
//float trackingObjectPosX[trackingOBJECT_MAX_COUNT];
//float trackingObjectPosY[trackingOBJECT_MAX_COUNT];
//float trackingObjectSpeedX[trackingOBJECT_MAX_COUNT];
//float trackingObjectSpeedY[trackingOBJECT_MAX_COUNT];
//float trackingObjectShift[trackingOBJECT_MAX_COUNT];
//uint8_t trackingObjectHue[trackingOBJECT_MAX_COUNT];
//uint8_t trackingObjectState[trackingOBJECT_MAX_COUNT];

void butterflysRoutine(bool isColored)
{
  bool isWings = modes[currentMode].Speed & 0x01;
  if (loadingFlag)
  {
    loadingFlag = false;
    speedfactor = (float)modes[currentMode].Speed / 2048.0f + 0.001f;
    randomSeed(millis());
    if (isColored) // для режима смены цвета фона фиксируем количество мотыльков
      deltaValue = (modes[currentMode].Scale > trackingOBJECT_MAX_COUNT) ? trackingOBJECT_MAX_COUNT : modes[currentMode].Scale; 
    else
      deltaValue = BUTTERFLY_FIX_COUNT;
    for (uint8_t i = 0U; i < trackingOBJECT_MAX_COUNT; i++)
    {
      trackingObjectPosX[i] = random8(WIDTH);
      trackingObjectPosY[i] = random8(HEIGHT);
      trackingObjectSpeedX[i] = 0;
      trackingObjectSpeedY[i] = 0;
      trackingObjectShift[i] = 0;
      trackingObjectHue[i] = (isColored) ? random8() : 255U;
      trackingObjectState[i] = 255U;
    }
    //для инверсии, чтобы сто раз не пересчитывать
    if (modes[currentMode].Scale != 1U)
      hue = (float)(modes[currentMode].Scale - 1U) * 2.6;
    else
      hue = random8();
    //hue2 = (modes[currentMode].Scale == 100U) ? 0U : 255U;  // белый или цветной фон
    if (modes[currentMode].Scale == 100U){ // вместо белого будет желтоватая лампа
      hue2 = 170U;
      hue = 31U;
    }
    else
     hue2 = 255U;
  }
  if (isWings && isColored)
    dimAll(35U); // для крылышков
  else
    FastLED.clear();

  float maxspeed;
  uint8_t tmp;
  if (++step >= deltaValue)
    step = 0U;
  for (uint8_t i = 0U; i < deltaValue; i++)
  {
    trackingObjectPosX[i] += trackingObjectSpeedX[i]*speedfactor;
    trackingObjectPosY[i] += trackingObjectSpeedY[i]*speedfactor;

    if (trackingObjectPosX[i] < 0)
      trackingObjectPosX[i] = (float)(WIDTH - 1) + trackingObjectPosX[i];
    if (trackingObjectPosX[i] > WIDTH - 1)
      trackingObjectPosX[i] = trackingObjectPosX[i] + 1 - WIDTH;

    if (trackingObjectPosY[i] < 0)
    {
      trackingObjectPosY[i] = -trackingObjectPosY[i];
      trackingObjectSpeedY[i] = -trackingObjectSpeedY[i];
      //trackingObjectSpeedX[i] = -trackingObjectSpeedX[i];
    }
    if (trackingObjectPosY[i] > HEIGHT - 1U)
    {
      trackingObjectPosY[i] = (HEIGHT << 1U) - 2U - trackingObjectPosY[i];
      trackingObjectSpeedY[i] = -trackingObjectSpeedY[i];
      //trackingObjectSpeedX[i] = -trackingObjectSpeedX[i];
    }

    //проворот траектории
    maxspeed = fabs(trackingObjectSpeedX[i])+fabs(trackingObjectSpeedY[i]); // максимальная суммарная скорость
    if (maxspeed == fabs(trackingObjectSpeedX[i] + trackingObjectSpeedY[i]))
      {
          if (trackingObjectSpeedX[i] > 0) // правый верхний сектор вектора
          {
            trackingObjectSpeedX[i] += trackingObjectShift[i];
            if (trackingObjectSpeedX[i] > maxspeed) // если вектор переехал вниз
              {
                trackingObjectSpeedX[i] = maxspeed + maxspeed - trackingObjectSpeedX[i];
                trackingObjectSpeedY[i] = trackingObjectSpeedX[i] - maxspeed;
              }
            else
              trackingObjectSpeedY[i] = maxspeed - fabs(trackingObjectSpeedX[i]);
          }
          else                           // левый нижний сектор
          {
            trackingObjectSpeedX[i] -= trackingObjectShift[i];
            if (trackingObjectSpeedX[i] + maxspeed < 0) // если вектор переехал вверх
              {
                trackingObjectSpeedX[i] = 0 - trackingObjectSpeedX[i] - maxspeed - maxspeed;
                trackingObjectSpeedY[i] = maxspeed - fabs(trackingObjectSpeedX[i]);
              }
            else
              trackingObjectSpeedY[i] = fabs(trackingObjectSpeedX[i]) - maxspeed;
          }
      }
    else //левый верхний и правый нижний секторы вектора
      {
          if (trackingObjectSpeedX[i] > 0) // правый нижний сектор
          {
            trackingObjectSpeedX[i] -= trackingObjectShift[i];
            if (trackingObjectSpeedX[i] > maxspeed) // если вектор переехал наверх
              {
                trackingObjectSpeedX[i] = maxspeed + maxspeed - trackingObjectSpeedX[i];
                trackingObjectSpeedY[i] = maxspeed - trackingObjectSpeedX[i];
              }
            else
              trackingObjectSpeedY[i] = fabs(trackingObjectSpeedX[i]) - maxspeed;
          }
          else                           // левый верхний сектор
          {
            trackingObjectSpeedX[i] += trackingObjectShift[i];
            if (trackingObjectSpeedX[i] + maxspeed < 0) // если вектор переехал вниз
              {
                trackingObjectSpeedX[i] = 0 - trackingObjectSpeedX[i] - maxspeed - maxspeed;
                trackingObjectSpeedY[i] = 0 - trackingObjectSpeedX[i] - maxspeed;
              }
            else
              trackingObjectSpeedY[i] = maxspeed - fabs(trackingObjectSpeedX[i]);
          }
      }
    
    if (trackingObjectState[i] == 255U)
    {
      if (step == i && random8(2U) == 0U)//(step == 0U && ((pcnt + i) & 0x01))
      {
        trackingObjectState[i] = random8(220U,244U);
        trackingObjectSpeedX[i] = (float)random8(101U) / 20.0f + 1.0f;
        if (random8(2U) == 0U) trackingObjectSpeedX[i] = -trackingObjectSpeedX[i];
        trackingObjectSpeedY[i] = (float)random8(101U) / 20.0f + 1.0f;
        if (random8(2U) == 0U) trackingObjectSpeedY[i] = -trackingObjectSpeedY[i];
        // проворот траектории
        //trackingObjectShift[i] = (float)random8((fabs(trackingObjectSpeedX[i])+fabs(trackingObjectSpeedY[i]))*2.0+2.0) / 40.0f;
        trackingObjectShift[i] = (float)random8((fabs(trackingObjectSpeedX[i])+fabs(trackingObjectSpeedY[i]))*20.0f+2.0f) / 200.0f;
        if (random8(2U) == 0U) trackingObjectShift[i] = -trackingObjectShift[i];
      }
    }
    else 
    {
      if (step == i)
        trackingObjectState[i]++;
      tmp = 255U - trackingObjectState[i];
      if (tmp == 0U || ((uint16_t)(trackingObjectPosX[i] * tmp) % tmp == 0U && (uint16_t)(trackingObjectPosY[i] * tmp) % tmp == 0U))
      {
        trackingObjectPosX[i] = round(trackingObjectPosX[i]);
        trackingObjectPosY[i] = round(trackingObjectPosY[i]);
        trackingObjectSpeedX[i] = 0;
        trackingObjectSpeedY[i] = 0;
        trackingObjectShift[i] = 0;
        trackingObjectState[i] = 255U;
      }
    }

    if (isWings)
      drawPixelXYF(trackingObjectPosX[i], trackingObjectPosY[i], CHSV(trackingObjectHue[i], 255U, (trackingObjectState[i] == 255U) ? 255U : 128U + random8(2U) * 111U)); // это процедура рисования с нецелочисленными координатами. ищите её в прошивке
    else
      drawPixelXYF(trackingObjectPosX[i], trackingObjectPosY[i], CHSV(trackingObjectHue[i], 255U, trackingObjectState[i])); // это процедура рисования с нецелочисленными координатами. ищите её в прошивке
  }

  // постобработка кадра
  if (isColored){
    for (uint8_t i = 0U; i < deltaValue; i++) // ещё раз рисуем всех Мотыльков, которые "сидят на стекле"
      if (trackingObjectState[i] == 255U)
        drawPixelXY(trackingObjectPosX[i], trackingObjectPosY[i], CHSV(trackingObjectHue[i], 255U, trackingObjectState[i]));
  }
  else {
    //теперь инверсия всей матрицы
    if (modes[currentMode].Scale == 1U)
      if (++deltaHue == 0U) hue++;
    for (uint16_t i = 0U; i < NUM_LEDS; i++)
      leds[i] = CHSV(hue, hue2, 255U - leds[i].r);
  }
}


// ------------------------------ ЭФФЕКТ ПРЫГУНЫ ----------------------
// стырено откуда-то by @obliterator
// https://github.com/DmytroKorniienko/FireLamp_JeeUI/blob/templ/src/effects.cpp

//Leaper leapers[20];
//вместо класса Leaper будем повторно использовать переменные из эффекта мячики и мотыльки
//float x, y; будет:
//float trackingObjectPosX[enlargedOBJECT_MAX_COUNT];
//float trackingObjectPosY[enlargedOBJECT_MAX_COUNT];
//float xd, yd; будет:
////float trackingObjectSpeedY[enlargedOBJECT_MAX_COUNT];                   // As time goes on the impact velocity will change, so make an array to store those values
////float trackingObjectShift[enlargedOBJECT_MAX_COUNT];                       // Coefficient of Restitution (bounce damping)
//CHSV color; будет:
////uint8_t trackingObjectHue[enlargedOBJECT_MAX_COUNT];

void LeapersRestart_leaper(uint8_t l) {
  // leap up and to the side with some random component
  trackingObjectSpeedY[l] = (1 * (float)random8(1, 100) / 100);
  trackingObjectShift[l] = (2 * (float)random8(1, 100) / 100);

  // for variety, sometimes go 50% faster
  if (random8() < 12) {
    trackingObjectSpeedY[l] += trackingObjectSpeedY[l] * 0.5;
    trackingObjectShift[l] += trackingObjectShift[l] * 0.5;
  }

  // leap towards the centre of the screen
  if (trackingObjectPosX[l] > (WIDTH / 2)) {
    trackingObjectSpeedY[l] = -trackingObjectSpeedY[l];
  }
}

void LeapersMove_leaper(uint8_t l) {
#define GRAVITY            0.06
#define SETTLED_THRESHOLD  0.1
#define WALL_FRICTION      0.95
#define WIND               0.95    // wind resistance

  trackingObjectPosX[l] += trackingObjectSpeedY[l];
  trackingObjectPosY[l] += trackingObjectShift[l];

  // bounce off the floor and ceiling?
  if (trackingObjectPosY[l] < 0 || trackingObjectPosY[l] > HEIGHT - 1) {
    trackingObjectShift[l] = (-trackingObjectShift[l] * WALL_FRICTION);
    trackingObjectSpeedY[l] = ( trackingObjectSpeedY[l] * WALL_FRICTION);
    trackingObjectPosY[l] += trackingObjectShift[l];
    if (trackingObjectPosY[l] < 0) trackingObjectPosY[l] = 0;
    // settled on the floor?
    if (trackingObjectPosY[l] <= SETTLED_THRESHOLD && fabs(trackingObjectShift[l]) <= SETTLED_THRESHOLD) {
      LeapersRestart_leaper(l);
    }
  }

  // bounce off the sides of the screen?
  if (trackingObjectPosX[l] <= 0 || trackingObjectPosX[l] >= WIDTH - 1) {
    trackingObjectSpeedY[l] = (-trackingObjectSpeedY[l] * WALL_FRICTION);
    if (trackingObjectPosX[l] <= 0) {
      trackingObjectPosX[l] = trackingObjectSpeedY[l];
    } else {
      trackingObjectPosX[l] = WIDTH - 1 - trackingObjectSpeedY[l];
    }
  }

  trackingObjectShift[l] -= GRAVITY;
  trackingObjectSpeedY[l] *= WIND;
  trackingObjectShift[l] *= WIND;
}


void LeapersRoutine(){
  //unsigned num = map(scale, 0U, 255U, 6U, sizeof(boids) / sizeof(*boids));
  if (loadingFlag)
  {
    loadingFlag = false;
    setCurrentPalette();    
    //FastLED.clear();
    //enlargedObjectNUM = (modes[currentMode].Scale - 1U) / 99.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) % 11U / 10.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
    //if (enlargedObjectNUM < 2U) enlargedObjectNUM = 2U;

    for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) {
      trackingObjectPosX[i] = random8(WIDTH);
      trackingObjectPosY[i] = random8(HEIGHT);

      //curr->color = CHSV(random(1U, 255U), 255U, 255U);
      trackingObjectHue[i] = random8();
    }
  }

  //myLamp.dimAll(0); накой хрен делать затухание на 100%?
  FastLED.clear();

  for (uint8_t i = 0; i < enlargedObjectNUM; i++) {
    LeapersMove_leaper(i);
    //drawPixelXYF(trackingObjectPosX[i], trackingObjectPosY[i], CHSV(trackingObjectHue[i], 255U, 255U));
    drawPixelXYF(trackingObjectPosX[i], trackingObjectPosY[i], ColorFromPalette(*curPalette, trackingObjectHue[i]));
  };

  blurScreen(20);
}

// ------------------------------ ЭФФЕКТ ДЫМ ----------------------
// (c) SottNick

void MultipleStreamSmoke(bool isColored){
    if (loadingFlag)
    {
      loadingFlag = false;
      hue2 = 0U;
    }
//if (modes[currentMode].Brightness & 0x01) // для проверки движения источника дыма можно включить
  dimAll(254U);//(255U - modes[currentMode].Scale * 2);
//else     FastLED.clear();

  deltaHue++;
  CRGB color;//, color2;
  if (isColored)
  {
    if (hue2 == modes[currentMode].Scale)
      {
        hue2 = 0U;
        hue = random8();
      }
    if (deltaHue & 0x01)//((deltaHue >> 2U) == 0U) // какой-то умножитель охота подключить к задержке смены цвета, но хз какой...
      hue2++;

    //color = CHSV(hue, 255U, 255U);
    hsv2rgb_spectrum(CHSV(hue, 255U, 127U), color);
    //hsv2rgb_spectrum(CHSV(hue, 255U, 88U), color2);
  }
  else {
    //color = CHSV((modes[currentMode].Scale - 1U) * 2.6, (modes[currentMode].Scale > 98U) ? 0U : 255U, 255U);
    hsv2rgb_spectrum(CHSV((modes[currentMode].Scale - 1U) * 2.6, (modes[currentMode].Scale > 98U) ? 0U : 255U, 127U), color);
    //hsv2rgb_spectrum(CHSV((modes[currentMode].Scale - 1U) * 2.6, (modes[currentMode].Scale > 98U) ? 0U : 255U,  88U), color2);
  }

  //deltaHue2--;
  if (random8(WIDTH) != 0U) // встречная спираль движется не всегда синхронно основной
    deltaHue2--;

  for (uint8_t y = 0; y < HEIGHT; y++) {
    leds[getPixelNumber((deltaHue  + y + 1U)%WIDTH, HEIGHT - 1U - y)] += color;
    leds[getPixelNumber((deltaHue  + y     )%WIDTH, HEIGHT - 1U - y)] += color; //color2
    leds[getPixelNumber((deltaHue2 + y     )%WIDTH,               y)] += color;
    leds[getPixelNumber((deltaHue2 + y + 1U)%WIDTH,               y)] += color; //color2
  }

//if (modes[currentMode].Brightness & 0x01) { // для проверки движения источника дыма можно включить эту опцию
  // Noise
  
  // скорость движения по массиву noise
  //uint32_t mult = 500U * ((modes[currentMode].Scale - 1U) % 10U);
  noise32_x[0] += 1500;//1000;
  noise32_y[0] += 1500;//1000;
  noise32_z[0] += 1500;//1000;

  // хрен знает что
  //mult = 1000U * ((modes[currentMode].Speed - 1U) % 10U);
  scale32_x[0] = 4000;
  scale32_y[0] = 4000;
  FillNoise(0);
  //MoveX(3);
  //MoveY(3);

  // допустимый отлёт зажжённого пикселя от изначально присвоенного местоположения (от 0 до указанного значения. дробное) 
  //mult = (modes[currentMode].Brightness - 1U) % 10U;
  MoveFractionalNoiseX(3);//4
  MoveFractionalNoiseY(3);//4

  blurScreen(20); // без размытия как-то пиксельно, наверное...  
//} endif (modes[currentMode].Brightness & 0x01)
}

// ------------------------------ ЭФФЕКТЫ ПИКАССО ----------------------
// стырено откуда-то by @obliterator
// https://github.com/DmytroKorniienko/FireLamp_JeeUI/blob/templ/src/effects.cpp

//вместо класса Particle будем повторно использовать переменные из эффекта мячики и мотыльки
//        float position_x = 0;
//float trackingObjectPosX[enlargedOBJECT_MAX_COUNT];
//        float position_y = 0;
//float trackingObjectPosY[enlargedOBJECT_MAX_COUNT];
//        float speed_x = 0;
////float trackingObjectSpeedY[enlargedOBJECT_MAX_COUNT];                   // As time goes on the impact velocity will change, so make an array to store those values
//        float speed_y = 0;
////float trackingObjectShift[enlargedOBJECT_MAX_COUNT];                       // Coefficient of Restitution (bounce damping)
//        CHSV color;
////uint8_t trackingObjectHue[enlargedOBJECT_MAX_COUNT];
//        uint8_t hue_next = 0;
//uint8_t trackingObjectState[enlargedOBJECT_MAX_COUNT] ;                       // прикручено при адаптации для распределения мячиков по радиусу лампы
//        int8_t hue_step = 0;
//uint16_t   trackingObjectPosY[enlargedOBJECT_MAX_COUNT] ;                       // The integer position of the dot on the strip (LED index)

void PicassoGenerate(bool reset){
  if (loadingFlag)
  {
    loadingFlag = false;
    //setCurrentPalette();    
    FastLED.clear();
    enlargedObjectNUM = (modes[currentMode].Scale - 1U) / 99.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    //enlargedObjectNUM = (modes[currentMode].Scale - 1U) % 11U / 10.0 * (enlargedOBJECT_MAX_COUNT - 1U) + 1U;
    if (enlargedObjectNUM > enlargedOBJECT_MAX_COUNT) enlargedObjectNUM = enlargedOBJECT_MAX_COUNT;
    if (enlargedObjectNUM < 2U) enlargedObjectNUM = 2U;

    double minSpeed = 0.2, maxSpeed = 0.8;
    
    for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) { 
      trackingObjectPosX[i] = random8(WIDTH);
      trackingObjectPosY[i] = random8(HEIGHT);

      //curr->color = CHSV(random(1U, 255U), 255U, 255U);
      trackingObjectHue[i] = random8();

      trackingObjectSpeedY[i] = +((-maxSpeed / 3) + (maxSpeed * (float)random8(1, 100) / 100));
      trackingObjectSpeedY[i] += trackingObjectSpeedY[i] > 0 ? minSpeed : -minSpeed;

      trackingObjectShift[i] = +((-maxSpeed / 2) + (maxSpeed * (float)random8(1, 100) / 100));
      trackingObjectShift[i] += trackingObjectShift[i] > 0 ? minSpeed : -minSpeed;

      trackingObjectState[i] = trackingObjectHue[i];

    }
  }
  for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) {

      if (reset) {
        trackingObjectState[i] = random8();
        trackingObjectPosY[i] = (trackingObjectState[i] - trackingObjectHue[i]) / 25;
      }
      if (trackingObjectState[i] != trackingObjectHue[i] && trackingObjectPosY[i]) {
        trackingObjectHue[i] += trackingObjectPosY[i];
      }
  }

}

void PicassoPosition(){
  for (uint8_t i = 0 ; i < enlargedObjectNUM ; i++) { 
    if (trackingObjectPosX[i] + trackingObjectSpeedY[i] > WIDTH || trackingObjectPosX[i] + trackingObjectSpeedY[i] < 0) {
      trackingObjectSpeedY[i] = -trackingObjectSpeedY[i];
    }

    if (trackingObjectPosY[i] + trackingObjectShift[i] > HEIGHT || trackingObjectPosY[i] + trackingObjectShift[i] < 0) {
      trackingObjectShift[i] = -trackingObjectShift[i];
    }

    trackingObjectPosX[i] += trackingObjectSpeedY[i];
    trackingObjectPosY[i] += trackingObjectShift[i];
  };
}

void PicassoRoutine(){
  PicassoGenerate(false);
  PicassoPosition();

//  for (unsigned i = 0; i < numParticles - 2; i+=2) {
//    Particle *p1 = (Particle *)&particles[i];
//    Particle *p2 = (Particle *)&particles[i + 1];
//    DrawLine(p1->position_x, p1->position_y, p2->position_x, p2->position_y, p1->color);
//  }
  for (uint8_t i = 0 ; i < enlargedObjectNUM - 2U ; i+=2) 
    DrawLine(trackingObjectPosX[i], trackingObjectPosY[i], trackingObjectPosX[i+1U], trackingObjectPosY[i+1U], CHSV(trackingObjectHue[i], 255U, 255U));
    //DrawLine(trackingObjectPosX[i], trackingObjectPosY[i], trackingObjectPosX[i+1U], trackingObjectPosY[i+1U], ColorFromPalette(*curPalette, trackingObjectHue[i]));


  EVERY_N_MILLIS(20000){
    PicassoGenerate(true);
  }

  blurScreen(80);
}

void PicassoRoutine2(){
  PicassoGenerate(false);
  PicassoPosition();
  dimAll(180);

//  for (unsigned i = 0; i < numParticles - 1; i++) {
//    Particle *p1 = (Particle *)&particles[i];
//    Particle *p2 = (Particle *)&particles[i + 1];
//    DrawLineF(p1->position_x, p1->position_y, p2->position_x, p2->position_y, p1->color);
//  }
  for (uint8_t i = 0 ; i < enlargedObjectNUM - 1U ; i++) 
    DrawLineF(trackingObjectPosX[i], trackingObjectPosY[i], trackingObjectPosX[i+1U], trackingObjectPosY[i+1U], CHSV(trackingObjectHue[i], 255U, 255U));
    //DrawLineF(trackingObjectPosX[i], trackingObjectPosY[i], trackingObjectPosX[i+1U], trackingObjectPosY[i+1U], ColorFromPalette(*curPalette, trackingObjectHue[i]));

  EVERY_N_MILLIS(20000){
    PicassoGenerate(true);
  }

  blurScreen(80);

}

void PicassoRoutine3(){
  PicassoGenerate(false);
  PicassoPosition();
  dimAll(180);

//  for (unsigned i = 0; i < numParticles - 2; i+=2) {
//    Particle *p1 = (Particle *)&particles[i];
//    Particle *p2 = (Particle *)&particles[i + 1];
//    drawCircleF(std::fabs(p1->position_x - p2->position_x), std::fabs(p1->position_y - p2->position_y), std::fabs(p1->position_x - p1->position_y), p1->color);
//  }
  for (uint8_t i = 0 ; i < enlargedObjectNUM - 2U ; i+=2) 
    drawCircleF(fabs(trackingObjectPosX[i] - trackingObjectPosX[i+1U]), fabs(trackingObjectPosY[i] - trackingObjectPosX[i+1U]), fabs(trackingObjectPosX[i] - trackingObjectPosY[i]), CHSV(trackingObjectHue[i], 255U, 255U));
    //drawCircleF(fabs(trackingObjectPosX[i] - trackingObjectPosX[i+1U]), fabs(trackingObjectPosY[i] - trackingObjectPosX[i+1U]), fabs(trackingObjectPosX[i] - trackingObjectPosY[i]), ColorFromPalette(*curPalette, trackingObjectHue[i]));
    
  EVERY_N_MILLIS(20000){
    PicassoGenerate(true);
  }

  blurScreen(80);

}

// ------------------------------ ЭФФЕКТ МЕРЦАНИЕ ----------------------
// (c) SottNick

#define TWINKLES_SPEEDS 4     // всего 4 варианта скоростей мерцания
#define TWINKLES_MULTIPLIER 6 // слишком медленно, если на самой медленной просто по единичке к яркости добавлять

void twinklesRoutine(){
    if (loadingFlag)
    {
      loadingFlag = false;
      setCurrentPalette();
      hue = 0U;
      deltaValue = (modes[currentMode].Scale - 1U) % 11U + 1U;  // вероятность пикселя загореться от 1/1 до 1/11
      for (uint32_t idx=0; idx < NUM_LEDS; idx++) {
        if (random8(deltaValue) == 0){
          ledsbuff[idx].r = random8();                          // оттенок пикселя
          ledsbuff[idx].g = random8(1, TWINKLES_SPEEDS * 2 +1); // скорость и направление (нарастает 1-4 или угасает 5-8)
          ledsbuff[idx].b = random8();                          // яркость
        }
        else
          ledsbuff[idx] = 0;                                    // всё выкл
      }
    }
    for (uint32_t idx=0; idx < NUM_LEDS; idx++) {
      if (ledsbuff[idx].b == 0){
        if (random8(deltaValue) == 0 && hue > 0){  // если пиксель ещё не горит, зажигаем каждый ХЗй
          ledsbuff[idx].r = random8();                          // оттенок пикселя
          ledsbuff[idx].g = random8(1, TWINKLES_SPEEDS +1);     // скорость и направление (нарастает 1-4, но не угасает 5-8)
          ledsbuff[idx].b = ledsbuff[idx].g;                    // яркость
          hue--; // уменьшаем количество погасших пикселей
        }
      }
      else if (ledsbuff[idx].g <= TWINKLES_SPEEDS){             // если нарастание яркости
        if (ledsbuff[idx].b > 255U - ledsbuff[idx].g - TWINKLES_MULTIPLIER){            // если досигнут максимум
          ledsbuff[idx].b = 255U;
          ledsbuff[idx].g = ledsbuff[idx].g + TWINKLES_SPEEDS;
        }
        else
          ledsbuff[idx].b = ledsbuff[idx].b + ledsbuff[idx].g + TWINKLES_MULTIPLIER;
      }
      else {                                                    // если угасание яркости
        if (ledsbuff[idx].b <= ledsbuff[idx].g - TWINKLES_SPEEDS + TWINKLES_MULTIPLIER){// если досигнут минимум
          ledsbuff[idx].b = 0;                                  // всё выкл
          hue++; // считаем количество погасших пикселей
        }
        else
          ledsbuff[idx].b = ledsbuff[idx].b - ledsbuff[idx].g + TWINKLES_SPEEDS - TWINKLES_MULTIPLIER;
      }
      if (ledsbuff[idx].b == 0)
        leds[idx] = 0U;
      else
        leds[idx] = ColorFromPalette(*curPalette, ledsbuff[idx].r, ledsbuff[idx].b);
    }
}


// ============= Огонь 2020 ===============
// (c) SottNick
//сильно по мотивам https://pastebin.com/RG0QGzfK
//Perlin noise fire procedure by Yaroslaw Turbin
//https://www.reddit.com/r/FastLED/comments/hgu16i/my_fire_effect_implementation_based_on_perlin/

#define SPARKLES_NUM  (WIDTH / 8U) // не более чем  enlargedOBJECT_MAX_COUNT (WIDTH * 2)
//float   trackingObjectPosX[SPARKLES_NUM]; // это для искорок. по идее должны быть uint8_t, но были только такие
//float   trackingObjectPosY[SPARKLES_NUM];
//uint8_t shiftHue[HEIGHT];
//uint16_t ff_y, ff_z; используем для сдвига нойза переменные из общих
//uint8_t deltaValue;

void fire2020Routine2(){
  if (loadingFlag) {
    loadingFlag = false;
    if (modes[currentMode].Scale > 100U) modes[currentMode].Scale = 100U; // чтобы не было проблем при прошивке без очистки памяти
    /*if (modes[currentMode].Scale == 100U)
      deltaValue = random8(9U);
    else
      deltaValue = modes[currentMode].Scale * 0.0899; // /100.0F * ((sizeof(firePalettes)/sizeof(TProgmemRGBPalette16 *))-0.01F))*/
    deltaValue = modes[currentMode].Scale * 0.0899;// /100.0F * ((sizeof(palette_arr) /sizeof(TProgmemRGBPalette16 *))-0.01F));
    if (deltaValue == 3U ||deltaValue == 4U)
      curPalette =  palette_arr[deltaValue]; // (uint8_t)(modes[currentMode].Scale/100.0F * ((sizeof(palette_arr) /sizeof(TProgmemRGBPalette16 *))-0.01F))];
    else
      curPalette = firePalettes[deltaValue]; // (uint8_t)(modes[currentMode].Scale/100.0F * ((sizeof(firePalettes)/sizeof(TProgmemRGBPalette16 *))-0.01F))];
    deltaValue = (((modes[currentMode].Scale - 1U) % 11U + 1U) << 4U) - 8U; // ширина языков пламени (масштаб шума Перлина)
    deltaHue = map(deltaValue, 8U, 168U, 8U, 84U); // высота языков пламени должна уменьшаться не так быстро, как ширина
    for (uint8_t j = 0; j < HEIGHT; j++) {
      shiftHue[j] = (HEIGHT - 1 - j) * 255 / (HEIGHT - 1); // init colorfade table
    }

    for (uint8_t i = 0; i < SPARKLES_NUM; i++) {
        trackingObjectPosY[i] = random8(HEIGHT);
        trackingObjectPosX[i] = random8(WIDTH);
    }
  }
  for (uint8_t i = 0; i < WIDTH; i++) {
    for (uint8_t j = 0; j < HEIGHT; j++) {
      leds[getPixelNumber(i,HEIGHT-1U-j)] = ColorFromPalette(*curPalette, qsub8(inoise8(i * deltaValue, (j+ff_y+random8(2)) * deltaHue, ff_z), shiftHue[j]), 255U);
    } 
  }

  //вставляем искорки из отдельного массива
  for (uint8_t i = 0; i < SPARKLES_NUM; i++) {
    //leds[getPixelNumber(trackingObjectPosX[i],trackingObjectPosY[i])] += ColorFromPalette(*curPalette, random(156, 255));   //trackingObjectHue[i] 
    if (trackingObjectPosY[i] > 3U){
      leds[getPixelNumber(trackingObjectPosX[i], trackingObjectPosY[i])] = leds[getPixelNumber(trackingObjectPosX[i], 3U)];
      leds[getPixelNumber(trackingObjectPosX[i], trackingObjectPosY[i])].fadeToBlackBy( trackingObjectPosY[i]*2U );
    }
    trackingObjectPosY[i]++;
    if (trackingObjectPosY[i] >= HEIGHT){
      trackingObjectPosY[i] = random8(4U);
      trackingObjectPosX[i] = random8(WIDTH);
    }
    if (!random8(map(255U-deltaValue, 87U, 247U, 4U, 32U)))
      trackingObjectPosX[i] = (WIDTH + (uint8_t)trackingObjectPosX[i] + 1U - random8(3U)) % WIDTH;
  }
  ff_y++;
  if (ff_y & 0x01)
    ff_z++;
}

// ------------------------------ ЭФФЕКТ КОЛЬЦА / КОДОВЫЙ ЗАМОК ----------------------
// (c) SottNick
// из-за повторного использоваия переменных от других эффектов теперь в этом коде невозможно что-то понять.
// поэтому для понимания придётся сперва заменить названия переменных на человеческие. но всё равно это песец, конечно.
//uint8_t deltaHue2; // максимальне количество пикселей в кольце (толщина кольца) от 1 до HEIGHT / 2 + 1
//uint8_t deltaHue; // количество колец от 2 до HEIGHT
//uint8_t noise3d[1][1][HEIGHT]; // начальный оттенок каждого кольца (оттенка из палитры) 0-255
//uint8_t shiftValue[HEIGHT]; // местоположение начального оттенка кольца 0-WIDTH-1
//uint8_t shiftHue[HEIGHT]; // 4 бита на ringHueShift, 4 на ringHueShift2
////ringHueShift[ringsCount]; // шаг градиета оттенка внутри кольца -8 - +8 случайное число
////ringHueShift2[ringsCount]; // обычная скорость переливания оттенка всего кольца -8 - +8 случайное число
//uint8_t deltaValue; // кольцо, которое в настоящий момент нужно провернуть
//uint8_t step; // оставшееся количество шагов, на которое нужно провернуть активное кольцо - случайное от WIDTH/5 до WIDTH-3
//uint8_t hue, hue2; // количество пикселей в нижнем (hue) и верхнем (hue2) кольцах

void ringsRoutine(){
    uint8_t h, x, y;
    if (loadingFlag)
    {
      loadingFlag = false;
      setCurrentPalette();

      //deltaHue2 = (modes[currentMode].Scale - 1U) / 99.0 * (HEIGHT / 2 - 1U) + 1U; // толщина кольца в пикселях. если на весь бегунок масштаба (от 1 до HEIGHT / 2 + 1)
      deltaHue2 = (modes[currentMode].Scale - 1U) % 11U + 1U; // толщина кольца от 1 до 11 для каждой из палитр
      deltaHue = HEIGHT / deltaHue2 + ((HEIGHT % deltaHue2 == 0U) ? 0U : 1U); // количество колец
      hue2 = deltaHue2 - (deltaHue2 * deltaHue - HEIGHT) / 2U; // толщина верхнего кольца. может быть меньше нижнего
      hue = HEIGHT - hue2 - (deltaHue - 2U) * deltaHue2; // толщина нижнего кольца = всё оставшееся
      for (uint8_t i = 0; i < deltaHue; i++)
      {
        noise3d[0][0][i] = random8(257U - WIDTH / 2U); // начальный оттенок кольца из палитры 0-255 за минусом длины кольца, делённой пополам
        shiftHue[i] = random8();
        shiftValue[i] = 0U; //random8(WIDTH); само прокрутится постепенно
        step = 0U;
        //do { // песец конструкцию придумал бредовую
        //  step = WIDTH - 3U - random8((WIDTH - 3U) * 2U); само присвоится при первом цикле
        //} while (step < WIDTH / 5U || step > 255U - WIDTH / 5U);
        deltaValue = random8(deltaHue);
      }
      
    }
    for (uint8_t i = 0; i < deltaHue; i++)
    {
      if (i != deltaValue) // если это не активное кольцо
        {
          h = shiftHue[i] & 0x0F; // сдвигаем оттенок внутри кольца
          if (h > 8U)
            //noise3d[0][0][i] += (uint8_t)(7U - h); // с такой скоростью сдвиг оттенка от вращения кольца не отличается
            noise3d[0][0][i]--;
          else
            //noise3d[0][0][i] += h;
            noise3d[0][0][i]++;
        }
      else
        {
          if (step == 0) // если сдвиг активного кольца завершён, выбираем следующее
            {
              deltaValue = random8(deltaHue);
              do {
                step = WIDTH - 3U - random8((WIDTH - 3U) * 2U); // проворот кольца от хз до хз 
              } while (step < WIDTH / 5U || step > 255U - WIDTH / 5U);
            }
          else
            {
              if (step > 127U)
                {
                  step++;
                  shiftValue[i] = (shiftValue[i] + 1U) % WIDTH;
                }
              else
                {
                  step--;
                  shiftValue[i] = (shiftValue[i] - 1U + WIDTH) % WIDTH;
                }
            }
        }
        // отрисовываем кольца
        h = (shiftHue[i] >> 4) & 0x0F; // берём шаг для градиента вутри кольца
        if (h > 8U)
          h = 7U - h;
        for (uint8_t j = 0U; j < ((i == 0U) ? hue : ((i == deltaHue - 1U) ? hue2 : deltaHue2)); j++) // от 0 до (толщина кольца - 1)
        {
          y = i * deltaHue2 + j - ((i == 0U) ? 0U : deltaHue2 - hue);
          // mod для чётных скоростей by @kostyamat - получается какая-то другая фигня. не стоит того
          //for (uint8_t k = 0; k < WIDTH / ((modes[currentMode].Speed & 0x01) ? 2U : 4U); k++) // полукольцо для нечётных скоростей и четверть кольца для чётных
          for (uint8_t k = 0; k < WIDTH / 2U; k++) // полукольцо
            {
              x = (shiftValue[i] + k) % WIDTH; // первая половина кольца
              leds[getPixelNumber(x, y)] = ColorFromPalette(*curPalette, noise3d[0][0][i] + k * h);
              x = (WIDTH - 1 + shiftValue[i] - k) % WIDTH; // вторая половина кольца (зеркальная первой)
              leds[getPixelNumber(x, y)] = ColorFromPalette(*curPalette, noise3d[0][0][i] + k * h);
            }
          if (WIDTH & 0x01) //(WIDTH % 2U > 0U) // если число пикселей по ширине матрицы нечётное, тогда не забываем и про среднее значение
          {
            x = (shiftValue[i] + WIDTH / 2U) % WIDTH;
            leds[getPixelNumber(x, y)] = ColorFromPalette(*curPalette, noise3d[0][0][i] + WIDTH / 2U * h);
          }
        }
    }
}

// ********************** SHADOWS ***********************
// https://github.com/vvip-68/GyverPanelWiFi/blob/master/firmware/GyverPanelWiFi_v1.04/effects.ino
// (c) vvip-68
void shadowsRoutine() {
/*  if (loadingFlag) {
    // modeCode = MC_SHADOWS;
    loadingFlag = false;
  }
*/

  static uint16_t sPseudotime = 0;
  static uint16_t sLastMillis = 0;
  static uint16_t sHue16 = 0;
 
  uint8_t sat8 = beatsin88( 87, 220, 250);
  uint8_t brightdepth = beatsin88( 341, 96, 224);
  uint16_t brightnessthetainc16 = beatsin88( 203, (25 * 256), (40 * 256));
  uint8_t msmultiplier = beatsin88(map(modes[currentMode].Speed, 1, 255, 100, 255), 32, map(modes[currentMode].Speed, 1, 255, 60, 255));//beatsin88(147, 23, 60);

  uint16_t hue16 = sHue16;//gHue * 256;
  uint16_t hueinc16 = beatsin88(113, 1, 3000);
  
  uint16_t ms = millis();
  uint16_t deltams = ms - sLastMillis ;
  
  byte effectBrightness = modes[currentMode].Scale*2.55;//getBrightnessCalculated(globalBrightness, effectContrast[thisMode]);


  sLastMillis  = ms;
  sPseudotime += deltams * msmultiplier;
  sHue16 += deltams * beatsin88( 400, 5,9);
  uint16_t brightnesstheta16 = sPseudotime;

  //byte bri_dx = map8(255-effectSpeed, 50, 100);

  for( uint16_t i = 0 ; i < NUM_LEDS; i++) {
    hue16 += hueinc16;
    uint8_t hue8 = hue16 / 256;

    brightnesstheta16  += brightnessthetainc16;
    uint16_t b16 = sin16( brightnesstheta16  ) + 32768;

    uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536;
    uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536;
    bri8 += (255 - brightdepth);
    
    CRGB newcolor = CHSV( hue8, sat8, map8(bri8, map(effectBrightness, 32, 255, 32,125), map(effectBrightness, 32,255, 125,250))); 
    
    uint16_t pixelnumber = i;
    pixelnumber = (NUM_LEDS-1) - pixelnumber;
    
    nblend( leds[pixelnumber], newcolor, 64);
  }
}
